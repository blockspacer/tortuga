// This file is generated by rust-protobuf 2.0.5. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct GetDocumentRequest {
    // message fields
    pub name: ::std::string::String,
    pub mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    // message oneof groups
    pub consistency_selector: ::std::option::Option<GetDocumentRequest_oneof_consistency_selector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum GetDocumentRequest_oneof_consistency_selector {
    transaction(::std::vec::Vec<u8>),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl GetDocumentRequest {
    pub fn new() -> GetDocumentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .google.firestore.v1beta1.DocumentMask mask = 2;

    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::common::DocumentMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::common::DocumentMask {
        self.mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_mask(&self) -> &super::common::DocumentMask {
        self.mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }

    // bytes transaction = 3;

    pub fn clear_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(::std::vec::Vec::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_transaction(&self) -> &[u8] {
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(ref v)) => v,
            _ => &[],
        }
    }

    // .google.protobuf.Timestamp read_time = 5;

    pub fn clear_read_time(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.consistency_selector {
            ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
}

impl ::protobuf::Message for GetDocumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(GetDocumentRequest_oneof_consistency_selector::read_time(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::transaction(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(GetDocumentRequest_oneof_consistency_selector::read_time(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &GetDocumentRequest_oneof_consistency_selector::transaction(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &GetDocumentRequest_oneof_consistency_selector::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &GetDocumentRequest_oneof_consistency_selector::transaction(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &GetDocumentRequest_oneof_consistency_selector::read_time(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDocumentRequest {
        GetDocumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &GetDocumentRequest| { &m.name },
                    |m: &mut GetDocumentRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "mask",
                    |m: &GetDocumentRequest| { &m.mask },
                    |m: &mut GetDocumentRequest| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "transaction",
                    GetDocumentRequest::has_transaction,
                    GetDocumentRequest::get_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_time",
                    GetDocumentRequest::has_read_time,
                    GetDocumentRequest::get_read_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDocumentRequest>(
                    "GetDocumentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDocumentRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDocumentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDocumentRequest,
        };
        unsafe {
            instance.get(GetDocumentRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDocumentRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_mask();
        self.clear_transaction();
        self.clear_read_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDocumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDocumentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDocumentsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub collection_id: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    pub order_by: ::std::string::String,
    pub mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    pub show_missing: bool,
    // message oneof groups
    pub consistency_selector: ::std::option::Option<ListDocumentsRequest_oneof_consistency_selector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum ListDocumentsRequest_oneof_consistency_selector {
    transaction(::std::vec::Vec<u8>),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl ListDocumentsRequest {
    pub fn new() -> ListDocumentsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // string collection_id = 2;

    pub fn clear_collection_id(&mut self) {
        self.collection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection_id(&mut self, v: ::std::string::String) {
        self.collection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection_id(&mut self) -> &mut ::std::string::String {
        &mut self.collection_id
    }

    // Take field
    pub fn take_collection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection_id, ::std::string::String::new())
    }

    pub fn get_collection_id(&self) -> &str {
        &self.collection_id
    }

    // int32 page_size = 3;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }

    // string page_token = 4;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }

    // string order_by = 6;

    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::std::string::String) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_order_by(&mut self) -> &mut ::std::string::String {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.order_by, ::std::string::String::new())
    }

    pub fn get_order_by(&self) -> &str {
        &self.order_by
    }

    // .google.firestore.v1beta1.DocumentMask mask = 7;

    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::common::DocumentMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::common::DocumentMask {
        self.mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_mask(&self) -> &super::common::DocumentMask {
        self.mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }

    // bytes transaction = 8;

    pub fn clear_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(::std::vec::Vec::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_transaction(&self) -> &[u8] {
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(ref v)) => v,
            _ => &[],
        }
    }

    // .google.protobuf.Timestamp read_time = 10;

    pub fn clear_read_time(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.consistency_selector {
            ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }

    // bool show_missing = 12;

    pub fn clear_show_missing(&mut self) {
        self.show_missing = false;
    }

    // Param is passed by value, moved
    pub fn set_show_missing(&mut self, v: bool) {
        self.show_missing = v;
    }

    pub fn get_show_missing(&self) -> bool {
        self.show_missing
    }
}

impl ::protobuf::Message for ListDocumentsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(ListDocumentsRequest_oneof_consistency_selector::read_time(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.order_by)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::transaction(is.read_bytes()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(ListDocumentsRequest_oneof_consistency_selector::read_time(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_missing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.collection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection_id);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        if !self.order_by.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.order_by);
        }
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.show_missing != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &ListDocumentsRequest_oneof_consistency_selector::transaction(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(8, &v);
                },
                &ListDocumentsRequest_oneof_consistency_selector::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.collection_id.is_empty() {
            os.write_string(2, &self.collection_id)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            os.write_string(6, &self.order_by)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.show_missing != false {
            os.write_bool(12, self.show_missing)?;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &ListDocumentsRequest_oneof_consistency_selector::transaction(ref v) => {
                    os.write_bytes(8, v)?;
                },
                &ListDocumentsRequest_oneof_consistency_selector::read_time(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDocumentsRequest {
        ListDocumentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &ListDocumentsRequest| { &m.parent },
                    |m: &mut ListDocumentsRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection_id",
                    |m: &ListDocumentsRequest| { &m.collection_id },
                    |m: &mut ListDocumentsRequest| { &mut m.collection_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListDocumentsRequest| { &m.page_size },
                    |m: &mut ListDocumentsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListDocumentsRequest| { &m.page_token },
                    |m: &mut ListDocumentsRequest| { &mut m.page_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "order_by",
                    |m: &ListDocumentsRequest| { &m.order_by },
                    |m: &mut ListDocumentsRequest| { &mut m.order_by },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "mask",
                    |m: &ListDocumentsRequest| { &m.mask },
                    |m: &mut ListDocumentsRequest| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "transaction",
                    ListDocumentsRequest::has_transaction,
                    ListDocumentsRequest::get_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_time",
                    ListDocumentsRequest::has_read_time,
                    ListDocumentsRequest::get_read_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "show_missing",
                    |m: &ListDocumentsRequest| { &m.show_missing },
                    |m: &mut ListDocumentsRequest| { &mut m.show_missing },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDocumentsRequest>(
                    "ListDocumentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDocumentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListDocumentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDocumentsRequest,
        };
        unsafe {
            instance.get(ListDocumentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListDocumentsRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_collection_id();
        self.clear_page_size();
        self.clear_page_token();
        self.clear_order_by();
        self.clear_mask();
        self.clear_transaction();
        self.clear_read_time();
        self.clear_show_missing();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDocumentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDocumentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListDocumentsResponse {
    // message fields
    pub documents: ::protobuf::RepeatedField<super::document::Document>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListDocumentsResponse {
    pub fn new() -> ListDocumentsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.firestore.v1beta1.Document documents = 1;

    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<super::document::Document>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<super::document::Document> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<super::document::Document> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }

    pub fn get_documents(&self) -> &[super::document::Document] {
        &self.documents
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListDocumentsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.documents {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.documents)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListDocumentsResponse {
        ListDocumentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Document>>(
                    "documents",
                    |m: &ListDocumentsResponse| { &m.documents },
                    |m: &mut ListDocumentsResponse| { &mut m.documents },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListDocumentsResponse| { &m.next_page_token },
                    |m: &mut ListDocumentsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListDocumentsResponse>(
                    "ListDocumentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListDocumentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListDocumentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListDocumentsResponse,
        };
        unsafe {
            instance.get(ListDocumentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListDocumentsResponse {
    fn clear(&mut self) {
        self.clear_documents();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListDocumentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListDocumentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateDocumentRequest {
    // message fields
    pub parent: ::std::string::String,
    pub collection_id: ::std::string::String,
    pub document_id: ::std::string::String,
    pub document: ::protobuf::SingularPtrField<super::document::Document>,
    pub mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CreateDocumentRequest {
    pub fn new() -> CreateDocumentRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // string collection_id = 2;

    pub fn clear_collection_id(&mut self) {
        self.collection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection_id(&mut self, v: ::std::string::String) {
        self.collection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection_id(&mut self) -> &mut ::std::string::String {
        &mut self.collection_id
    }

    // Take field
    pub fn take_collection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection_id, ::std::string::String::new())
    }

    pub fn get_collection_id(&self) -> &str {
        &self.collection_id
    }

    // string document_id = 3;

    pub fn clear_document_id(&mut self) {
        self.document_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_document_id(&mut self, v: ::std::string::String) {
        self.document_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document_id(&mut self) -> &mut ::std::string::String {
        &mut self.document_id
    }

    // Take field
    pub fn take_document_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.document_id, ::std::string::String::new())
    }

    pub fn get_document_id(&self) -> &str {
        &self.document_id
    }

    // .google.firestore.v1beta1.Document document = 4;

    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: super::document::Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut super::document::Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> super::document::Document {
        self.document.take().unwrap_or_else(|| super::document::Document::new())
    }

    pub fn get_document(&self) -> &super::document::Document {
        self.document.as_ref().unwrap_or_else(|| super::document::Document::default_instance())
    }

    // .google.firestore.v1beta1.DocumentMask mask = 5;

    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::common::DocumentMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::common::DocumentMask {
        self.mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_mask(&self) -> &super::common::DocumentMask {
        self.mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }
}

impl ::protobuf::Message for CreateDocumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.document_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.collection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection_id);
        }
        if !self.document_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.document_id);
        }
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.collection_id.is_empty() {
            os.write_string(2, &self.collection_id)?;
        }
        if !self.document_id.is_empty() {
            os.write_string(3, &self.document_id)?;
        }
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateDocumentRequest {
        CreateDocumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &CreateDocumentRequest| { &m.parent },
                    |m: &mut CreateDocumentRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection_id",
                    |m: &CreateDocumentRequest| { &m.collection_id },
                    |m: &mut CreateDocumentRequest| { &mut m.collection_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "document_id",
                    |m: &CreateDocumentRequest| { &m.document_id },
                    |m: &mut CreateDocumentRequest| { &mut m.document_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Document>>(
                    "document",
                    |m: &CreateDocumentRequest| { &m.document },
                    |m: &mut CreateDocumentRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "mask",
                    |m: &CreateDocumentRequest| { &m.mask },
                    |m: &mut CreateDocumentRequest| { &mut m.mask },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateDocumentRequest>(
                    "CreateDocumentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateDocumentRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateDocumentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateDocumentRequest,
        };
        unsafe {
            instance.get(CreateDocumentRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateDocumentRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_collection_id();
        self.clear_document_id();
        self.clear_document();
        self.clear_mask();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateDocumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateDocumentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateDocumentRequest {
    // message fields
    pub document: ::protobuf::SingularPtrField<super::document::Document>,
    pub update_mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    pub mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    pub current_document: ::protobuf::SingularPtrField<super::common::Precondition>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl UpdateDocumentRequest {
    pub fn new() -> UpdateDocumentRequest {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.Document document = 1;

    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: super::document::Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut super::document::Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> super::document::Document {
        self.document.take().unwrap_or_else(|| super::document::Document::new())
    }

    pub fn get_document(&self) -> &super::document::Document {
        self.document.as_ref().unwrap_or_else(|| super::document::Document::default_instance())
    }

    // .google.firestore.v1beta1.DocumentMask update_mask = 2;

    pub fn clear_update_mask(&mut self) {
        self.update_mask.clear();
    }

    pub fn has_update_mask(&self) -> bool {
        self.update_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_mask(&mut self, v: super::common::DocumentMask) {
        self.update_mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.update_mask.is_none() {
            self.update_mask.set_default();
        }
        self.update_mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_update_mask(&mut self) -> super::common::DocumentMask {
        self.update_mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_update_mask(&self) -> &super::common::DocumentMask {
        self.update_mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }

    // .google.firestore.v1beta1.DocumentMask mask = 3;

    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::common::DocumentMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::common::DocumentMask {
        self.mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_mask(&self) -> &super::common::DocumentMask {
        self.mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }

    // .google.firestore.v1beta1.Precondition current_document = 4;

    pub fn clear_current_document(&mut self) {
        self.current_document.clear();
    }

    pub fn has_current_document(&self) -> bool {
        self.current_document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_document(&mut self, v: super::common::Precondition) {
        self.current_document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_document(&mut self) -> &mut super::common::Precondition {
        if self.current_document.is_none() {
            self.current_document.set_default();
        }
        self.current_document.as_mut().unwrap()
    }

    // Take field
    pub fn take_current_document(&mut self) -> super::common::Precondition {
        self.current_document.take().unwrap_or_else(|| super::common::Precondition::new())
    }

    pub fn get_current_document(&self) -> &super::common::Precondition {
        self.current_document.as_ref().unwrap_or_else(|| super::common::Precondition::default_instance())
    }
}

impl ::protobuf::Message for UpdateDocumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.current_document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update_mask)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.current_document)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.current_document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.update_mask.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.current_document.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateDocumentRequest {
        UpdateDocumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Document>>(
                    "document",
                    |m: &UpdateDocumentRequest| { &m.document },
                    |m: &mut UpdateDocumentRequest| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "update_mask",
                    |m: &UpdateDocumentRequest| { &m.update_mask },
                    |m: &mut UpdateDocumentRequest| { &mut m.update_mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "mask",
                    |m: &UpdateDocumentRequest| { &m.mask },
                    |m: &mut UpdateDocumentRequest| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Precondition>>(
                    "current_document",
                    |m: &UpdateDocumentRequest| { &m.current_document },
                    |m: &mut UpdateDocumentRequest| { &mut m.current_document },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateDocumentRequest>(
                    "UpdateDocumentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateDocumentRequest {
        static mut instance: ::protobuf::lazy::Lazy<UpdateDocumentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateDocumentRequest,
        };
        unsafe {
            instance.get(UpdateDocumentRequest::new)
        }
    }
}

impl ::protobuf::Clear for UpdateDocumentRequest {
    fn clear(&mut self) {
        self.clear_document();
        self.clear_update_mask();
        self.clear_mask();
        self.clear_current_document();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateDocumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateDocumentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteDocumentRequest {
    // message fields
    pub name: ::std::string::String,
    pub current_document: ::protobuf::SingularPtrField<super::common::Precondition>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl DeleteDocumentRequest {
    pub fn new() -> DeleteDocumentRequest {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .google.firestore.v1beta1.Precondition current_document = 2;

    pub fn clear_current_document(&mut self) {
        self.current_document.clear();
    }

    pub fn has_current_document(&self) -> bool {
        self.current_document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_document(&mut self, v: super::common::Precondition) {
        self.current_document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_document(&mut self) -> &mut super::common::Precondition {
        if self.current_document.is_none() {
            self.current_document.set_default();
        }
        self.current_document.as_mut().unwrap()
    }

    // Take field
    pub fn take_current_document(&mut self) -> super::common::Precondition {
        self.current_document.take().unwrap_or_else(|| super::common::Precondition::new())
    }

    pub fn get_current_document(&self) -> &super::common::Precondition {
        self.current_document.as_ref().unwrap_or_else(|| super::common::Precondition::default_instance())
    }
}

impl ::protobuf::Message for DeleteDocumentRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.current_document {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.current_document)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.current_document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.current_document.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteDocumentRequest {
        DeleteDocumentRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &DeleteDocumentRequest| { &m.name },
                    |m: &mut DeleteDocumentRequest| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::Precondition>>(
                    "current_document",
                    |m: &DeleteDocumentRequest| { &m.current_document },
                    |m: &mut DeleteDocumentRequest| { &mut m.current_document },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DeleteDocumentRequest>(
                    "DeleteDocumentRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeleteDocumentRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeleteDocumentRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DeleteDocumentRequest,
        };
        unsafe {
            instance.get(DeleteDocumentRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeleteDocumentRequest {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_current_document();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteDocumentRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteDocumentRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetDocumentsRequest {
    // message fields
    pub database: ::std::string::String,
    pub documents: ::protobuf::RepeatedField<::std::string::String>,
    pub mask: ::protobuf::SingularPtrField<super::common::DocumentMask>,
    // message oneof groups
    pub consistency_selector: ::std::option::Option<BatchGetDocumentsRequest_oneof_consistency_selector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum BatchGetDocumentsRequest_oneof_consistency_selector {
    transaction(::std::vec::Vec<u8>),
    new_transaction(super::common::TransactionOptions),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl BatchGetDocumentsRequest {
    pub fn new() -> BatchGetDocumentsRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // repeated string documents = 2;

    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }

    pub fn get_documents(&self) -> &[::std::string::String] {
        &self.documents
    }

    // .google.firestore.v1beta1.DocumentMask mask = 3;

    pub fn clear_mask(&mut self) {
        self.mask.clear();
    }

    pub fn has_mask(&self) -> bool {
        self.mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mask(&mut self, v: super::common::DocumentMask) {
        self.mask = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mask(&mut self) -> &mut super::common::DocumentMask {
        if self.mask.is_none() {
            self.mask.set_default();
        }
        self.mask.as_mut().unwrap()
    }

    // Take field
    pub fn take_mask(&mut self) -> super::common::DocumentMask {
        self.mask.take().unwrap_or_else(|| super::common::DocumentMask::new())
    }

    pub fn get_mask(&self) -> &super::common::DocumentMask {
        self.mask.as_ref().unwrap_or_else(|| super::common::DocumentMask::default_instance())
    }

    // bytes transaction = 4;

    pub fn clear_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(::std::vec::Vec::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_transaction(&self) -> &[u8] {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(ref v)) => v,
            _ => &[],
        }
    }

    // .google.firestore.v1beta1.TransactionOptions new_transaction = 5;

    pub fn clear_new_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_new_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_transaction(&mut self, v: super::common::TransactionOptions) {
        self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_transaction(&mut self) -> &mut super::common::TransactionOptions {
        if let ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(super::common::TransactionOptions::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_transaction(&mut self) -> super::common::TransactionOptions {
        if self.has_new_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::TransactionOptions::new()
        }
    }

    pub fn get_new_transaction(&self) -> &super::common::TransactionOptions {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(ref v)) => v,
            _ => super::common::TransactionOptions::default_instance(),
        }
    }

    // .google.protobuf.Timestamp read_time = 7;

    pub fn clear_read_time(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.consistency_selector {
            ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
}

impl ::protobuf::Message for BatchGetDocumentsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mask {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.documents)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mask)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::transaction(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(BatchGetDocumentsRequest_oneof_consistency_selector::read_time(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.documents {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &BatchGetDocumentsRequest_oneof_consistency_selector::transaction(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BatchGetDocumentsRequest_oneof_consistency_selector::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.documents {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.mask.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &BatchGetDocumentsRequest_oneof_consistency_selector::transaction(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &BatchGetDocumentsRequest_oneof_consistency_selector::new_transaction(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BatchGetDocumentsRequest_oneof_consistency_selector::read_time(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetDocumentsRequest {
        BatchGetDocumentsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &BatchGetDocumentsRequest| { &m.database },
                    |m: &mut BatchGetDocumentsRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documents",
                    |m: &BatchGetDocumentsRequest| { &m.documents },
                    |m: &mut BatchGetDocumentsRequest| { &mut m.documents },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::DocumentMask>>(
                    "mask",
                    |m: &BatchGetDocumentsRequest| { &m.mask },
                    |m: &mut BatchGetDocumentsRequest| { &mut m.mask },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "transaction",
                    BatchGetDocumentsRequest::has_transaction,
                    BatchGetDocumentsRequest::get_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::TransactionOptions>(
                    "new_transaction",
                    BatchGetDocumentsRequest::has_new_transaction,
                    BatchGetDocumentsRequest::get_new_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_time",
                    BatchGetDocumentsRequest::has_read_time,
                    BatchGetDocumentsRequest::get_read_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchGetDocumentsRequest>(
                    "BatchGetDocumentsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchGetDocumentsRequest {
        static mut instance: ::protobuf::lazy::Lazy<BatchGetDocumentsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchGetDocumentsRequest,
        };
        unsafe {
            instance.get(BatchGetDocumentsRequest::new)
        }
    }
}

impl ::protobuf::Clear for BatchGetDocumentsRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_documents();
        self.clear_mask();
        self.clear_transaction();
        self.clear_new_transaction();
        self.clear_read_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetDocumentsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetDocumentsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatchGetDocumentsResponse {
    // message fields
    pub transaction: ::std::vec::Vec<u8>,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub result: ::std::option::Option<BatchGetDocumentsResponse_oneof_result>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum BatchGetDocumentsResponse_oneof_result {
    found(super::document::Document),
    missing(::std::string::String),
}

impl BatchGetDocumentsResponse {
    pub fn new() -> BatchGetDocumentsResponse {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.Document found = 1;

    pub fn clear_found(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_found(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_found(&mut self, v: super::document::Document) {
        self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(v))
    }

    // Mutable pointer to the field.
    pub fn mut_found(&mut self) -> &mut super::document::Document {
        if let ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(super::document::Document::new()));
        }
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_found(&mut self) -> super::document::Document {
        if self.has_found() {
            match self.result.take() {
                ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(v)) => v,
                _ => panic!(),
            }
        } else {
            super::document::Document::new()
        }
    }

    pub fn get_found(&self) -> &super::document::Document {
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(ref v)) => v,
            _ => super::document::Document::default_instance(),
        }
    }

    // string missing = 2;

    pub fn clear_missing(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_missing(&self) -> bool {
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_missing(&mut self, v: ::std::string::String) {
        self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_missing(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(_)) = self.result {
        } else {
            self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(::std::string::String::new()));
        }
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_missing(&mut self) -> ::std::string::String {
        if self.has_missing() {
            match self.result.take() {
                ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    pub fn get_missing(&self) -> &str {
        match self.result {
            ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(ref v)) => v,
            _ => "",
        }
    }

    // bytes transaction = 3;

    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }

    // .google.protobuf.Timestamp read_time = 4;

    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for BatchGetDocumentsResponse {
    fn is_initialized(&self) -> bool {
        if let Some(BatchGetDocumentsResponse_oneof_result::found(ref v)) = self.result {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::found(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.result = ::std::option::Option::Some(BatchGetDocumentsResponse_oneof_result::missing(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.transaction);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &BatchGetDocumentsResponse_oneof_result::found(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &BatchGetDocumentsResponse_oneof_result::missing(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(3, &self.transaction)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.result {
            match v {
                &BatchGetDocumentsResponse_oneof_result::found(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &BatchGetDocumentsResponse_oneof_result::missing(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchGetDocumentsResponse {
        BatchGetDocumentsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::document::Document>(
                    "found",
                    BatchGetDocumentsResponse::has_found,
                    BatchGetDocumentsResponse::get_found,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                    "missing",
                    BatchGetDocumentsResponse::has_missing,
                    BatchGetDocumentsResponse::get_missing,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transaction",
                    |m: &BatchGetDocumentsResponse| { &m.transaction },
                    |m: &mut BatchGetDocumentsResponse| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "read_time",
                    |m: &BatchGetDocumentsResponse| { &m.read_time },
                    |m: &mut BatchGetDocumentsResponse| { &mut m.read_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatchGetDocumentsResponse>(
                    "BatchGetDocumentsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchGetDocumentsResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatchGetDocumentsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatchGetDocumentsResponse,
        };
        unsafe {
            instance.get(BatchGetDocumentsResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatchGetDocumentsResponse {
    fn clear(&mut self) {
        self.clear_found();
        self.clear_missing();
        self.clear_transaction();
        self.clear_read_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchGetDocumentsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchGetDocumentsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BeginTransactionRequest {
    // message fields
    pub database: ::std::string::String,
    pub options: ::protobuf::SingularPtrField<super::common::TransactionOptions>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BeginTransactionRequest {
    pub fn new() -> BeginTransactionRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // .google.firestore.v1beta1.TransactionOptions options = 2;

    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: super::common::TransactionOptions) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut super::common::TransactionOptions {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> super::common::TransactionOptions {
        self.options.take().unwrap_or_else(|| super::common::TransactionOptions::new())
    }

    pub fn get_options(&self) -> &super::common::TransactionOptions {
        self.options.as_ref().unwrap_or_else(|| super::common::TransactionOptions::default_instance())
    }
}

impl ::protobuf::Message for BeginTransactionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BeginTransactionRequest {
        BeginTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &BeginTransactionRequest| { &m.database },
                    |m: &mut BeginTransactionRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::common::TransactionOptions>>(
                    "options",
                    |m: &BeginTransactionRequest| { &m.options },
                    |m: &mut BeginTransactionRequest| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BeginTransactionRequest>(
                    "BeginTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BeginTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<BeginTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BeginTransactionRequest,
        };
        unsafe {
            instance.get(BeginTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for BeginTransactionRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_options();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BeginTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BeginTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BeginTransactionResponse {
    // message fields
    pub transaction: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl BeginTransactionResponse {
    pub fn new() -> BeginTransactionResponse {
        ::std::default::Default::default()
    }

    // bytes transaction = 1;

    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }
}

impl ::protobuf::Message for BeginTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.transaction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(1, &self.transaction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BeginTransactionResponse {
        BeginTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transaction",
                    |m: &BeginTransactionResponse| { &m.transaction },
                    |m: &mut BeginTransactionResponse| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BeginTransactionResponse>(
                    "BeginTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BeginTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<BeginTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BeginTransactionResponse,
        };
        unsafe {
            instance.get(BeginTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for BeginTransactionResponse {
    fn clear(&mut self) {
        self.clear_transaction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BeginTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BeginTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitRequest {
    // message fields
    pub database: ::std::string::String,
    pub writes: ::protobuf::RepeatedField<super::write::Write>,
    pub transaction: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CommitRequest {
    pub fn new() -> CommitRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // repeated .google.firestore.v1beta1.Write writes = 2;

    pub fn clear_writes(&mut self) {
        self.writes.clear();
    }

    // Param is passed by value, moved
    pub fn set_writes(&mut self, v: ::protobuf::RepeatedField<super::write::Write>) {
        self.writes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_writes(&mut self) -> &mut ::protobuf::RepeatedField<super::write::Write> {
        &mut self.writes
    }

    // Take field
    pub fn take_writes(&mut self) -> ::protobuf::RepeatedField<super::write::Write> {
        ::std::mem::replace(&mut self.writes, ::protobuf::RepeatedField::new())
    }

    pub fn get_writes(&self) -> &[super::write::Write] {
        &self.writes
    }

    // bytes transaction = 3;

    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }
}

impl ::protobuf::Message for CommitRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.writes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.writes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        for value in &self.writes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.transaction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        for v in &self.writes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.transaction.is_empty() {
            os.write_bytes(3, &self.transaction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitRequest {
        CommitRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &CommitRequest| { &m.database },
                    |m: &mut CommitRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::write::Write>>(
                    "writes",
                    |m: &CommitRequest| { &m.writes },
                    |m: &mut CommitRequest| { &mut m.writes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transaction",
                    |m: &CommitRequest| { &m.transaction },
                    |m: &mut CommitRequest| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommitRequest>(
                    "CommitRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommitRequest {
        static mut instance: ::protobuf::lazy::Lazy<CommitRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitRequest,
        };
        unsafe {
            instance.get(CommitRequest::new)
        }
    }
}

impl ::protobuf::Clear for CommitRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_writes();
        self.clear_transaction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommitResponse {
    // message fields
    pub write_results: ::protobuf::RepeatedField<super::write::WriteResult>,
    pub commit_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl CommitResponse {
    pub fn new() -> CommitResponse {
        ::std::default::Default::default()
    }

    // repeated .google.firestore.v1beta1.WriteResult write_results = 1;

    pub fn clear_write_results(&mut self) {
        self.write_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_write_results(&mut self, v: ::protobuf::RepeatedField<super::write::WriteResult>) {
        self.write_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_write_results(&mut self) -> &mut ::protobuf::RepeatedField<super::write::WriteResult> {
        &mut self.write_results
    }

    // Take field
    pub fn take_write_results(&mut self) -> ::protobuf::RepeatedField<super::write::WriteResult> {
        ::std::mem::replace(&mut self.write_results, ::protobuf::RepeatedField::new())
    }

    pub fn get_write_results(&self) -> &[super::write::WriteResult] {
        &self.write_results
    }

    // .google.protobuf.Timestamp commit_time = 2;

    pub fn clear_commit_time(&mut self) {
        self.commit_time.clear();
    }

    pub fn has_commit_time(&self) -> bool {
        self.commit_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.commit_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.commit_time.is_none() {
            self.commit_time.set_default();
        }
        self.commit_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.commit_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_commit_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.commit_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for CommitResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.write_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.write_results)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.write_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.commit_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.write_results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.commit_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommitResponse {
        CommitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::write::WriteResult>>(
                    "write_results",
                    |m: &CommitResponse| { &m.write_results },
                    |m: &mut CommitResponse| { &mut m.write_results },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "commit_time",
                    |m: &CommitResponse| { &m.commit_time },
                    |m: &mut CommitResponse| { &mut m.commit_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommitResponse>(
                    "CommitResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommitResponse {
        static mut instance: ::protobuf::lazy::Lazy<CommitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommitResponse,
        };
        unsafe {
            instance.get(CommitResponse::new)
        }
    }
}

impl ::protobuf::Clear for CommitResponse {
    fn clear(&mut self) {
        self.clear_write_results();
        self.clear_commit_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollbackRequest {
    // message fields
    pub database: ::std::string::String,
    pub transaction: ::std::vec::Vec<u8>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RollbackRequest {
    pub fn new() -> RollbackRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // bytes transaction = 2;

    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }
}

impl ::protobuf::Message for RollbackRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.transaction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if !self.transaction.is_empty() {
            os.write_bytes(2, &self.transaction)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollbackRequest {
        RollbackRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &RollbackRequest| { &m.database },
                    |m: &mut RollbackRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transaction",
                    |m: &RollbackRequest| { &m.transaction },
                    |m: &mut RollbackRequest| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RollbackRequest>(
                    "RollbackRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RollbackRequest {
        static mut instance: ::protobuf::lazy::Lazy<RollbackRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RollbackRequest,
        };
        unsafe {
            instance.get(RollbackRequest::new)
        }
    }
}

impl ::protobuf::Clear for RollbackRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_transaction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollbackRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollbackRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunQueryRequest {
    // message fields
    pub parent: ::std::string::String,
    // message oneof groups
    pub query_type: ::std::option::Option<RunQueryRequest_oneof_query_type>,
    pub consistency_selector: ::std::option::Option<RunQueryRequest_oneof_consistency_selector>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum RunQueryRequest_oneof_query_type {
    structured_query(super::query::StructuredQuery),
}

#[derive(Clone,PartialEq)]
pub enum RunQueryRequest_oneof_consistency_selector {
    transaction(::std::vec::Vec<u8>),
    new_transaction(super::common::TransactionOptions),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl RunQueryRequest {
    pub fn new() -> RunQueryRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // .google.firestore.v1beta1.StructuredQuery structured_query = 2;

    pub fn clear_structured_query(&mut self) {
        self.query_type = ::std::option::Option::None;
    }

    pub fn has_structured_query(&self) -> bool {
        match self.query_type {
            ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_structured_query(&mut self, v: super::query::StructuredQuery) {
        self.query_type = ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_structured_query(&mut self) -> &mut super::query::StructuredQuery {
        if let ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(_)) = self.query_type {
        } else {
            self.query_type = ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(super::query::StructuredQuery::new()));
        }
        match self.query_type {
            ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_structured_query(&mut self) -> super::query::StructuredQuery {
        if self.has_structured_query() {
            match self.query_type.take() {
                ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::StructuredQuery::new()
        }
    }

    pub fn get_structured_query(&self) -> &super::query::StructuredQuery {
        match self.query_type {
            ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(ref v)) => v,
            _ => super::query::StructuredQuery::default_instance(),
        }
    }

    // bytes transaction = 5;

    pub fn clear_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(::std::vec::Vec::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_transaction(&self) -> &[u8] {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(ref v)) => v,
            _ => &[],
        }
    }

    // .google.firestore.v1beta1.TransactionOptions new_transaction = 6;

    pub fn clear_new_transaction(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_new_transaction(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_new_transaction(&mut self, v: super::common::TransactionOptions) {
        self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(v))
    }

    // Mutable pointer to the field.
    pub fn mut_new_transaction(&mut self) -> &mut super::common::TransactionOptions {
        if let ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(super::common::TransactionOptions::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_new_transaction(&mut self) -> super::common::TransactionOptions {
        if self.has_new_transaction() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(v)) => v,
                _ => panic!(),
            }
        } else {
            super::common::TransactionOptions::new()
        }
    }

    pub fn get_new_transaction(&self) -> &super::common::TransactionOptions {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(ref v)) => v,
            _ => super::common::TransactionOptions::default_instance(),
        }
    }

    // .google.protobuf.Timestamp read_time = 7;

    pub fn clear_read_time(&mut self) {
        self.consistency_selector = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(_)) = self.consistency_selector {
        } else {
            self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.consistency_selector.take() {
                ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.consistency_selector {
            ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }
}

impl ::protobuf::Message for RunQueryRequest {
    fn is_initialized(&self) -> bool {
        if let Some(RunQueryRequest_oneof_query_type::structured_query(ref v)) = self.query_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RunQueryRequest_oneof_consistency_selector::new_transaction(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RunQueryRequest_oneof_consistency_selector::read_time(ref v)) = self.consistency_selector {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_type = ::std::option::Option::Some(RunQueryRequest_oneof_query_type::structured_query(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::transaction(is.read_bytes()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::new_transaction(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.consistency_selector = ::std::option::Option::Some(RunQueryRequest_oneof_consistency_selector::read_time(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let ::std::option::Option::Some(ref v) = self.query_type {
            match v {
                &RunQueryRequest_oneof_query_type::structured_query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &RunQueryRequest_oneof_consistency_selector::transaction(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(5, &v);
                },
                &RunQueryRequest_oneof_consistency_selector::new_transaction(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RunQueryRequest_oneof_consistency_selector::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query_type {
            match v {
                &RunQueryRequest_oneof_query_type::structured_query(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.consistency_selector {
            match v {
                &RunQueryRequest_oneof_consistency_selector::transaction(ref v) => {
                    os.write_bytes(5, v)?;
                },
                &RunQueryRequest_oneof_consistency_selector::new_transaction(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RunQueryRequest_oneof_consistency_selector::read_time(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunQueryRequest {
        RunQueryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &RunQueryRequest| { &m.parent },
                    |m: &mut RunQueryRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::StructuredQuery>(
                    "structured_query",
                    RunQueryRequest::has_structured_query,
                    RunQueryRequest::get_structured_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "transaction",
                    RunQueryRequest::has_transaction,
                    RunQueryRequest::get_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::common::TransactionOptions>(
                    "new_transaction",
                    RunQueryRequest::has_new_transaction,
                    RunQueryRequest::get_new_transaction,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_time",
                    RunQueryRequest::has_read_time,
                    RunQueryRequest::get_read_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunQueryRequest>(
                    "RunQueryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunQueryRequest {
        static mut instance: ::protobuf::lazy::Lazy<RunQueryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunQueryRequest,
        };
        unsafe {
            instance.get(RunQueryRequest::new)
        }
    }
}

impl ::protobuf::Clear for RunQueryRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_structured_query();
        self.clear_transaction();
        self.clear_new_transaction();
        self.clear_read_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunQueryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunQueryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunQueryResponse {
    // message fields
    pub transaction: ::std::vec::Vec<u8>,
    pub document: ::protobuf::SingularPtrField<super::document::Document>,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub skipped_results: i32,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl RunQueryResponse {
    pub fn new() -> RunQueryResponse {
        ::std::default::Default::default()
    }

    // bytes transaction = 2;

    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: ::std::vec::Vec<u8>) {
        self.transaction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.transaction
    }

    // Take field
    pub fn take_transaction(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.transaction, ::std::vec::Vec::new())
    }

    pub fn get_transaction(&self) -> &[u8] {
        &self.transaction
    }

    // .google.firestore.v1beta1.Document document = 1;

    pub fn clear_document(&mut self) {
        self.document.clear();
    }

    pub fn has_document(&self) -> bool {
        self.document.is_some()
    }

    // Param is passed by value, moved
    pub fn set_document(&mut self, v: super::document::Document) {
        self.document = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_document(&mut self) -> &mut super::document::Document {
        if self.document.is_none() {
            self.document.set_default();
        }
        self.document.as_mut().unwrap()
    }

    // Take field
    pub fn take_document(&mut self) -> super::document::Document {
        self.document.take().unwrap_or_else(|| super::document::Document::new())
    }

    pub fn get_document(&self) -> &super::document::Document {
        self.document.as_ref().unwrap_or_else(|| super::document::Document::default_instance())
    }

    // .google.protobuf.Timestamp read_time = 3;

    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // int32 skipped_results = 4;

    pub fn clear_skipped_results(&mut self) {
        self.skipped_results = 0;
    }

    // Param is passed by value, moved
    pub fn set_skipped_results(&mut self, v: i32) {
        self.skipped_results = v;
    }

    pub fn get_skipped_results(&self) -> i32 {
        self.skipped_results
    }
}

impl ::protobuf::Message for RunQueryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.document {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.transaction)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.document)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.skipped_results = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.transaction.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.transaction);
        }
        if let Some(ref v) = self.document.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.skipped_results != 0 {
            my_size += ::protobuf::rt::value_size(4, self.skipped_results, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.transaction.is_empty() {
            os.write_bytes(2, &self.transaction)?;
        }
        if let Some(ref v) = self.document.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.skipped_results != 0 {
            os.write_int32(4, self.skipped_results)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunQueryResponse {
        RunQueryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "transaction",
                    |m: &RunQueryResponse| { &m.transaction },
                    |m: &mut RunQueryResponse| { &mut m.transaction },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Document>>(
                    "document",
                    |m: &RunQueryResponse| { &m.document },
                    |m: &mut RunQueryResponse| { &mut m.document },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "read_time",
                    |m: &RunQueryResponse| { &m.read_time },
                    |m: &mut RunQueryResponse| { &mut m.read_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "skipped_results",
                    |m: &RunQueryResponse| { &m.skipped_results },
                    |m: &mut RunQueryResponse| { &mut m.skipped_results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RunQueryResponse>(
                    "RunQueryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RunQueryResponse {
        static mut instance: ::protobuf::lazy::Lazy<RunQueryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RunQueryResponse,
        };
        unsafe {
            instance.get(RunQueryResponse::new)
        }
    }
}

impl ::protobuf::Clear for RunQueryResponse {
    fn clear(&mut self) {
        self.clear_transaction();
        self.clear_document();
        self.clear_read_time();
        self.clear_skipped_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunQueryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunQueryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteRequest {
    // message fields
    pub database: ::std::string::String,
    pub stream_id: ::std::string::String,
    pub writes: ::protobuf::RepeatedField<super::write::Write>,
    pub stream_token: ::std::vec::Vec<u8>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WriteRequest {
    pub fn new() -> WriteRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // string stream_id = 2;

    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        &mut self.stream_id
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream_id, ::std::string::String::new())
    }

    pub fn get_stream_id(&self) -> &str {
        &self.stream_id
    }

    // repeated .google.firestore.v1beta1.Write writes = 3;

    pub fn clear_writes(&mut self) {
        self.writes.clear();
    }

    // Param is passed by value, moved
    pub fn set_writes(&mut self, v: ::protobuf::RepeatedField<super::write::Write>) {
        self.writes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_writes(&mut self) -> &mut ::protobuf::RepeatedField<super::write::Write> {
        &mut self.writes
    }

    // Take field
    pub fn take_writes(&mut self) -> ::protobuf::RepeatedField<super::write::Write> {
        ::std::mem::replace(&mut self.writes, ::protobuf::RepeatedField::new())
    }

    pub fn get_writes(&self) -> &[super::write::Write] {
        &self.writes
    }

    // bytes stream_token = 4;

    pub fn clear_stream_token(&mut self) {
        self.stream_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.stream_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stream_token
    }

    // Take field
    pub fn take_stream_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stream_token, ::std::vec::Vec::new())
    }

    pub fn get_stream_token(&self) -> &[u8] {
        &self.stream_token
    }

    // repeated .google.firestore.v1beta1.WriteRequest.LabelsEntry labels = 5;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
}

impl ::protobuf::Message for WriteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.writes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream_id)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.writes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stream_token)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        if !self.stream_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.stream_id);
        }
        for value in &self.writes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.stream_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.stream_token);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        if !self.stream_id.is_empty() {
            os.write_string(2, &self.stream_id)?;
        }
        for v in &self.writes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.stream_token.is_empty() {
            os.write_bytes(4, &self.stream_token)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.labels, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteRequest {
        WriteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &WriteRequest| { &m.database },
                    |m: &mut WriteRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stream_id",
                    |m: &WriteRequest| { &m.stream_id },
                    |m: &mut WriteRequest| { &mut m.stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::write::Write>>(
                    "writes",
                    |m: &WriteRequest| { &m.writes },
                    |m: &mut WriteRequest| { &mut m.writes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stream_token",
                    |m: &WriteRequest| { &m.stream_token },
                    |m: &mut WriteRequest| { &mut m.stream_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &WriteRequest| { &m.labels },
                    |m: &mut WriteRequest| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteRequest>(
                    "WriteRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteRequest {
        static mut instance: ::protobuf::lazy::Lazy<WriteRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteRequest,
        };
        unsafe {
            instance.get(WriteRequest::new)
        }
    }
}

impl ::protobuf::Clear for WriteRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_stream_id();
        self.clear_writes();
        self.clear_stream_token();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WriteResponse {
    // message fields
    pub stream_id: ::std::string::String,
    pub stream_token: ::std::vec::Vec<u8>,
    pub write_results: ::protobuf::RepeatedField<super::write::WriteResult>,
    pub commit_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl WriteResponse {
    pub fn new() -> WriteResponse {
        ::std::default::Default::default()
    }

    // string stream_id = 1;

    pub fn clear_stream_id(&mut self) {
        self.stream_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_id(&mut self, v: ::std::string::String) {
        self.stream_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_id(&mut self) -> &mut ::std::string::String {
        &mut self.stream_id
    }

    // Take field
    pub fn take_stream_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stream_id, ::std::string::String::new())
    }

    pub fn get_stream_id(&self) -> &str {
        &self.stream_id
    }

    // bytes stream_token = 2;

    pub fn clear_stream_token(&mut self) {
        self.stream_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_stream_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.stream_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stream_token
    }

    // Take field
    pub fn take_stream_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stream_token, ::std::vec::Vec::new())
    }

    pub fn get_stream_token(&self) -> &[u8] {
        &self.stream_token
    }

    // repeated .google.firestore.v1beta1.WriteResult write_results = 3;

    pub fn clear_write_results(&mut self) {
        self.write_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_write_results(&mut self, v: ::protobuf::RepeatedField<super::write::WriteResult>) {
        self.write_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_write_results(&mut self) -> &mut ::protobuf::RepeatedField<super::write::WriteResult> {
        &mut self.write_results
    }

    // Take field
    pub fn take_write_results(&mut self) -> ::protobuf::RepeatedField<super::write::WriteResult> {
        ::std::mem::replace(&mut self.write_results, ::protobuf::RepeatedField::new())
    }

    pub fn get_write_results(&self) -> &[super::write::WriteResult] {
        &self.write_results
    }

    // .google.protobuf.Timestamp commit_time = 4;

    pub fn clear_commit_time(&mut self) {
        self.commit_time.clear();
    }

    pub fn has_commit_time(&self) -> bool {
        self.commit_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commit_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.commit_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commit_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.commit_time.is_none() {
            self.commit_time.set_default();
        }
        self.commit_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_commit_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.commit_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_commit_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.commit_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for WriteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.write_results {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.commit_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stream_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stream_token)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.write_results)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commit_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.stream_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.stream_id);
        }
        if !self.stream_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.stream_token);
        }
        for value in &self.write_results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.commit_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.stream_id.is_empty() {
            os.write_string(1, &self.stream_id)?;
        }
        if !self.stream_token.is_empty() {
            os.write_bytes(2, &self.stream_token)?;
        }
        for v in &self.write_results {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.commit_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WriteResponse {
        WriteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stream_id",
                    |m: &WriteResponse| { &m.stream_id },
                    |m: &mut WriteResponse| { &mut m.stream_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stream_token",
                    |m: &WriteResponse| { &m.stream_token },
                    |m: &mut WriteResponse| { &mut m.stream_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::write::WriteResult>>(
                    "write_results",
                    |m: &WriteResponse| { &m.write_results },
                    |m: &mut WriteResponse| { &mut m.write_results },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "commit_time",
                    |m: &WriteResponse| { &m.commit_time },
                    |m: &mut WriteResponse| { &mut m.commit_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WriteResponse>(
                    "WriteResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WriteResponse {
        static mut instance: ::protobuf::lazy::Lazy<WriteResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WriteResponse,
        };
        unsafe {
            instance.get(WriteResponse::new)
        }
    }
}

impl ::protobuf::Clear for WriteResponse {
    fn clear(&mut self) {
        self.clear_stream_id();
        self.clear_stream_token();
        self.clear_write_results();
        self.clear_commit_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenRequest {
    // message fields
    pub database: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // message oneof groups
    pub target_change: ::std::option::Option<ListenRequest_oneof_target_change>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum ListenRequest_oneof_target_change {
    add_target(Target),
    remove_target(i32),
}

impl ListenRequest {
    pub fn new() -> ListenRequest {
        ::std::default::Default::default()
    }

    // string database = 1;

    pub fn clear_database(&mut self) {
        self.database.clear();
    }

    // Param is passed by value, moved
    pub fn set_database(&mut self, v: ::std::string::String) {
        self.database = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database(&mut self) -> &mut ::std::string::String {
        &mut self.database
    }

    // Take field
    pub fn take_database(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.database, ::std::string::String::new())
    }

    pub fn get_database(&self) -> &str {
        &self.database
    }

    // .google.firestore.v1beta1.Target add_target = 2;

    pub fn clear_add_target(&mut self) {
        self.target_change = ::std::option::Option::None;
    }

    pub fn has_add_target(&self) -> bool {
        match self.target_change {
            ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_target(&mut self, v: Target) {
        self.target_change = ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_target(&mut self) -> &mut Target {
        if let ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(_)) = self.target_change {
        } else {
            self.target_change = ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(Target::new()));
        }
        match self.target_change {
            ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_target(&mut self) -> Target {
        if self.has_add_target() {
            match self.target_change.take() {
                ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(v)) => v,
                _ => panic!(),
            }
        } else {
            Target::new()
        }
    }

    pub fn get_add_target(&self) -> &Target {
        match self.target_change {
            ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(ref v)) => v,
            _ => Target::default_instance(),
        }
    }

    // int32 remove_target = 3;

    pub fn clear_remove_target(&mut self) {
        self.target_change = ::std::option::Option::None;
    }

    pub fn has_remove_target(&self) -> bool {
        match self.target_change {
            ::std::option::Option::Some(ListenRequest_oneof_target_change::remove_target(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remove_target(&mut self, v: i32) {
        self.target_change = ::std::option::Option::Some(ListenRequest_oneof_target_change::remove_target(v))
    }

    pub fn get_remove_target(&self) -> i32 {
        match self.target_change {
            ::std::option::Option::Some(ListenRequest_oneof_target_change::remove_target(v)) => v,
            _ => 0,
        }
    }

    // repeated .google.firestore.v1beta1.ListenRequest.LabelsEntry labels = 4;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
}

impl ::protobuf::Message for ListenRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ListenRequest_oneof_target_change::add_target(ref v)) = self.target_change {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.database)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_change = ::std::option::Option::Some(ListenRequest_oneof_target_change::add_target(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_change = ::std::option::Option::Some(ListenRequest_oneof_target_change::remove_target(is.read_int32()?));
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.database.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.database);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels);
        if let ::std::option::Option::Some(ref v) = self.target_change {
            match v {
                &ListenRequest_oneof_target_change::add_target(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ListenRequest_oneof_target_change::remove_target(v) => {
                    my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.database.is_empty() {
            os.write_string(1, &self.database)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.labels, os)?;
        if let ::std::option::Option::Some(ref v) = self.target_change {
            match v {
                &ListenRequest_oneof_target_change::add_target(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ListenRequest_oneof_target_change::remove_target(v) => {
                    os.write_int32(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenRequest {
        ListenRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "database",
                    |m: &ListenRequest| { &m.database },
                    |m: &mut ListenRequest| { &mut m.database },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Target>(
                    "add_target",
                    ListenRequest::has_add_target,
                    ListenRequest::get_add_target,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor::<_>(
                    "remove_target",
                    ListenRequest::has_remove_target,
                    ListenRequest::get_remove_target,
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "labels",
                    |m: &ListenRequest| { &m.labels },
                    |m: &mut ListenRequest| { &mut m.labels },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListenRequest>(
                    "ListenRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListenRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListenRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListenRequest,
        };
        unsafe {
            instance.get(ListenRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListenRequest {
    fn clear(&mut self) {
        self.clear_database();
        self.clear_add_target();
        self.clear_remove_target();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenResponse {
    // message oneof groups
    pub response_type: ::std::option::Option<ListenResponse_oneof_response_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum ListenResponse_oneof_response_type {
    target_change(TargetChange),
    document_change(super::write::DocumentChange),
    document_delete(super::write::DocumentDelete),
    document_remove(super::write::DocumentRemove),
    filter(super::write::ExistenceFilter),
}

impl ListenResponse {
    pub fn new() -> ListenResponse {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.TargetChange target_change = 2;

    pub fn clear_target_change(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_target_change(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_target_change(&mut self, v: TargetChange) {
        self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(v))
    }

    // Mutable pointer to the field.
    pub fn mut_target_change(&mut self) -> &mut TargetChange {
        if let ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(TargetChange::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_target_change(&mut self) -> TargetChange {
        if self.has_target_change() {
            match self.response_type.take() {
                ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(v)) => v,
                _ => panic!(),
            }
        } else {
            TargetChange::new()
        }
    }

    pub fn get_target_change(&self) -> &TargetChange {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(ref v)) => v,
            _ => TargetChange::default_instance(),
        }
    }

    // .google.firestore.v1beta1.DocumentChange document_change = 3;

    pub fn clear_document_change(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_document_change(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_document_change(&mut self, v: super::write::DocumentChange) {
        self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(v))
    }

    // Mutable pointer to the field.
    pub fn mut_document_change(&mut self) -> &mut super::write::DocumentChange {
        if let ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(super::write::DocumentChange::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_document_change(&mut self) -> super::write::DocumentChange {
        if self.has_document_change() {
            match self.response_type.take() {
                ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(v)) => v,
                _ => panic!(),
            }
        } else {
            super::write::DocumentChange::new()
        }
    }

    pub fn get_document_change(&self) -> &super::write::DocumentChange {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(ref v)) => v,
            _ => super::write::DocumentChange::default_instance(),
        }
    }

    // .google.firestore.v1beta1.DocumentDelete document_delete = 4;

    pub fn clear_document_delete(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_document_delete(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_document_delete(&mut self, v: super::write::DocumentDelete) {
        self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(v))
    }

    // Mutable pointer to the field.
    pub fn mut_document_delete(&mut self) -> &mut super::write::DocumentDelete {
        if let ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(super::write::DocumentDelete::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_document_delete(&mut self) -> super::write::DocumentDelete {
        if self.has_document_delete() {
            match self.response_type.take() {
                ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(v)) => v,
                _ => panic!(),
            }
        } else {
            super::write::DocumentDelete::new()
        }
    }

    pub fn get_document_delete(&self) -> &super::write::DocumentDelete {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(ref v)) => v,
            _ => super::write::DocumentDelete::default_instance(),
        }
    }

    // .google.firestore.v1beta1.DocumentRemove document_remove = 6;

    pub fn clear_document_remove(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_document_remove(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_document_remove(&mut self, v: super::write::DocumentRemove) {
        self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(v))
    }

    // Mutable pointer to the field.
    pub fn mut_document_remove(&mut self) -> &mut super::write::DocumentRemove {
        if let ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(super::write::DocumentRemove::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_document_remove(&mut self) -> super::write::DocumentRemove {
        if self.has_document_remove() {
            match self.response_type.take() {
                ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(v)) => v,
                _ => panic!(),
            }
        } else {
            super::write::DocumentRemove::new()
        }
    }

    pub fn get_document_remove(&self) -> &super::write::DocumentRemove {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(ref v)) => v,
            _ => super::write::DocumentRemove::default_instance(),
        }
    }

    // .google.firestore.v1beta1.ExistenceFilter filter = 5;

    pub fn clear_filter(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_filter(&self) -> bool {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: super::write::ExistenceFilter) {
        self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter(&mut self) -> &mut super::write::ExistenceFilter {
        if let ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(_)) = self.response_type {
        } else {
            self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(super::write::ExistenceFilter::new()));
        }
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter(&mut self) -> super::write::ExistenceFilter {
        if self.has_filter() {
            match self.response_type.take() {
                ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(v)) => v,
                _ => panic!(),
            }
        } else {
            super::write::ExistenceFilter::new()
        }
    }

    pub fn get_filter(&self) -> &super::write::ExistenceFilter {
        match self.response_type {
            ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(ref v)) => v,
            _ => super::write::ExistenceFilter::default_instance(),
        }
    }
}

impl ::protobuf::Message for ListenResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ListenResponse_oneof_response_type::target_change(ref v)) = self.response_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ListenResponse_oneof_response_type::document_change(ref v)) = self.response_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ListenResponse_oneof_response_type::document_delete(ref v)) = self.response_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ListenResponse_oneof_response_type::document_remove(ref v)) = self.response_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ListenResponse_oneof_response_type::filter(ref v)) = self.response_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::target_change(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_change(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_delete(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::document_remove(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response_type = ::std::option::Option::Some(ListenResponse_oneof_response_type::filter(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &ListenResponse_oneof_response_type::target_change(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ListenResponse_oneof_response_type::document_change(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ListenResponse_oneof_response_type::document_delete(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ListenResponse_oneof_response_type::document_remove(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ListenResponse_oneof_response_type::filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response_type {
            match v {
                &ListenResponse_oneof_response_type::target_change(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ListenResponse_oneof_response_type::document_change(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ListenResponse_oneof_response_type::document_delete(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ListenResponse_oneof_response_type::document_remove(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ListenResponse_oneof_response_type::filter(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenResponse {
        ListenResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TargetChange>(
                    "target_change",
                    ListenResponse::has_target_change,
                    ListenResponse::get_target_change,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::write::DocumentChange>(
                    "document_change",
                    ListenResponse::has_document_change,
                    ListenResponse::get_document_change,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::write::DocumentDelete>(
                    "document_delete",
                    ListenResponse::has_document_delete,
                    ListenResponse::get_document_delete,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::write::DocumentRemove>(
                    "document_remove",
                    ListenResponse::has_document_remove,
                    ListenResponse::get_document_remove,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::write::ExistenceFilter>(
                    "filter",
                    ListenResponse::has_filter,
                    ListenResponse::get_filter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListenResponse>(
                    "ListenResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListenResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListenResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListenResponse,
        };
        unsafe {
            instance.get(ListenResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListenResponse {
    fn clear(&mut self) {
        self.clear_target_change();
        self.clear_document_change();
        self.clear_document_delete();
        self.clear_document_remove();
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Target {
    // message fields
    pub target_id: i32,
    pub once: bool,
    // message oneof groups
    pub target_type: ::std::option::Option<Target_oneof_target_type>,
    pub resume_type: ::std::option::Option<Target_oneof_resume_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Target_oneof_target_type {
    query(Target_QueryTarget),
    documents(Target_DocumentsTarget),
}

#[derive(Clone,PartialEq)]
pub enum Target_oneof_resume_type {
    resume_token(::std::vec::Vec<u8>),
    read_time(::protobuf::well_known_types::Timestamp),
}

impl Target {
    pub fn new() -> Target {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.Target.QueryTarget query = 2;

    pub fn clear_query(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_query(&self) -> bool {
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: Target_QueryTarget) {
        self.target_type = ::std::option::Option::Some(Target_oneof_target_type::query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query(&mut self) -> &mut Target_QueryTarget {
        if let ::std::option::Option::Some(Target_oneof_target_type::query(_)) = self.target_type {
        } else {
            self.target_type = ::std::option::Option::Some(Target_oneof_target_type::query(Target_QueryTarget::new()));
        }
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query(&mut self) -> Target_QueryTarget {
        if self.has_query() {
            match self.target_type.take() {
                ::std::option::Option::Some(Target_oneof_target_type::query(v)) => v,
                _ => panic!(),
            }
        } else {
            Target_QueryTarget::new()
        }
    }

    pub fn get_query(&self) -> &Target_QueryTarget {
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::query(ref v)) => v,
            _ => Target_QueryTarget::default_instance(),
        }
    }

    // .google.firestore.v1beta1.Target.DocumentsTarget documents = 3;

    pub fn clear_documents(&mut self) {
        self.target_type = ::std::option::Option::None;
    }

    pub fn has_documents(&self) -> bool {
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::documents(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: Target_DocumentsTarget) {
        self.target_type = ::std::option::Option::Some(Target_oneof_target_type::documents(v))
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut Target_DocumentsTarget {
        if let ::std::option::Option::Some(Target_oneof_target_type::documents(_)) = self.target_type {
        } else {
            self.target_type = ::std::option::Option::Some(Target_oneof_target_type::documents(Target_DocumentsTarget::new()));
        }
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::documents(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_documents(&mut self) -> Target_DocumentsTarget {
        if self.has_documents() {
            match self.target_type.take() {
                ::std::option::Option::Some(Target_oneof_target_type::documents(v)) => v,
                _ => panic!(),
            }
        } else {
            Target_DocumentsTarget::new()
        }
    }

    pub fn get_documents(&self) -> &Target_DocumentsTarget {
        match self.target_type {
            ::std::option::Option::Some(Target_oneof_target_type::documents(ref v)) => v,
            _ => Target_DocumentsTarget::default_instance(),
        }
    }

    // bytes resume_token = 4;

    pub fn clear_resume_token(&mut self) {
        self.resume_type = ::std::option::Option::None;
    }

    pub fn has_resume_token(&self) -> bool {
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::resume_token(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_resume_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::resume_token(v))
    }

    // Mutable pointer to the field.
    pub fn mut_resume_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Target_oneof_resume_type::resume_token(_)) = self.resume_type {
        } else {
            self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::resume_token(::std::vec::Vec::new()));
        }
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::resume_token(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_resume_token(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_resume_token() {
            match self.resume_type.take() {
                ::std::option::Option::Some(Target_oneof_resume_type::resume_token(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_resume_token(&self) -> &[u8] {
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::resume_token(ref v)) => v,
            _ => &[],
        }
    }

    // .google.protobuf.Timestamp read_time = 11;

    pub fn clear_read_time(&mut self) {
        self.resume_type = ::std::option::Option::None;
    }

    pub fn has_read_time(&self) -> bool {
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::read_time(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::read_time(v))
    }

    // Mutable pointer to the field.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if let ::std::option::Option::Some(Target_oneof_resume_type::read_time(_)) = self.resume_type {
        } else {
            self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::read_time(::protobuf::well_known_types::Timestamp::new()));
        }
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::read_time(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        if self.has_read_time() {
            match self.resume_type.take() {
                ::std::option::Option::Some(Target_oneof_resume_type::read_time(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Timestamp::new()
        }
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        match self.resume_type {
            ::std::option::Option::Some(Target_oneof_resume_type::read_time(ref v)) => v,
            _ => ::protobuf::well_known_types::Timestamp::default_instance(),
        }
    }

    // int32 target_id = 5;

    pub fn clear_target_id(&mut self) {
        self.target_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: i32) {
        self.target_id = v;
    }

    pub fn get_target_id(&self) -> i32 {
        self.target_id
    }

    // bool once = 6;

    pub fn clear_once(&mut self) {
        self.once = false;
    }

    // Param is passed by value, moved
    pub fn set_once(&mut self, v: bool) {
        self.once = v;
    }

    pub fn get_once(&self) -> bool {
        self.once
    }
}

impl ::protobuf::Message for Target {
    fn is_initialized(&self) -> bool {
        if let Some(Target_oneof_target_type::query(ref v)) = self.target_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Target_oneof_target_type::documents(ref v)) = self.target_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Target_oneof_resume_type::read_time(ref v)) = self.resume_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_type = ::std::option::Option::Some(Target_oneof_target_type::query(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.target_type = ::std::option::Option::Some(Target_oneof_target_type::documents(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::resume_token(is.read_bytes()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.resume_type = ::std::option::Option::Some(Target_oneof_resume_type::read_time(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target_id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.once = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.target_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.target_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.once != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.target_type {
            match v {
                &Target_oneof_target_type::query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Target_oneof_target_type::documents(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.resume_type {
            match v {
                &Target_oneof_resume_type::resume_token(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &Target_oneof_resume_type::read_time(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.target_id != 0 {
            os.write_int32(5, self.target_id)?;
        }
        if self.once != false {
            os.write_bool(6, self.once)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target_type {
            match v {
                &Target_oneof_target_type::query(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Target_oneof_target_type::documents(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.resume_type {
            match v {
                &Target_oneof_resume_type::resume_token(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &Target_oneof_resume_type::read_time(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Target {
        Target::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Target_QueryTarget>(
                    "query",
                    Target::has_query,
                    Target::get_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Target_DocumentsTarget>(
                    "documents",
                    Target::has_documents,
                    Target::get_documents,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "resume_token",
                    Target::has_resume_token,
                    Target::get_resume_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Timestamp>(
                    "read_time",
                    Target::has_read_time,
                    Target::get_read_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_id",
                    |m: &Target| { &m.target_id },
                    |m: &mut Target| { &mut m.target_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "once",
                    |m: &Target| { &m.once },
                    |m: &mut Target| { &mut m.once },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Target>(
                    "Target",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Target {
        static mut instance: ::protobuf::lazy::Lazy<Target> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Target,
        };
        unsafe {
            instance.get(Target::new)
        }
    }
}

impl ::protobuf::Clear for Target {
    fn clear(&mut self) {
        self.clear_query();
        self.clear_documents();
        self.clear_resume_token();
        self.clear_read_time();
        self.clear_target_id();
        self.clear_once();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Target {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Target {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Target_DocumentsTarget {
    // message fields
    pub documents: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Target_DocumentsTarget {
    pub fn new() -> Target_DocumentsTarget {
        ::std::default::Default::default()
    }

    // repeated string documents = 2;

    pub fn clear_documents(&mut self) {
        self.documents.clear();
    }

    // Param is passed by value, moved
    pub fn set_documents(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.documents = v;
    }

    // Mutable pointer to the field.
    pub fn mut_documents(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.documents
    }

    // Take field
    pub fn take_documents(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.documents, ::protobuf::RepeatedField::new())
    }

    pub fn get_documents(&self) -> &[::std::string::String] {
        &self.documents
    }
}

impl ::protobuf::Message for Target_DocumentsTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.documents)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.documents {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.documents {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Target_DocumentsTarget {
        Target_DocumentsTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documents",
                    |m: &Target_DocumentsTarget| { &m.documents },
                    |m: &mut Target_DocumentsTarget| { &mut m.documents },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Target_DocumentsTarget>(
                    "Target_DocumentsTarget",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Target_DocumentsTarget {
        static mut instance: ::protobuf::lazy::Lazy<Target_DocumentsTarget> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Target_DocumentsTarget,
        };
        unsafe {
            instance.get(Target_DocumentsTarget::new)
        }
    }
}

impl ::protobuf::Clear for Target_DocumentsTarget {
    fn clear(&mut self) {
        self.clear_documents();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Target_DocumentsTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Target_DocumentsTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Target_QueryTarget {
    // message fields
    pub parent: ::std::string::String,
    // message oneof groups
    pub query_type: ::std::option::Option<Target_QueryTarget_oneof_query_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Target_QueryTarget_oneof_query_type {
    structured_query(super::query::StructuredQuery),
}

impl Target_QueryTarget {
    pub fn new() -> Target_QueryTarget {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // .google.firestore.v1beta1.StructuredQuery structured_query = 2;

    pub fn clear_structured_query(&mut self) {
        self.query_type = ::std::option::Option::None;
    }

    pub fn has_structured_query(&self) -> bool {
        match self.query_type {
            ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_structured_query(&mut self, v: super::query::StructuredQuery) {
        self.query_type = ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(v))
    }

    // Mutable pointer to the field.
    pub fn mut_structured_query(&mut self) -> &mut super::query::StructuredQuery {
        if let ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(_)) = self.query_type {
        } else {
            self.query_type = ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(super::query::StructuredQuery::new()));
        }
        match self.query_type {
            ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_structured_query(&mut self) -> super::query::StructuredQuery {
        if self.has_structured_query() {
            match self.query_type.take() {
                ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(v)) => v,
                _ => panic!(),
            }
        } else {
            super::query::StructuredQuery::new()
        }
    }

    pub fn get_structured_query(&self) -> &super::query::StructuredQuery {
        match self.query_type {
            ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(ref v)) => v,
            _ => super::query::StructuredQuery::default_instance(),
        }
    }
}

impl ::protobuf::Message for Target_QueryTarget {
    fn is_initialized(&self) -> bool {
        if let Some(Target_QueryTarget_oneof_query_type::structured_query(ref v)) = self.query_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_type = ::std::option::Option::Some(Target_QueryTarget_oneof_query_type::structured_query(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if let ::std::option::Option::Some(ref v) = self.query_type {
            match v {
                &Target_QueryTarget_oneof_query_type::structured_query(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query_type {
            match v {
                &Target_QueryTarget_oneof_query_type::structured_query(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Target_QueryTarget {
        Target_QueryTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &Target_QueryTarget| { &m.parent },
                    |m: &mut Target_QueryTarget| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::query::StructuredQuery>(
                    "structured_query",
                    Target_QueryTarget::has_structured_query,
                    Target_QueryTarget::get_structured_query,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Target_QueryTarget>(
                    "Target_QueryTarget",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Target_QueryTarget {
        static mut instance: ::protobuf::lazy::Lazy<Target_QueryTarget> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Target_QueryTarget,
        };
        unsafe {
            instance.get(Target_QueryTarget::new)
        }
    }
}

impl ::protobuf::Clear for Target_QueryTarget {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_structured_query();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Target_QueryTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Target_QueryTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TargetChange {
    // message fields
    pub target_change_type: TargetChange_TargetChangeType,
    pub target_ids: ::std::vec::Vec<i32>,
    pub cause: ::protobuf::SingularPtrField<super::status::Status>,
    pub resume_token: ::std::vec::Vec<u8>,
    pub read_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl TargetChange {
    pub fn new() -> TargetChange {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.TargetChange.TargetChangeType target_change_type = 1;

    pub fn clear_target_change_type(&mut self) {
        self.target_change_type = TargetChange_TargetChangeType::NO_CHANGE;
    }

    // Param is passed by value, moved
    pub fn set_target_change_type(&mut self, v: TargetChange_TargetChangeType) {
        self.target_change_type = v;
    }

    pub fn get_target_change_type(&self) -> TargetChange_TargetChangeType {
        self.target_change_type
    }

    // repeated int32 target_ids = 2;

    pub fn clear_target_ids(&mut self) {
        self.target_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.target_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.target_ids
    }

    // Take field
    pub fn take_target_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.target_ids, ::std::vec::Vec::new())
    }

    pub fn get_target_ids(&self) -> &[i32] {
        &self.target_ids
    }

    // .google.rpc.Status cause = 3;

    pub fn clear_cause(&mut self) {
        self.cause.clear();
    }

    pub fn has_cause(&self) -> bool {
        self.cause.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cause(&mut self, v: super::status::Status) {
        self.cause = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cause(&mut self) -> &mut super::status::Status {
        if self.cause.is_none() {
            self.cause.set_default();
        }
        self.cause.as_mut().unwrap()
    }

    // Take field
    pub fn take_cause(&mut self) -> super::status::Status {
        self.cause.take().unwrap_or_else(|| super::status::Status::new())
    }

    pub fn get_cause(&self) -> &super::status::Status {
        self.cause.as_ref().unwrap_or_else(|| super::status::Status::default_instance())
    }

    // bytes resume_token = 4;

    pub fn clear_resume_token(&mut self) {
        self.resume_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_resume_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.resume_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resume_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.resume_token
    }

    // Take field
    pub fn take_resume_token(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.resume_token, ::std::vec::Vec::new())
    }

    pub fn get_resume_token(&self) -> &[u8] {
        &self.resume_token
    }

    // .google.protobuf.Timestamp read_time = 6;

    pub fn clear_read_time(&mut self) {
        self.read_time.clear();
    }

    pub fn has_read_time(&self) -> bool {
        self.read_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_read_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.read_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_read_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.read_time.is_none() {
            self.read_time.set_default();
        }
        self.read_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_read_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.read_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_read_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.read_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }
}

impl ::protobuf::Message for TargetChange {
    fn is_initialized(&self) -> bool {
        for v in &self.cause {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.read_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.target_change_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.target_ids)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cause)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.resume_token)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.read_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.target_change_type != TargetChange_TargetChangeType::NO_CHANGE {
            my_size += ::protobuf::rt::enum_size(1, self.target_change_type);
        }
        for value in &self.target_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.cause.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.resume_token.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.resume_token);
        }
        if let Some(ref v) = self.read_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.target_change_type != TargetChange_TargetChangeType::NO_CHANGE {
            os.write_enum(1, self.target_change_type.value())?;
        }
        for v in &self.target_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(ref v) = self.cause.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.resume_token.is_empty() {
            os.write_bytes(4, &self.resume_token)?;
        }
        if let Some(ref v) = self.read_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TargetChange {
        TargetChange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TargetChange_TargetChangeType>>(
                    "target_change_type",
                    |m: &TargetChange| { &m.target_change_type },
                    |m: &mut TargetChange| { &mut m.target_change_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "target_ids",
                    |m: &TargetChange| { &m.target_ids },
                    |m: &mut TargetChange| { &mut m.target_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                    "cause",
                    |m: &TargetChange| { &m.cause },
                    |m: &mut TargetChange| { &mut m.cause },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "resume_token",
                    |m: &TargetChange| { &m.resume_token },
                    |m: &mut TargetChange| { &mut m.resume_token },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "read_time",
                    |m: &TargetChange| { &m.read_time },
                    |m: &mut TargetChange| { &mut m.read_time },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TargetChange>(
                    "TargetChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TargetChange {
        static mut instance: ::protobuf::lazy::Lazy<TargetChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TargetChange,
        };
        unsafe {
            instance.get(TargetChange::new)
        }
    }
}

impl ::protobuf::Clear for TargetChange {
    fn clear(&mut self) {
        self.clear_target_change_type();
        self.clear_target_ids();
        self.clear_cause();
        self.clear_resume_token();
        self.clear_read_time();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TargetChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetChange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TargetChange_TargetChangeType {
    NO_CHANGE = 0,
    ADD = 1,
    REMOVE = 2,
    CURRENT = 3,
    RESET = 4,
}

impl ::protobuf::ProtobufEnum for TargetChange_TargetChangeType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TargetChange_TargetChangeType> {
        match value {
            0 => ::std::option::Option::Some(TargetChange_TargetChangeType::NO_CHANGE),
            1 => ::std::option::Option::Some(TargetChange_TargetChangeType::ADD),
            2 => ::std::option::Option::Some(TargetChange_TargetChangeType::REMOVE),
            3 => ::std::option::Option::Some(TargetChange_TargetChangeType::CURRENT),
            4 => ::std::option::Option::Some(TargetChange_TargetChangeType::RESET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TargetChange_TargetChangeType] = &[
            TargetChange_TargetChangeType::NO_CHANGE,
            TargetChange_TargetChangeType::ADD,
            TargetChange_TargetChangeType::REMOVE,
            TargetChange_TargetChangeType::CURRENT,
            TargetChange_TargetChangeType::RESET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TargetChange_TargetChangeType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TargetChange_TargetChangeType {
}

impl ::std::default::Default for TargetChange_TargetChangeType {
    fn default() -> Self {
        TargetChange_TargetChangeType::NO_CHANGE
    }
}

impl ::protobuf::reflect::ProtobufValue for TargetChange_TargetChangeType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollectionIdsRequest {
    // message fields
    pub parent: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListCollectionIdsRequest {
    pub fn new() -> ListCollectionIdsRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;

    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    pub fn get_parent(&self) -> &str {
        &self.parent
    }

    // int32 page_size = 2;

    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }

    // string page_token = 3;

    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }

    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
}

impl ::protobuf::Message for ListCollectionIdsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if self.page_size != 0 {
            os.write_int32(2, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(3, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollectionIdsRequest {
        ListCollectionIdsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent",
                    |m: &ListCollectionIdsRequest| { &m.parent },
                    |m: &mut ListCollectionIdsRequest| { &mut m.parent },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "page_size",
                    |m: &ListCollectionIdsRequest| { &m.page_size },
                    |m: &mut ListCollectionIdsRequest| { &mut m.page_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "page_token",
                    |m: &ListCollectionIdsRequest| { &m.page_token },
                    |m: &mut ListCollectionIdsRequest| { &mut m.page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCollectionIdsRequest>(
                    "ListCollectionIdsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCollectionIdsRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListCollectionIdsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCollectionIdsRequest,
        };
        unsafe {
            instance.get(ListCollectionIdsRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListCollectionIdsRequest {
    fn clear(&mut self) {
        self.clear_parent();
        self.clear_page_size();
        self.clear_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollectionIdsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectionIdsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListCollectionIdsResponse {
    // message fields
    pub collection_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub next_page_token: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl ListCollectionIdsResponse {
    pub fn new() -> ListCollectionIdsResponse {
        ::std::default::Default::default()
    }

    // repeated string collection_ids = 1;

    pub fn clear_collection_ids(&mut self) {
        self.collection_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.collection_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collection_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.collection_ids
    }

    // Take field
    pub fn take_collection_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.collection_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_collection_ids(&self) -> &[::std::string::String] {
        &self.collection_ids
    }

    // string next_page_token = 2;

    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
}

impl ::protobuf::Message for ListCollectionIdsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.collection_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.collection_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.collection_ids {
            os.write_string(1, &v)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListCollectionIdsResponse {
        ListCollectionIdsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection_ids",
                    |m: &ListCollectionIdsResponse| { &m.collection_ids },
                    |m: &mut ListCollectionIdsResponse| { &mut m.collection_ids },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "next_page_token",
                    |m: &ListCollectionIdsResponse| { &m.next_page_token },
                    |m: &mut ListCollectionIdsResponse| { &mut m.next_page_token },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListCollectionIdsResponse>(
                    "ListCollectionIdsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListCollectionIdsResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListCollectionIdsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListCollectionIdsResponse,
        };
        unsafe {
            instance.get(ListCollectionIdsResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListCollectionIdsResponse {
    fn clear(&mut self) {
        self.clear_collection_ids();
        self.clear_next_page_token();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListCollectionIdsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListCollectionIdsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(google/firestore/v1beta1/firestore.proto\x12\x18google.firestore.v1be\
    ta1\x1a\x1cgoogle/api/annotations.proto\x1a%google/firestore/v1beta1/com\
    mon.proto\x1a'google/firestore/v1beta1/document.proto\x1a$google/firesto\
    re/v1beta1/query.proto\x1a$google/firestore/v1beta1/write.proto\x1a\x1bg\
    oogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\
    \x17google/rpc/status.proto\"\xdb\x01\n\x12GetDocumentRequest\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12:\n\x04mask\x18\x02\x20\x01(\x0b\
    2&.google.firestore.v1beta1.DocumentMaskR\x04mask\x12\"\n\x0btransaction\
    \x18\x03\x20\x01(\x0cH\0R\x0btransaction\x129\n\tread_time\x18\x05\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampH\0R\x08readTimeB\x16\n\x14consi\
    stency_selector\"\x80\x03\n\x14ListDocumentsRequest\x12\x16\n\x06parent\
    \x18\x01\x20\x01(\tR\x06parent\x12#\n\rcollection_id\x18\x02\x20\x01(\tR\
    \x0ccollectionId\x12\x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\
    \x12\x1d\n\npage_token\x18\x04\x20\x01(\tR\tpageToken\x12\x19\n\x08order\
    _by\x18\x06\x20\x01(\tR\x07orderBy\x12:\n\x04mask\x18\x07\x20\x01(\x0b2&\
    .google.firestore.v1beta1.DocumentMaskR\x04mask\x12\"\n\x0btransaction\
    \x18\x08\x20\x01(\x0cH\0R\x0btransaction\x129\n\tread_time\x18\n\x20\x01\
    (\x0b2\x1a.google.protobuf.TimestampH\0R\x08readTime\x12!\n\x0cshow_miss\
    ing\x18\x0c\x20\x01(\x08R\x0bshowMissingB\x16\n\x14consistency_selector\
    \"\x81\x01\n\x15ListDocumentsResponse\x12@\n\tdocuments\x18\x01\x20\x03(\
    \x0b2\".google.firestore.v1beta1.DocumentR\tdocuments\x12&\n\x0fnext_pag\
    e_token\x18\x02\x20\x01(\tR\rnextPageToken\"\xf1\x01\n\x15CreateDocument\
    Request\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\x12#\n\rcollec\
    tion_id\x18\x02\x20\x01(\tR\x0ccollectionId\x12\x1f\n\x0bdocument_id\x18\
    \x03\x20\x01(\tR\ndocumentId\x12>\n\x08document\x18\x04\x20\x01(\x0b2\".\
    google.firestore.v1beta1.DocumentR\x08document\x12:\n\x04mask\x18\x05\
    \x20\x01(\x0b2&.google.firestore.v1beta1.DocumentMaskR\x04mask\"\xaf\x02\
    \n\x15UpdateDocumentRequest\x12>\n\x08document\x18\x01\x20\x01(\x0b2\".g\
    oogle.firestore.v1beta1.DocumentR\x08document\x12G\n\x0bupdate_mask\x18\
    \x02\x20\x01(\x0b2&.google.firestore.v1beta1.DocumentMaskR\nupdateMask\
    \x12:\n\x04mask\x18\x03\x20\x01(\x0b2&.google.firestore.v1beta1.Document\
    MaskR\x04mask\x12Q\n\x10current_document\x18\x04\x20\x01(\x0b2&.google.f\
    irestore.v1beta1.PreconditionR\x0fcurrentDocument\"~\n\x15DeleteDocument\
    Request\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12Q\n\x10current_\
    document\x18\x02\x20\x01(\x0b2&.google.firestore.v1beta1.PreconditionR\
    \x0fcurrentDocument\"\xe0\x02\n\x18BatchGetDocumentsRequest\x12\x1a\n\
    \x08database\x18\x01\x20\x01(\tR\x08database\x12\x1c\n\tdocuments\x18\
    \x02\x20\x03(\tR\tdocuments\x12:\n\x04mask\x18\x03\x20\x01(\x0b2&.google\
    .firestore.v1beta1.DocumentMaskR\x04mask\x12\"\n\x0btransaction\x18\x04\
    \x20\x01(\x0cH\0R\x0btransaction\x12W\n\x0fnew_transaction\x18\x05\x20\
    \x01(\x0b2,.google.firestore.v1beta1.TransactionOptionsH\0R\x0enewTransa\
    ction\x129\n\tread_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.Timest\
    ampH\0R\x08readTimeB\x16\n\x14consistency_selector\"\xd8\x01\n\x19BatchG\
    etDocumentsResponse\x12:\n\x05found\x18\x01\x20\x01(\x0b2\".google.fires\
    tore.v1beta1.DocumentH\0R\x05found\x12\x1a\n\x07missing\x18\x02\x20\x01(\
    \tH\0R\x07missing\x12\x20\n\x0btransaction\x18\x03\x20\x01(\x0cR\x0btran\
    saction\x127\n\tread_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.Time\
    stampR\x08readTimeB\x08\n\x06result\"}\n\x17BeginTransactionRequest\x12\
    \x1a\n\x08database\x18\x01\x20\x01(\tR\x08database\x12F\n\x07options\x18\
    \x02\x20\x01(\x0b2,.google.firestore.v1beta1.TransactionOptionsR\x07opti\
    ons\"<\n\x18BeginTransactionResponse\x12\x20\n\x0btransaction\x18\x01\
    \x20\x01(\x0cR\x0btransaction\"\x86\x01\n\rCommitRequest\x12\x1a\n\x08da\
    tabase\x18\x01\x20\x01(\tR\x08database\x127\n\x06writes\x18\x02\x20\x03(\
    \x0b2\x1f.google.firestore.v1beta1.WriteR\x06writes\x12\x20\n\x0btransac\
    tion\x18\x03\x20\x01(\x0cR\x0btransaction\"\x99\x01\n\x0eCommitResponse\
    \x12J\n\rwrite_results\x18\x01\x20\x03(\x0b2%.google.firestore.v1beta1.W\
    riteResultR\x0cwriteResults\x12;\n\x0bcommit_time\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\ncommitTime\"O\n\x0fRollbackRequest\x12\
    \x1a\n\x08database\x18\x01\x20\x01(\tR\x08database\x12\x20\n\x0btransact\
    ion\x18\x02\x20\x01(\x0cR\x0btransaction\"\xdf\x02\n\x0fRunQueryRequest\
    \x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\x12V\n\x10structured_\
    query\x18\x02\x20\x01(\x0b2).google.firestore.v1beta1.StructuredQueryH\0\
    R\x0fstructuredQuery\x12\"\n\x0btransaction\x18\x05\x20\x01(\x0cH\x01R\
    \x0btransaction\x12W\n\x0fnew_transaction\x18\x06\x20\x01(\x0b2,.google.\
    firestore.v1beta1.TransactionOptionsH\x01R\x0enewTransaction\x129\n\trea\
    d_time\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\x01R\x08read\
    TimeB\x0c\n\nquery_typeB\x16\n\x14consistency_selector\"\xd6\x01\n\x10Ru\
    nQueryResponse\x12\x20\n\x0btransaction\x18\x02\x20\x01(\x0cR\x0btransac\
    tion\x12>\n\x08document\x18\x01\x20\x01(\x0b2\".google.firestore.v1beta1\
    .DocumentR\x08document\x127\n\tread_time\x18\x03\x20\x01(\x0b2\x1a.googl\
    e.protobuf.TimestampR\x08readTime\x12'\n\x0fskipped_results\x18\x04\x20\
    \x01(\x05R\x0eskippedResults\"\xaa\x02\n\x0cWriteRequest\x12\x1a\n\x08da\
    tabase\x18\x01\x20\x01(\tR\x08database\x12\x1b\n\tstream_id\x18\x02\x20\
    \x01(\tR\x08streamId\x127\n\x06writes\x18\x03\x20\x03(\x0b2\x1f.google.f\
    irestore.v1beta1.WriteR\x06writes\x12!\n\x0cstream_token\x18\x04\x20\x01\
    (\x0cR\x0bstreamToken\x12J\n\x06labels\x18\x05\x20\x03(\x0b22.google.fir\
    estore.v1beta1.WriteRequest.LabelsEntryR\x06labels\x1a9\n\x0bLabelsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\xd8\x01\n\rWriteResponse\x12\x1b\n\tst\
    ream_id\x18\x01\x20\x01(\tR\x08streamId\x12!\n\x0cstream_token\x18\x02\
    \x20\x01(\x0cR\x0bstreamToken\x12J\n\rwrite_results\x18\x03\x20\x03(\x0b\
    2%.google.firestore.v1beta1.WriteResultR\x0cwriteResults\x12;\n\x0bcommi\
    t_time\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ncommitTime\
    \"\xae\x02\n\rListenRequest\x12\x1a\n\x08database\x18\x01\x20\x01(\tR\
    \x08database\x12A\n\nadd_target\x18\x02\x20\x01(\x0b2\x20.google.firesto\
    re.v1beta1.TargetH\0R\taddTarget\x12%\n\rremove_target\x18\x03\x20\x01(\
    \x05H\0R\x0cremoveTarget\x12K\n\x06labels\x18\x04\x20\x03(\x0b23.google.\
    firestore.v1beta1.ListenRequest.LabelsEntryR\x06labels\x1a9\n\x0bLabelsE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01B\x0f\n\rtarget_change\"\xb4\x03\n\
    \x0eListenResponse\x12M\n\rtarget_change\x18\x02\x20\x01(\x0b2&.google.f\
    irestore.v1beta1.TargetChangeH\0R\x0ctargetChange\x12S\n\x0fdocument_cha\
    nge\x18\x03\x20\x01(\x0b2(.google.firestore.v1beta1.DocumentChangeH\0R\
    \x0edocumentChange\x12S\n\x0fdocument_delete\x18\x04\x20\x01(\x0b2(.goog\
    le.firestore.v1beta1.DocumentDeleteH\0R\x0edocumentDelete\x12S\n\x0fdocu\
    ment_remove\x18\x06\x20\x01(\x0b2(.google.firestore.v1beta1.DocumentRemo\
    veH\0R\x0edocumentRemove\x12C\n\x06filter\x18\x05\x20\x01(\x0b2).google.\
    firestore.v1beta1.ExistenceFilterH\0R\x06filterB\x0f\n\rresponse_type\"\
    \x8e\x04\n\x06Target\x12D\n\x05query\x18\x02\x20\x01(\x0b2,.google.fires\
    tore.v1beta1.Target.QueryTargetH\0R\x05query\x12P\n\tdocuments\x18\x03\
    \x20\x01(\x0b20.google.firestore.v1beta1.Target.DocumentsTargetH\0R\tdoc\
    uments\x12#\n\x0cresume_token\x18\x04\x20\x01(\x0cH\x01R\x0bresumeToken\
    \x129\n\tread_time\x18\x0b\x20\x01(\x0b2\x1a.google.protobuf.TimestampH\
    \x01R\x08readTime\x12\x1b\n\ttarget_id\x18\x05\x20\x01(\x05R\x08targetId\
    \x12\x12\n\x04once\x18\x06\x20\x01(\x08R\x04once\x1a/\n\x0fDocumentsTarg\
    et\x12\x1c\n\tdocuments\x18\x02\x20\x03(\tR\tdocuments\x1a\x8b\x01\n\x0b\
    QueryTarget\x12\x16\n\x06parent\x18\x01\x20\x01(\tR\x06parent\x12V\n\x10\
    structured_query\x18\x02\x20\x01(\x0b2).google.firestore.v1beta1.Structu\
    redQueryH\0R\x0fstructuredQueryB\x0c\n\nquery_typeB\r\n\x0btarget_typeB\
    \r\n\x0bresume_type\"\xea\x02\n\x0cTargetChange\x12e\n\x12target_change_\
    type\x18\x01\x20\x01(\x0e27.google.firestore.v1beta1.TargetChange.Target\
    ChangeTypeR\x10targetChangeType\x12\x1d\n\ntarget_ids\x18\x02\x20\x03(\
    \x05R\ttargetIds\x12(\n\x05cause\x18\x03\x20\x01(\x0b2\x12.google.rpc.St\
    atusR\x05cause\x12!\n\x0cresume_token\x18\x04\x20\x01(\x0cR\x0bresumeTok\
    en\x127\n\tread_time\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.Timestamp\
    R\x08readTime\"N\n\x10TargetChangeType\x12\r\n\tNO_CHANGE\x10\0\x12\x07\
    \n\x03ADD\x10\x01\x12\n\n\x06REMOVE\x10\x02\x12\x0b\n\x07CURRENT\x10\x03\
    \x12\t\n\x05RESET\x10\x04\"n\n\x18ListCollectionIdsRequest\x12\x16\n\x06\
    parent\x18\x01\x20\x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x02\x20\
    \x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03\x20\x01(\tR\tpageTo\
    ken\"j\n\x19ListCollectionIdsResponse\x12%\n\x0ecollection_ids\x18\x01\
    \x20\x03(\tR\rcollectionIds\x12&\n\x0fnext_page_token\x18\x02\x20\x01(\t\
    R\rnextPageToken2\xc8\x13\n\tFirestore\x12\x9e\x01\n\x0bGetDocument\x12,\
    .google.firestore.v1beta1.GetDocumentRequest\x1a\".google.firestore.v1be\
    ta1.Document\"=\x82\xd3\xe4\x93\x027\x125/v1beta1/{name=projects/*/datab\
    ases/*/documents/*/**}\x12\xc1\x01\n\rListDocuments\x12..google.firestor\
    e.v1beta1.ListDocumentsRequest\x1a/.google.firestore.v1beta1.ListDocumen\
    tsResponse\"O\x82\xd3\xe4\x93\x02I\x12G/v1beta1/{parent=projects/*/datab\
    ases/*/documents/*/**}/{collection_id}\x12\xbe\x01\n\x0eCreateDocument\
    \x12/.google.firestore.v1beta1.CreateDocumentRequest\x1a\".google.firest\
    ore.v1beta1.Document\"W\x82\xd3\xe4\x93\x02Q\"E/v1beta1/{parent=projects\
    /*/databases/*/documents/**}/{collection_id}:\x08document\x12\xb7\x01\n\
    \x0eUpdateDocument\x12/.google.firestore.v1beta1.UpdateDocumentRequest\
    \x1a\".google.firestore.v1beta1.Document\"P\x82\xd3\xe4\x93\x02J2>/v1bet\
    a1/{document.name=projects/*/databases/*/documents/*/**}:\x08document\
    \x12\x98\x01\n\x0eDeleteDocument\x12/.google.firestore.v1beta1.DeleteDoc\
    umentRequest\x1a\x16.google.protobuf.Empty\"=\x82\xd3\xe4\x93\x027*5/v1b\
    eta1/{name=projects/*/databases/*/documents/*/**}\x12\xc8\x01\n\x11Batch\
    GetDocuments\x122.google.firestore.v1beta1.BatchGetDocumentsRequest\x1a3\
    .google.firestore.v1beta1.BatchGetDocumentsResponse\"H\x82\xd3\xe4\x93\
    \x02B\"=/v1beta1/{database=projects/*/databases/*}/documents:batchGet:\
    \x01*0\x01\x12\xcb\x01\n\x10BeginTransaction\x121.google.firestore.v1bet\
    a1.BeginTransactionRequest\x1a2.google.firestore.v1beta1.BeginTransactio\
    nResponse\"P\x82\xd3\xe4\x93\x02J\"E/v1beta1/{database=projects/*/databa\
    ses/*}/documents:beginTransaction:\x01*\x12\xa3\x01\n\x06Commit\x12'.goo\
    gle.firestore.v1beta1.CommitRequest\x1a(.google.firestore.v1beta1.Commit\
    Response\"F\x82\xd3\xe4\x93\x02@\";/v1beta1/{database=projects/*/databas\
    es/*}/documents:commit:\x01*\x12\x97\x01\n\x08Rollback\x12).google.fires\
    tore.v1beta1.RollbackRequest\x1a\x16.google.protobuf.Empty\"H\x82\xd3\
    \xe4\x93\x02B\"=/v1beta1/{database=projects/*/databases/*}/documents:rol\
    lback:\x01*\x12\xf4\x01\n\x08RunQuery\x12).google.firestore.v1beta1.RunQ\
    ueryRequest\x1a*.google.firestore.v1beta1.RunQueryResponse\"\x8e\x01\x82\
    \xd3\xe4\x93\x02\x87\x01\";/v1beta1/{parent=projects/*/databases/*/docum\
    ents}:runQuery:\x01*ZE\"@/v1beta1/{parent=projects/*/databases/*/documen\
    ts/*/**}:runQuery:\x01*0\x01\x12\xa3\x01\n\x05Write\x12&.google.firestor\
    e.v1beta1.WriteRequest\x1a'.google.firestore.v1beta1.WriteResponse\"E\
    \x82\xd3\xe4\x93\x02?\":/v1beta1/{database=projects/*/databases/*}/docum\
    ents:write:\x01*(\x010\x01\x12\xa7\x01\n\x06Listen\x12'.google.firestore\
    .v1beta1.ListenRequest\x1a(.google.firestore.v1beta1.ListenResponse\"F\
    \x82\xd3\xe4\x93\x02@\";/v1beta1/{database=projects/*/databases/*}/docum\
    ents:listen:\x01*(\x010\x01\x12\x9f\x02\n\x11ListCollectionIds\x122.goog\
    le.firestore.v1beta1.ListCollectionIdsRequest\x1a3.google.firestore.v1be\
    ta1.ListCollectionIdsResponse\"\xa0\x01\x82\xd3\xe4\x93\x02\x99\x01\"D/v\
    1beta1/{parent=projects/*/databases/*/documents}:listCollectionIds:\x01*\
    ZN\"I/v1beta1/{parent=projects/*/databases/*/documents/*/**}:listCollect\
    ionIds:\x01*B\xbc\x01\n\x1ccom.google.firestore.v1beta1B\x0eFirestorePro\
    toP\x01ZAgoogle.golang.org/genproto/googleapis/firestore/v1beta1;firesto\
    re\xa2\x02\x04GCFS\xaa\x02\x1eGoogle.Cloud.Firestore.V1Beta1\xca\x02\x1e\
    Google\\Cloud\\Firestore\\V1beta1J\xe1\xe3\x01\n\x07\x12\x05\x0e\0\xf7\
    \x05\x01\n\xbc\x04\n\x01\x0c\x12\x03\x0e\0\x122\xb1\x04\x20Copyright\x20\
    2018\x20Google\x20LLC\n\n\x20Licensed\x20under\x20the\x20Apache\x20Licen\
    se,\x20Version\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\
    \x20use\x20this\x20file\x20except\x20in\x20compliance\x20with\x20the\x20\
    License.\n\x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\
    \x20at\n\n\x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\
    \n\n\x20Unless\x20required\x20by\x20applicable\x20law\x20or\x20agreed\
    \x20to\x20in\x20writing,\x20software\n\x20distributed\x20under\x20the\
    \x20License\x20is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\
    \x20WITHOUT\x20WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20e\
    ither\x20express\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20\
    the\x20specific\x20language\x20governing\x20permissions\x20and\n\x20limi\
    tations\x20under\x20the\x20License.\n\n\x08\n\x01\x02\x12\x03\x10\x08\
    \x20\n\t\n\x02\x03\0\x12\x03\x12\x07%\n\t\n\x02\x03\x01\x12\x03\x13\x07.\
    \n\t\n\x02\x03\x02\x12\x03\x14\x070\n\t\n\x02\x03\x03\x12\x03\x15\x07-\n\
    \t\n\x02\x03\x04\x12\x03\x16\x07-\n\t\n\x02\x03\x05\x12\x03\x17\x07$\n\t\
    \n\x02\x03\x06\x12\x03\x18\x07(\n\t\n\x02\x03\x07\x12\x03\x19\x07\x20\n\
    \x08\n\x01\x08\x12\x03\x1b\0;\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x1b\0;\n\
    \x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x1b\x07\x17\n\r\n\x06\x08\xe7\x07\0\
    \x02\0\x12\x03\x1b\x07\x17\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\
    \x1b\x07\x17\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x1b\x1a:\n\x08\n\x01\
    \x08\x12\x03\x1c\0X\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x1c\0X\n\x0c\n\
    \x05\x08\xe7\x07\x01\x02\x12\x03\x1c\x07\x11\n\r\n\x06\x08\xe7\x07\x01\
    \x02\0\x12\x03\x1c\x07\x11\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\
    \x1c\x07\x11\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x1c\x14W\n\x08\n\
    \x01\x08\x12\x03\x1d\0\"\n\x0b\n\x04\x08\xe7\x07\x02\x12\x03\x1d\0\"\n\
    \x0c\n\x05\x08\xe7\x07\x02\x02\x12\x03\x1d\x07\x1a\n\r\n\x06\x08\xe7\x07\
    \x02\x02\0\x12\x03\x1d\x07\x1a\n\x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\
    \x03\x1d\x07\x1a\n\x0c\n\x05\x08\xe7\x07\x02\x03\x12\x03\x1d\x1d!\n\x08\
    \n\x01\x08\x12\x03\x1e\0/\n\x0b\n\x04\x08\xe7\x07\x03\x12\x03\x1e\0/\n\
    \x0c\n\x05\x08\xe7\x07\x03\x02\x12\x03\x1e\x07\x1b\n\r\n\x06\x08\xe7\x07\
    \x03\x02\0\x12\x03\x1e\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\
    \x03\x1e\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x03\x07\x12\x03\x1e\x1e.\n\x08\
    \n\x01\x08\x12\x03\x1f\05\n\x0b\n\x04\x08\xe7\x07\x04\x12\x03\x1f\05\n\
    \x0c\n\x05\x08\xe7\x07\x04\x02\x12\x03\x1f\x07\x13\n\r\n\x06\x08\xe7\x07\
    \x04\x02\0\x12\x03\x1f\x07\x13\n\x0e\n\x07\x08\xe7\x07\x04\x02\0\x01\x12\
    \x03\x1f\x07\x13\n\x0c\n\x05\x08\xe7\x07\x04\x07\x12\x03\x1f\x164\n\x08\
    \n\x01\x08\x12\x03\x20\0\"\n\x0b\n\x04\x08\xe7\x07\x05\x12\x03\x20\0\"\n\
    \x0c\n\x05\x08\xe7\x07\x05\x02\x12\x03\x20\x07\x18\n\r\n\x06\x08\xe7\x07\
    \x05\x02\0\x12\x03\x20\x07\x18\n\x0e\n\x07\x08\xe7\x07\x05\x02\0\x01\x12\
    \x03\x20\x07\x18\n\x0c\n\x05\x08\xe7\x07\x05\x07\x12\x03\x20\x1b!\n\x08\
    \n\x01\x08\x12\x03!\0;\n2\n\x04\x08\xe7\x07\x06\x12\x03!\0;\"%\x20Specif\
    ication\x20of\x20the\x20Firestore\x20API.\n\n\x0c\n\x05\x08\xe7\x07\x06\
    \x02\x12\x03!\x07\x14\n\r\n\x06\x08\xe7\x07\x06\x02\0\x12\x03!\x07\x14\n\
    \x0e\n\x07\x08\xe7\x07\x06\x02\0\x01\x12\x03!\x07\x14\n\x0c\n\x05\x08\
    \xe7\x07\x06\x07\x12\x03!\x17:\n\x81\x07\n\x02\x06\0\x12\x054\0\xa4\x01\
    \x01\x1a\xf3\x06\x20The\x20Cloud\x20Firestore\x20service.\n\n\x20This\
    \x20service\x20exposes\x20several\x20types\x20of\x20comparable\x20timest\
    amps:\n\n\x20*\x20\x20\x20\x20`create_time`\x20-\x20The\x20time\x20at\
    \x20which\x20a\x20document\x20was\x20created.\x20Changes\x20only\n\x20\
    \x20\x20\x20\x20\x20when\x20a\x20document\x20is\x20deleted,\x20then\x20r\
    e-created.\x20Increases\x20in\x20a\x20strict\n\x20\x20\x20\x20\x20\x20\
    \x20monotonic\x20fashion.\n\x20*\x20\x20\x20\x20`update_time`\x20-\x20Th\
    e\x20time\x20at\x20which\x20a\x20document\x20was\x20last\x20updated.\x20\
    Changes\n\x20\x20\x20\x20\x20\x20every\x20time\x20a\x20document\x20is\
    \x20modified.\x20Does\x20not\x20change\x20when\x20a\x20write\x20results\
    \n\x20\x20\x20\x20\x20\x20in\x20no\x20modifications.\x20Increases\x20in\
    \x20a\x20strict\x20monotonic\x20fashion.\n\x20*\x20\x20\x20\x20`read_tim\
    e`\x20-\x20The\x20time\x20at\x20which\x20a\x20particular\x20state\x20was\
    \x20observed.\x20Used\n\x20\x20\x20\x20\x20\x20to\x20denote\x20a\x20cons\
    istent\x20snapshot\x20of\x20the\x20database\x20or\x20the\x20time\x20at\
    \x20which\x20a\n\x20\x20\x20\x20\x20\x20Document\x20was\x20observed\x20t\
    o\x20not\x20exist.\n\x20*\x20\x20\x20\x20`commit_time`\x20-\x20The\x20ti\
    me\x20at\x20which\x20the\x20writes\x20in\x20a\x20transaction\x20were\n\
    \x20\x20\x20\x20\x20\x20committed.\x20Any\x20read\x20with\x20an\x20equal\
    \x20or\x20greater\x20`read_time`\x20is\x20guaranteed\n\x20\x20\x20\x20\
    \x20\x20to\x20see\x20the\x20effects\x20of\x20the\x20transaction.\n\n\n\n\
    \x03\x06\0\x01\x12\x034\x08\x11\n'\n\x04\x06\0\x02\0\x12\x046\x02:\x03\
    \x1a\x19\x20Gets\x20a\x20single\x20document.\n\n\x0c\n\x05\x06\0\x02\0\
    \x01\x12\x036\x06\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x036\x12$\n\x0c\n\
    \x05\x06\0\x02\0\x03\x12\x036/7\n\r\n\x05\x06\0\x02\0\x04\x12\x047\x049\
    \x06\n\x10\n\x08\x06\0\x02\0\x04\xe7\x07\0\x12\x047\x049\x06\n\x10\n\t\
    \x06\0\x02\0\x04\xe7\x07\0\x02\x12\x037\x0b\x1c\n\x11\n\n\x06\0\x02\0\
    \x04\xe7\x07\0\x02\0\x12\x037\x0b\x1c\n\x12\n\x0b\x06\0\x02\0\x04\xe7\
    \x07\0\x02\0\x01\x12\x037\x0c\x1b\n\x11\n\t\x06\0\x02\0\x04\xe7\x07\0\
    \x08\x12\x047\x1f9\x05\n\x20\n\x04\x06\0\x02\x01\x12\x04=\x02A\x03\x1a\
    \x12\x20Lists\x20documents.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03=\x06\
    \x13\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03=\x14(\n\x0c\n\x05\x06\0\x02\
    \x01\x03\x12\x03=3H\n\r\n\x05\x06\0\x02\x01\x04\x12\x04>\x04@\x06\n\x10\
    \n\x08\x06\0\x02\x01\x04\xe7\x07\0\x12\x04>\x04@\x06\n\x10\n\t\x06\0\x02\
    \x01\x04\xe7\x07\0\x02\x12\x03>\x0b\x1c\n\x11\n\n\x06\0\x02\x01\x04\xe7\
    \x07\0\x02\0\x12\x03>\x0b\x1c\n\x12\n\x0b\x06\0\x02\x01\x04\xe7\x07\0\
    \x02\0\x01\x12\x03>\x0c\x1b\n\x11\n\t\x06\0\x02\x01\x04\xe7\x07\0\x08\
    \x12\x04>\x1f@\x05\n'\n\x04\x06\0\x02\x02\x12\x04D\x02I\x03\x1a\x19\x20C\
    reates\x20a\x20new\x20document.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03D\
    \x06\x14\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03D\x15*\n\x0c\n\x05\x06\0\
    \x02\x02\x03\x12\x03D5=\n\r\n\x05\x06\0\x02\x02\x04\x12\x04E\x04H\x06\n\
    \x10\n\x08\x06\0\x02\x02\x04\xe7\x07\0\x12\x04E\x04H\x06\n\x10\n\t\x06\0\
    \x02\x02\x04\xe7\x07\0\x02\x12\x03E\x0b\x1c\n\x11\n\n\x06\0\x02\x02\x04\
    \xe7\x07\0\x02\0\x12\x03E\x0b\x1c\n\x12\n\x0b\x06\0\x02\x02\x04\xe7\x07\
    \0\x02\0\x01\x12\x03E\x0c\x1b\n\x11\n\t\x06\0\x02\x02\x04\xe7\x07\0\x08\
    \x12\x04E\x1fH\x05\n.\n\x04\x06\0\x02\x03\x12\x04L\x02Q\x03\x1a\x20\x20U\
    pdates\x20or\x20inserts\x20a\x20document.\n\n\x0c\n\x05\x06\0\x02\x03\
    \x01\x12\x03L\x06\x14\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03L\x15*\n\x0c\
    \n\x05\x06\0\x02\x03\x03\x12\x03L5=\n\r\n\x05\x06\0\x02\x03\x04\x12\x04M\
    \x04P\x06\n\x10\n\x08\x06\0\x02\x03\x04\xe7\x07\0\x12\x04M\x04P\x06\n\
    \x10\n\t\x06\0\x02\x03\x04\xe7\x07\0\x02\x12\x03M\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x03\x04\xe7\x07\0\x02\0\x12\x03M\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x03\x04\xe7\x07\0\x02\0\x01\x12\x03M\x0c\x1b\n\x11\n\t\x06\0\x02\x03\
    \x04\xe7\x07\0\x08\x12\x04M\x1fP\x05\n#\n\x04\x06\0\x02\x04\x12\x04T\x02\
    X\x03\x1a\x15\x20Deletes\x20a\x20document.\n\n\x0c\n\x05\x06\0\x02\x04\
    \x01\x12\x03T\x06\x14\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03T\x15*\n\x0c\
    \n\x05\x06\0\x02\x04\x03\x12\x03T5J\n\r\n\x05\x06\0\x02\x04\x04\x12\x04U\
    \x04W\x06\n\x10\n\x08\x06\0\x02\x04\x04\xe7\x07\0\x12\x04U\x04W\x06\n\
    \x10\n\t\x06\0\x02\x04\x04\xe7\x07\0\x02\x12\x03U\x0b\x1c\n\x11\n\n\x06\
    \0\x02\x04\x04\xe7\x07\0\x02\0\x12\x03U\x0b\x1c\n\x12\n\x0b\x06\0\x02\
    \x04\x04\xe7\x07\0\x02\0\x01\x12\x03U\x0c\x1b\n\x11\n\t\x06\0\x02\x04\
    \x04\xe7\x07\0\x08\x12\x04U\x1fW\x05\n\x9c\x01\n\x04\x06\0\x02\x05\x12\
    \x04^\x02c\x03\x1a\x8d\x01\x20Gets\x20multiple\x20documents.\n\n\x20Docu\
    ments\x20returned\x20by\x20this\x20method\x20are\x20not\x20guaranteed\
    \x20to\x20be\x20returned\x20in\x20the\n\x20same\x20order\x20that\x20they\
    \x20were\x20requested.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03^\x06\x17\
    \n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03^\x180\n\x0c\n\x05\x06\0\x02\x05\
    \x06\x12\x03^;A\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03^B[\n\r\n\x05\x06\0\
    \x02\x05\x04\x12\x04_\x04b\x06\n\x10\n\x08\x06\0\x02\x05\x04\xe7\x07\0\
    \x12\x04_\x04b\x06\n\x10\n\t\x06\0\x02\x05\x04\xe7\x07\0\x02\x12\x03_\
    \x0b\x1c\n\x11\n\n\x06\0\x02\x05\x04\xe7\x07\0\x02\0\x12\x03_\x0b\x1c\n\
    \x12\n\x0b\x06\0\x02\x05\x04\xe7\x07\0\x02\0\x01\x12\x03_\x0c\x1b\n\x11\
    \n\t\x06\0\x02\x05\x04\xe7\x07\0\x08\x12\x04_\x1fb\x05\n)\n\x04\x06\0\
    \x02\x06\x12\x04f\x02k\x03\x1a\x1b\x20Starts\x20a\x20new\x20transaction.\
    \n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03f\x06\x16\n\x0c\n\x05\x06\0\x02\
    \x06\x02\x12\x03f\x17.\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x03f9Q\n\r\n\
    \x05\x06\0\x02\x06\x04\x12\x04g\x04j\x06\n\x10\n\x08\x06\0\x02\x06\x04\
    \xe7\x07\0\x12\x04g\x04j\x06\n\x10\n\t\x06\0\x02\x06\x04\xe7\x07\0\x02\
    \x12\x03g\x0b\x1c\n\x11\n\n\x06\0\x02\x06\x04\xe7\x07\0\x02\0\x12\x03g\
    \x0b\x1c\n\x12\n\x0b\x06\0\x02\x06\x04\xe7\x07\0\x02\0\x01\x12\x03g\x0c\
    \x1b\n\x11\n\t\x06\0\x02\x06\x04\xe7\x07\0\x08\x12\x04g\x1fj\x05\nK\n\
    \x04\x06\0\x02\x07\x12\x04n\x02s\x03\x1a=\x20Commits\x20a\x20transaction\
    ,\x20while\x20optionally\x20updating\x20documents.\n\n\x0c\n\x05\x06\0\
    \x02\x07\x01\x12\x03n\x06\x0c\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03n\r\
    \x1a\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x03n%3\n\r\n\x05\x06\0\x02\x07\
    \x04\x12\x04o\x04r\x06\n\x10\n\x08\x06\0\x02\x07\x04\xe7\x07\0\x12\x04o\
    \x04r\x06\n\x10\n\t\x06\0\x02\x07\x04\xe7\x07\0\x02\x12\x03o\x0b\x1c\n\
    \x11\n\n\x06\0\x02\x07\x04\xe7\x07\0\x02\0\x12\x03o\x0b\x1c\n\x12\n\x0b\
    \x06\0\x02\x07\x04\xe7\x07\0\x02\0\x01\x12\x03o\x0c\x1b\n\x11\n\t\x06\0\
    \x02\x07\x04\xe7\x07\0\x08\x12\x04o\x1fr\x05\n)\n\x04\x06\0\x02\x08\x12\
    \x04v\x02{\x03\x1a\x1b\x20Rolls\x20back\x20a\x20transaction.\n\n\x0c\n\
    \x05\x06\0\x02\x08\x01\x12\x03v\x06\x0e\n\x0c\n\x05\x06\0\x02\x08\x02\
    \x12\x03v\x0f\x1e\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03v)>\n\r\n\x05\x06\
    \0\x02\x08\x04\x12\x04w\x04z\x06\n\x10\n\x08\x06\0\x02\x08\x04\xe7\x07\0\
    \x12\x04w\x04z\x06\n\x10\n\t\x06\0\x02\x08\x04\xe7\x07\0\x02\x12\x03w\
    \x0b\x1c\n\x11\n\n\x06\0\x02\x08\x04\xe7\x07\0\x02\0\x12\x03w\x0b\x1c\n\
    \x12\n\x0b\x06\0\x02\x08\x04\xe7\x07\0\x02\0\x01\x12\x03w\x0c\x1b\n\x11\
    \n\t\x06\0\x02\x08\x04\xe7\x07\0\x08\x12\x04w\x1fz\x05\n\x1e\n\x04\x06\0\
    \x02\t\x12\x05~\x02\x87\x01\x03\x1a\x0f\x20Runs\x20a\x20query.\n\n\x0c\n\
    \x05\x06\0\x02\t\x01\x12\x03~\x06\x0e\n\x0c\n\x05\x06\0\x02\t\x02\x12\
    \x03~\x0f\x1e\n\x0c\n\x05\x06\0\x02\t\x06\x12\x03~)/\n\x0c\n\x05\x06\0\
    \x02\t\x03\x12\x03~0@\n\x0e\n\x05\x06\0\x02\t\x04\x12\x05\x7f\x04\x86\
    \x01\x06\n\x11\n\x08\x06\0\x02\t\x04\xe7\x07\0\x12\x05\x7f\x04\x86\x01\
    \x06\n\x10\n\t\x06\0\x02\t\x04\xe7\x07\0\x02\x12\x03\x7f\x0b\x1c\n\x11\n\
    \n\x06\0\x02\t\x04\xe7\x07\0\x02\0\x12\x03\x7f\x0b\x1c\n\x12\n\x0b\x06\0\
    \x02\t\x04\xe7\x07\0\x02\0\x01\x12\x03\x7f\x0c\x1b\n\x12\n\t\x06\0\x02\t\
    \x04\xe7\x07\0\x08\x12\x05\x7f\x1f\x86\x01\x05\nL\n\x04\x06\0\x02\n\x12\
    \x06\x8a\x01\x02\x8f\x01\x03\x1a<\x20Streams\x20batches\x20of\x20documen\
    t\x20updates\x20and\x20deletes,\x20in\x20order.\n\n\r\n\x05\x06\0\x02\n\
    \x01\x12\x04\x8a\x01\x06\x0b\n\r\n\x05\x06\0\x02\n\x05\x12\x04\x8a\x01\
    \x0c\x12\n\r\n\x05\x06\0\x02\n\x02\x12\x04\x8a\x01\x13\x1f\n\r\n\x05\x06\
    \0\x02\n\x06\x12\x04\x8a\x01*0\n\r\n\x05\x06\0\x02\n\x03\x12\x04\x8a\x01\
    1>\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\x8b\x01\x04\x8e\x01\x06\n\x12\n\
    \x08\x06\0\x02\n\x04\xe7\x07\0\x12\x06\x8b\x01\x04\x8e\x01\x06\n\x11\n\t\
    \x06\0\x02\n\x04\xe7\x07\0\x02\x12\x04\x8b\x01\x0b\x1c\n\x12\n\n\x06\0\
    \x02\n\x04\xe7\x07\0\x02\0\x12\x04\x8b\x01\x0b\x1c\n\x13\n\x0b\x06\0\x02\
    \n\x04\xe7\x07\0\x02\0\x01\x12\x04\x8b\x01\x0c\x1b\n\x13\n\t\x06\0\x02\n\
    \x04\xe7\x07\0\x08\x12\x06\x8b\x01\x1f\x8e\x01\x05\n%\n\x04\x06\0\x02\
    \x0b\x12\x06\x92\x01\x02\x97\x01\x03\x1a\x15\x20Listens\x20to\x20changes\
    .\n\n\r\n\x05\x06\0\x02\x0b\x01\x12\x04\x92\x01\x06\x0c\n\r\n\x05\x06\0\
    \x02\x0b\x05\x12\x04\x92\x01\r\x13\n\r\n\x05\x06\0\x02\x0b\x02\x12\x04\
    \x92\x01\x14!\n\r\n\x05\x06\0\x02\x0b\x06\x12\x04\x92\x01,2\n\r\n\x05\
    \x06\0\x02\x0b\x03\x12\x04\x92\x013A\n\x0f\n\x05\x06\0\x02\x0b\x04\x12\
    \x06\x93\x01\x04\x96\x01\x06\n\x12\n\x08\x06\0\x02\x0b\x04\xe7\x07\0\x12\
    \x06\x93\x01\x04\x96\x01\x06\n\x11\n\t\x06\0\x02\x0b\x04\xe7\x07\0\x02\
    \x12\x04\x93\x01\x0b\x1c\n\x12\n\n\x06\0\x02\x0b\x04\xe7\x07\0\x02\0\x12\
    \x04\x93\x01\x0b\x1c\n\x13\n\x0b\x06\0\x02\x0b\x04\xe7\x07\0\x02\0\x01\
    \x12\x04\x93\x01\x0c\x1b\n\x13\n\t\x06\0\x02\x0b\x04\xe7\x07\0\x08\x12\
    \x06\x93\x01\x1f\x96\x01\x05\nE\n\x04\x06\0\x02\x0c\x12\x06\x9a\x01\x02\
    \xa3\x01\x03\x1a5\x20Lists\x20all\x20the\x20collection\x20IDs\x20underne\
    ath\x20a\x20document.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\x9a\x01\x06\
    \x17\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\x9a\x01\x180\n\r\n\x05\x06\0\
    \x02\x0c\x03\x12\x04\x9a\x01;T\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\x06\x9b\
    \x01\x04\xa2\x01\x06\n\x12\n\x08\x06\0\x02\x0c\x04\xe7\x07\0\x12\x06\x9b\
    \x01\x04\xa2\x01\x06\n\x11\n\t\x06\0\x02\x0c\x04\xe7\x07\0\x02\x12\x04\
    \x9b\x01\x0b\x1c\n\x12\n\n\x06\0\x02\x0c\x04\xe7\x07\0\x02\0\x12\x04\x9b\
    \x01\x0b\x1c\n\x13\n\x0b\x06\0\x02\x0c\x04\xe7\x07\0\x02\0\x01\x12\x04\
    \x9b\x01\x0c\x1b\n\x13\n\t\x06\0\x02\x0c\x04\xe7\x07\0\x08\x12\x06\x9b\
    \x01\x1f\xa2\x01\x05\nh\n\x02\x04\0\x12\x06\xa7\x01\0\xbc\x01\x01\x1aZ\
    \x20The\x20request\x20for\x20[Firestore.GetDocument][google.firestore.v1\
    beta1.Firestore.GetDocument].\n\n\x0b\n\x03\x04\0\x01\x12\x04\xa7\x01\
    \x08\x1a\n\x95\x01\n\x04\x04\0\x02\0\x12\x04\xaa\x01\x02\x12\x1a\x86\x01\
    \x20The\x20resource\x20name\x20of\x20the\x20Document\x20to\x20get.\x20In\
    \x20the\x20format:\n\x20`projects/{project_id}/databases/{database_id}/d\
    ocuments/{document_path}`.\n\n\x0f\n\x05\x04\0\x02\0\x04\x12\x06\xaa\x01\
    \x02\xa7\x01\x1c\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xaa\x01\x02\x08\n\r\n\
    \x05\x04\0\x02\0\x01\x12\x04\xaa\x01\t\r\n\r\n\x05\x04\0\x02\0\x03\x12\
    \x04\xaa\x01\x10\x11\n\xb8\x01\n\x04\x04\0\x02\x01\x12\x04\xb0\x01\x02\
    \x18\x1a\xa9\x01\x20The\x20fields\x20to\x20return.\x20If\x20not\x20set,\
    \x20returns\x20all\x20fields.\n\n\x20If\x20the\x20document\x20has\x20a\
    \x20field\x20that\x20is\x20not\x20present\x20in\x20this\x20mask,\x20that\
    \x20field\n\x20will\x20not\x20be\x20returned\x20in\x20the\x20response.\n\
    \n\x0f\n\x05\x04\0\x02\x01\x04\x12\x06\xb0\x01\x02\xaa\x01\x12\n\r\n\x05\
    \x04\0\x02\x01\x06\x12\x04\xb0\x01\x02\x0e\n\r\n\x05\x04\0\x02\x01\x01\
    \x12\x04\xb0\x01\x0f\x13\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xb0\x01\x16\
    \x17\ni\n\x04\x04\0\x08\0\x12\x06\xb4\x01\x02\xbb\x01\x03\x1aY\x20The\
    \x20consistency\x20mode\x20for\x20this\x20transaction.\n\x20If\x20not\
    \x20set,\x20defaults\x20to\x20strong\x20consistency.\n\n\r\n\x05\x04\0\
    \x08\0\x01\x12\x04\xb4\x01\x08\x1c\n4\n\x04\x04\0\x02\x02\x12\x04\xb6\
    \x01\x04\x1a\x1a&\x20Reads\x20the\x20document\x20in\x20a\x20transaction.\
    \n\n\r\n\x05\x04\0\x02\x02\x05\x12\x04\xb6\x01\x04\t\n\r\n\x05\x04\0\x02\
    \x02\x01\x12\x04\xb6\x01\n\x15\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xb6\
    \x01\x18\x19\nl\n\x04\x04\0\x02\x03\x12\x04\xba\x01\x04,\x1a^\x20Reads\
    \x20the\x20version\x20of\x20the\x20document\x20at\x20the\x20given\x20tim\
    e.\n\x20This\x20may\x20not\x20be\x20older\x20than\x2060\x20seconds.\n\n\
    \r\n\x05\x04\0\x02\x03\x06\x12\x04\xba\x01\x04\x1d\n\r\n\x05\x04\0\x02\
    \x03\x01\x12\x04\xba\x01\x1e'\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xba\
    \x01*+\nl\n\x02\x04\x01\x12\x06\xbf\x01\0\xee\x01\x01\x1a^\x20The\x20req\
    uest\x20for\x20[Firestore.ListDocuments][google.firestore.v1beta1.Firest\
    ore.ListDocuments].\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xbf\x01\x08\x1c\n\
    \xd8\x02\n\x04\x04\x01\x02\0\x12\x04\xc6\x01\x02\x14\x1a\xc9\x02\x20The\
    \x20parent\x20resource\x20name.\x20In\x20the\x20format:\n\x20`projects/{\
    project_id}/databases/{database_id}/documents`\x20or\n\x20`projects/{pro\
    ject_id}/databases/{database_id}/documents/{document_path}`.\n\x20For\
    \x20example:\n\x20`projects/my-project/databases/my-database/documents`\
    \x20or\n\x20`projects/my-project/databases/my-database/documents/chatroo\
    ms/my-chatroom`\n\n\x0f\n\x05\x04\x01\x02\0\x04\x12\x06\xc6\x01\x02\xbf\
    \x01\x1e\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xc6\x01\x02\x08\n\r\n\x05\
    \x04\x01\x02\0\x01\x12\x04\xc6\x01\t\x0f\n\r\n\x05\x04\x01\x02\0\x03\x12\
    \x04\xc6\x01\x12\x13\nj\n\x04\x04\x01\x02\x01\x12\x04\xca\x01\x02\x1b\
    \x1a\\\x20The\x20collection\x20ID,\x20relative\x20to\x20`parent`,\x20to\
    \x20list.\x20For\x20example:\x20`chatrooms`\n\x20or\x20`messages`.\n\n\
    \x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\xca\x01\x02\xc6\x01\x14\n\r\n\x05\
    \x04\x01\x02\x01\x05\x12\x04\xca\x01\x02\x08\n\r\n\x05\x04\x01\x02\x01\
    \x01\x12\x04\xca\x01\t\x16\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xca\x01\
    \x19\x1a\n:\n\x04\x04\x01\x02\x02\x12\x04\xcd\x01\x02\x16\x1a,\x20The\
    \x20maximum\x20number\x20of\x20documents\x20to\x20return.\n\n\x0f\n\x05\
    \x04\x01\x02\x02\x04\x12\x06\xcd\x01\x02\xca\x01\x1b\n\r\n\x05\x04\x01\
    \x02\x02\x05\x12\x04\xcd\x01\x02\x07\n\r\n\x05\x04\x01\x02\x02\x01\x12\
    \x04\xcd\x01\x08\x11\n\r\n\x05\x04\x01\x02\x02\x03\x12\x04\xcd\x01\x14\
    \x15\nZ\n\x04\x04\x01\x02\x03\x12\x04\xd0\x01\x02\x18\x1aL\x20The\x20`ne\
    xt_page_token`\x20value\x20returned\x20from\x20a\x20previous\x20List\x20\
    request,\x20if\x20any.\n\n\x0f\n\x05\x04\x01\x02\x03\x04\x12\x06\xd0\x01\
    \x02\xcd\x01\x16\n\r\n\x05\x04\x01\x02\x03\x05\x12\x04\xd0\x01\x02\x08\n\
    \r\n\x05\x04\x01\x02\x03\x01\x12\x04\xd0\x01\t\x13\n\r\n\x05\x04\x01\x02\
    \x03\x03\x12\x04\xd0\x01\x16\x17\nQ\n\x04\x04\x01\x02\x04\x12\x04\xd3\
    \x01\x02\x16\x1aC\x20The\x20order\x20to\x20sort\x20results\x20by.\x20For\
    \x20example:\x20`priority\x20desc,\x20name`.\n\n\x0f\n\x05\x04\x01\x02\
    \x04\x04\x12\x06\xd3\x01\x02\xd0\x01\x18\n\r\n\x05\x04\x01\x02\x04\x05\
    \x12\x04\xd3\x01\x02\x08\n\r\n\x05\x04\x01\x02\x04\x01\x12\x04\xd3\x01\t\
    \x11\n\r\n\x05\x04\x01\x02\x04\x03\x12\x04\xd3\x01\x14\x15\n\xb6\x01\n\
    \x04\x04\x01\x02\x05\x12\x04\xd9\x01\x02\x18\x1a\xa7\x01\x20The\x20field\
    s\x20to\x20return.\x20If\x20not\x20set,\x20returns\x20all\x20fields.\n\n\
    \x20If\x20a\x20document\x20has\x20a\x20field\x20that\x20is\x20not\x20pre\
    sent\x20in\x20this\x20mask,\x20that\x20field\n\x20will\x20not\x20be\x20r\
    eturned\x20in\x20the\x20response.\n\n\x0f\n\x05\x04\x01\x02\x05\x04\x12\
    \x06\xd9\x01\x02\xd3\x01\x16\n\r\n\x05\x04\x01\x02\x05\x06\x12\x04\xd9\
    \x01\x02\x0e\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\xd9\x01\x0f\x13\n\r\n\
    \x05\x04\x01\x02\x05\x03\x12\x04\xd9\x01\x16\x17\ni\n\x04\x04\x01\x08\0\
    \x12\x06\xdd\x01\x02\xe4\x01\x03\x1aY\x20The\x20consistency\x20mode\x20f\
    or\x20this\x20transaction.\n\x20If\x20not\x20set,\x20defaults\x20to\x20s\
    trong\x20consistency.\n\n\r\n\x05\x04\x01\x08\0\x01\x12\x04\xdd\x01\x08\
    \x1c\n1\n\x04\x04\x01\x02\x06\x12\x04\xdf\x01\x04\x1a\x1a#\x20Reads\x20d\
    ocuments\x20in\x20a\x20transaction.\n\n\r\n\x05\x04\x01\x02\x06\x05\x12\
    \x04\xdf\x01\x04\t\n\r\n\x05\x04\x01\x02\x06\x01\x12\x04\xdf\x01\n\x15\n\
    \r\n\x05\x04\x01\x02\x06\x03\x12\x04\xdf\x01\x18\x19\ng\n\x04\x04\x01\
    \x02\x07\x12\x04\xe3\x01\x04-\x1aY\x20Reads\x20documents\x20as\x20they\
    \x20were\x20at\x20the\x20given\x20time.\n\x20This\x20may\x20not\x20be\
    \x20older\x20than\x2060\x20seconds.\n\n\r\n\x05\x04\x01\x02\x07\x06\x12\
    \x04\xe3\x01\x04\x1d\n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\xe3\x01\x1e'\
    \n\r\n\x05\x04\x01\x02\x07\x03\x12\x04\xe3\x01*,\n\xac\x03\n\x04\x04\x01\
    \x02\x08\x12\x04\xed\x01\x02\x19\x1a\x9d\x03\x20If\x20the\x20list\x20sho\
    uld\x20show\x20missing\x20documents.\x20A\x20missing\x20document\x20is\
    \x20a\n\x20document\x20that\x20does\x20not\x20exist\x20but\x20has\x20sub\
    -documents.\x20These\x20documents\x20will\n\x20be\x20returned\x20with\
    \x20a\x20key\x20but\x20will\x20not\x20have\x20fields,\x20[Document.creat\
    e_time][google.firestore.v1beta1.Document.create_time],\n\x20or\x20[Docu\
    ment.update_time][google.firestore.v1beta1.Document.update_time]\x20set.\
    \n\n\x20Requests\x20with\x20`show_missing`\x20may\x20not\x20specify\x20`\
    where`\x20or\n\x20`order_by`.\n\n\x0f\n\x05\x04\x01\x02\x08\x04\x12\x06\
    \xed\x01\x02\xe4\x01\x03\n\r\n\x05\x04\x01\x02\x08\x05\x12\x04\xed\x01\
    \x02\x06\n\r\n\x05\x04\x01\x02\x08\x01\x12\x04\xed\x01\x07\x13\n\r\n\x05\
    \x04\x01\x02\x08\x03\x12\x04\xed\x01\x16\x18\nm\n\x02\x04\x02\x12\x06\
    \xf1\x01\0\xf7\x01\x01\x1a_\x20The\x20response\x20for\x20[Firestore.List\
    Documents][google.firestore.v1beta1.Firestore.ListDocuments].\n\n\x0b\n\
    \x03\x04\x02\x01\x12\x04\xf1\x01\x08\x1d\n$\n\x04\x04\x02\x02\0\x12\x04\
    \xf3\x01\x02\"\x1a\x16\x20The\x20Documents\x20found.\n\n\r\n\x05\x04\x02\
    \x02\0\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\x02\x02\0\x06\x12\x04\xf3\
    \x01\x0b\x13\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xf3\x01\x14\x1d\n\r\n\
    \x05\x04\x02\x02\0\x03\x12\x04\xf3\x01\x20!\n$\n\x04\x04\x02\x02\x01\x12\
    \x04\xf6\x01\x02\x1d\x1a\x16\x20The\x20next\x20page\x20token.\n\n\x0f\n\
    \x05\x04\x02\x02\x01\x04\x12\x06\xf6\x01\x02\xf3\x01\"\n\r\n\x05\x04\x02\
    \x02\x01\x05\x12\x04\xf6\x01\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\
    \x04\xf6\x01\t\x18\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xf6\x01\x1b\x1c\
    \nn\n\x02\x04\x03\x12\x06\xfa\x01\0\x90\x02\x01\x1a`\x20The\x20request\
    \x20for\x20[Firestore.CreateDocument][google.firestore.v1beta1.Firestore\
    .CreateDocument].\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xfa\x01\x08\x1d\n\
    \xc3\x01\n\x04\x04\x03\x02\0\x12\x04\xfe\x01\x02\x14\x1a\xb4\x01\x20The\
    \x20parent\x20resource.\x20For\x20example:\n\x20`projects/{project_id}/d\
    atabases/{database_id}/documents`\x20or\n\x20`projects/{project_id}/data\
    bases/{database_id}/documents/chatrooms/{chatroom_id}`\n\n\x0f\n\x05\x04\
    \x03\x02\0\x04\x12\x06\xfe\x01\x02\xfa\x01\x1f\n\r\n\x05\x04\x03\x02\0\
    \x05\x12\x04\xfe\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xfe\x01\
    \t\x0f\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\xfe\x01\x12\x13\n[\n\x04\x04\
    \x03\x02\x01\x12\x04\x81\x02\x02\x1b\x1aM\x20The\x20collection\x20ID,\
    \x20relative\x20to\x20`parent`,\x20to\x20list.\x20For\x20example:\x20`ch\
    atrooms`.\n\n\x0f\n\x05\x04\x03\x02\x01\x04\x12\x06\x81\x02\x02\xfe\x01\
    \x14\n\r\n\x05\x04\x03\x02\x01\x05\x12\x04\x81\x02\x02\x08\n\r\n\x05\x04\
    \x03\x02\x01\x01\x12\x04\x81\x02\t\x16\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\x81\x02\x19\x1a\n\x8f\x01\n\x04\x04\x03\x02\x02\x12\x04\x86\x02\x02\
    \x19\x1a\x80\x01\x20The\x20client-assigned\x20document\x20ID\x20to\x20us\
    e\x20for\x20this\x20document.\n\n\x20Optional.\x20If\x20not\x20specified\
    ,\x20an\x20ID\x20will\x20be\x20assigned\x20by\x20the\x20service.\n\n\x0f\
    \n\x05\x04\x03\x02\x02\x04\x12\x06\x86\x02\x02\x81\x02\x1b\n\r\n\x05\x04\
    \x03\x02\x02\x05\x12\x04\x86\x02\x02\x08\n\r\n\x05\x04\x03\x02\x02\x01\
    \x12\x04\x86\x02\t\x14\n\r\n\x05\x04\x03\x02\x02\x03\x12\x04\x86\x02\x17\
    \x18\n?\n\x04\x04\x03\x02\x03\x12\x04\x89\x02\x02\x18\x1a1\x20The\x20doc\
    ument\x20to\x20create.\x20`name`\x20must\x20not\x20be\x20set.\n\n\x0f\n\
    \x05\x04\x03\x02\x03\x04\x12\x06\x89\x02\x02\x86\x02\x19\n\r\n\x05\x04\
    \x03\x02\x03\x06\x12\x04\x89\x02\x02\n\n\r\n\x05\x04\x03\x02\x03\x01\x12\
    \x04\x89\x02\x0b\x13\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\x89\x02\x16\
    \x17\n\xb8\x01\n\x04\x04\x03\x02\x04\x12\x04\x8f\x02\x02\x18\x1a\xa9\x01\
    \x20The\x20fields\x20to\x20return.\x20If\x20not\x20set,\x20returns\x20al\
    l\x20fields.\n\n\x20If\x20the\x20document\x20has\x20a\x20field\x20that\
    \x20is\x20not\x20present\x20in\x20this\x20mask,\x20that\x20field\n\x20wi\
    ll\x20not\x20be\x20returned\x20in\x20the\x20response.\n\n\x0f\n\x05\x04\
    \x03\x02\x04\x04\x12\x06\x8f\x02\x02\x89\x02\x18\n\r\n\x05\x04\x03\x02\
    \x04\x06\x12\x04\x8f\x02\x02\x0e\n\r\n\x05\x04\x03\x02\x04\x01\x12\x04\
    \x8f\x02\x0f\x13\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\x8f\x02\x16\x17\n\
    n\n\x02\x04\x04\x12\x06\x93\x02\0\xaa\x02\x01\x1a`\x20The\x20request\x20\
    for\x20[Firestore.UpdateDocument][google.firestore.v1beta1.Firestore.Upd\
    ateDocument].\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x93\x02\x08\x1d\nY\n\x04\
    \x04\x04\x02\0\x12\x04\x96\x02\x02\x18\x1aK\x20The\x20updated\x20documen\
    t.\n\x20Creates\x20the\x20document\x20if\x20it\x20does\x20not\x20already\
    \x20exist.\n\n\x0f\n\x05\x04\x04\x02\0\x04\x12\x06\x96\x02\x02\x93\x02\
    \x1f\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x96\x02\x02\n\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\x96\x02\x0b\x13\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x96\x02\x16\x17\n\xc9\x02\n\x04\x04\x04\x02\x01\x12\x04\x9f\x02\x02\x1f\
    \x1a\xba\x02\x20The\x20fields\x20to\x20update.\n\x20None\x20of\x20the\
    \x20field\x20paths\x20in\x20the\x20mask\x20may\x20contain\x20a\x20reserv\
    ed\x20name.\n\n\x20If\x20the\x20document\x20exists\x20on\x20the\x20serve\
    r\x20and\x20has\x20fields\x20not\x20referenced\x20in\x20the\n\x20mask,\
    \x20they\x20are\x20left\x20unchanged.\n\x20Fields\x20referenced\x20in\
    \x20the\x20mask,\x20but\x20not\x20present\x20in\x20the\x20input\x20docum\
    ent,\x20are\n\x20deleted\x20from\x20the\x20document\x20on\x20the\x20serv\
    er.\n\n\x0f\n\x05\x04\x04\x02\x01\x04\x12\x06\x9f\x02\x02\x96\x02\x18\n\
    \r\n\x05\x04\x04\x02\x01\x06\x12\x04\x9f\x02\x02\x0e\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\x9f\x02\x0f\x1a\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\x9f\x02\x1d\x1e\n\xb8\x01\n\x04\x04\x04\x02\x02\x12\x04\xa5\x02\x02\
    \x18\x1a\xa9\x01\x20The\x20fields\x20to\x20return.\x20If\x20not\x20set,\
    \x20returns\x20all\x20fields.\n\n\x20If\x20the\x20document\x20has\x20a\
    \x20field\x20that\x20is\x20not\x20present\x20in\x20this\x20mask,\x20that\
    \x20field\n\x20will\x20not\x20be\x20returned\x20in\x20the\x20response.\n\
    \n\x0f\n\x05\x04\x04\x02\x02\x04\x12\x06\xa5\x02\x02\x9f\x02\x1f\n\r\n\
    \x05\x04\x04\x02\x02\x06\x12\x04\xa5\x02\x02\x0e\n\r\n\x05\x04\x04\x02\
    \x02\x01\x12\x04\xa5\x02\x0f\x13\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\
    \xa5\x02\x16\x17\n\x83\x01\n\x04\x04\x04\x02\x03\x12\x04\xa9\x02\x02$\
    \x1au\x20An\x20optional\x20precondition\x20on\x20the\x20document.\n\x20T\
    he\x20request\x20will\x20fail\x20if\x20this\x20is\x20set\x20and\x20not\
    \x20met\x20by\x20the\x20target\x20document.\n\n\x0f\n\x05\x04\x04\x02\
    \x03\x04\x12\x06\xa9\x02\x02\xa5\x02\x18\n\r\n\x05\x04\x04\x02\x03\x06\
    \x12\x04\xa9\x02\x02\x0e\n\r\n\x05\x04\x04\x02\x03\x01\x12\x04\xa9\x02\
    \x0f\x1f\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xa9\x02\"#\nn\n\x02\x04\
    \x05\x12\x06\xad\x02\0\xb5\x02\x01\x1a`\x20The\x20request\x20for\x20[Fir\
    estore.DeleteDocument][google.firestore.v1beta1.Firestore.DeleteDocument\
    ].\n\n\x0b\n\x03\x04\x05\x01\x12\x04\xad\x02\x08\x1d\n\x98\x01\n\x04\x04\
    \x05\x02\0\x12\x04\xb0\x02\x02\x12\x1a\x89\x01\x20The\x20resource\x20nam\
    e\x20of\x20the\x20Document\x20to\x20delete.\x20In\x20the\x20format:\n\
    \x20`projects/{project_id}/databases/{database_id}/documents/{document_p\
    ath}`.\n\n\x0f\n\x05\x04\x05\x02\0\x04\x12\x06\xb0\x02\x02\xad\x02\x1f\n\
    \r\n\x05\x04\x05\x02\0\x05\x12\x04\xb0\x02\x02\x08\n\r\n\x05\x04\x05\x02\
    \0\x01\x12\x04\xb0\x02\t\r\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xb0\x02\
    \x10\x11\n\x83\x01\n\x04\x04\x05\x02\x01\x12\x04\xb4\x02\x02$\x1au\x20An\
    \x20optional\x20precondition\x20on\x20the\x20document.\n\x20The\x20reque\
    st\x20will\x20fail\x20if\x20this\x20is\x20set\x20and\x20not\x20met\x20by\
    \x20the\x20target\x20document.\n\n\x0f\n\x05\x04\x05\x02\x01\x04\x12\x06\
    \xb4\x02\x02\xb0\x02\x12\n\r\n\x05\x04\x05\x02\x01\x06\x12\x04\xb4\x02\
    \x02\x0e\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xb4\x02\x0f\x1f\n\r\n\x05\
    \x04\x05\x02\x01\x03\x12\x04\xb4\x02\"#\nt\n\x02\x04\x06\x12\x06\xb8\x02\
    \0\xd9\x02\x01\x1af\x20The\x20request\x20for\x20[Firestore.BatchGetDocum\
    ents][google.firestore.v1beta1.Firestore.BatchGetDocuments].\n\n\x0b\n\
    \x03\x04\x06\x01\x12\x04\xb8\x02\x08\x20\nc\n\x04\x04\x06\x02\0\x12\x04\
    \xbb\x02\x02\x16\x1aU\x20The\x20database\x20name.\x20In\x20the\x20format\
    :\n\x20`projects/{project_id}/databases/{database_id}`.\n\n\x0f\n\x05\
    \x04\x06\x02\0\x04\x12\x06\xbb\x02\x02\xb8\x02\"\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\xbb\x02\x02\x08\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xbb\x02\
    \t\x11\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xbb\x02\x14\x15\n\x93\x02\n\
    \x04\x04\x06\x02\x01\x12\x04\xc1\x02\x02\x20\x1a\x84\x02\x20The\x20names\
    \x20of\x20the\x20documents\x20to\x20retrieve.\x20In\x20the\x20format:\n\
    \x20`projects/{project_id}/databases/{database_id}/documents/{document_p\
    ath}`.\n\x20The\x20request\x20will\x20fail\x20if\x20any\x20of\x20the\x20\
    document\x20is\x20not\x20a\x20child\x20resource\x20of\x20the\n\x20given\
    \x20`database`.\x20Duplicate\x20names\x20will\x20be\x20elided.\n\n\r\n\
    \x05\x04\x06\x02\x01\x04\x12\x04\xc1\x02\x02\n\n\r\n\x05\x04\x06\x02\x01\
    \x05\x12\x04\xc1\x02\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xc1\
    \x02\x12\x1b\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xc1\x02\x1e\x1f\n\xb6\
    \x01\n\x04\x04\x06\x02\x02\x12\x04\xc7\x02\x02\x18\x1a\xa7\x01\x20The\
    \x20fields\x20to\x20return.\x20If\x20not\x20set,\x20returns\x20all\x20fi\
    elds.\n\n\x20If\x20a\x20document\x20has\x20a\x20field\x20that\x20is\x20n\
    ot\x20present\x20in\x20this\x20mask,\x20that\x20field\x20will\n\x20not\
    \x20be\x20returned\x20in\x20the\x20response.\n\n\x0f\n\x05\x04\x06\x02\
    \x02\x04\x12\x06\xc7\x02\x02\xc1\x02\x20\n\r\n\x05\x04\x06\x02\x02\x06\
    \x12\x04\xc7\x02\x02\x0e\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xc7\x02\
    \x0f\x13\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xc7\x02\x16\x17\ni\n\x04\
    \x04\x06\x08\0\x12\x06\xcb\x02\x02\xd8\x02\x03\x1aY\x20The\x20consistenc\
    y\x20mode\x20for\x20this\x20transaction.\n\x20If\x20not\x20set,\x20defau\
    lts\x20to\x20strong\x20consistency.\n\n\r\n\x05\x04\x06\x08\0\x01\x12\
    \x04\xcb\x02\x08\x1c\n1\n\x04\x04\x06\x02\x03\x12\x04\xcd\x02\x04\x1a\
    \x1a#\x20Reads\x20documents\x20in\x20a\x20transaction.\n\n\r\n\x05\x04\
    \x06\x02\x03\x05\x12\x04\xcd\x02\x04\t\n\r\n\x05\x04\x06\x02\x03\x01\x12\
    \x04\xcd\x02\n\x15\n\r\n\x05\x04\x06\x02\x03\x03\x12\x04\xcd\x02\x18\x19\
    \n\xb7\x01\n\x04\x04\x06\x02\x04\x12\x04\xd3\x02\x04+\x1a\xa8\x01\x20Sta\
    rts\x20a\x20new\x20transaction\x20and\x20reads\x20the\x20documents.\n\
    \x20Defaults\x20to\x20a\x20read-only\x20transaction.\n\x20The\x20new\x20\
    transaction\x20ID\x20will\x20be\x20returned\x20as\x20the\x20first\x20res\
    ponse\x20in\x20the\n\x20stream.\n\n\r\n\x05\x04\x06\x02\x04\x06\x12\x04\
    \xd3\x02\x04\x16\n\r\n\x05\x04\x06\x02\x04\x01\x12\x04\xd3\x02\x17&\n\r\
    \n\x05\x04\x06\x02\x04\x03\x12\x04\xd3\x02)*\ng\n\x04\x04\x06\x02\x05\
    \x12\x04\xd7\x02\x04,\x1aY\x20Reads\x20documents\x20as\x20they\x20were\
    \x20at\x20the\x20given\x20time.\n\x20This\x20may\x20not\x20be\x20older\
    \x20than\x2060\x20seconds.\n\n\r\n\x05\x04\x06\x02\x05\x06\x12\x04\xd7\
    \x02\x04\x1d\n\r\n\x05\x04\x06\x02\x05\x01\x12\x04\xd7\x02\x1e'\n\r\n\
    \x05\x04\x06\x02\x05\x03\x12\x04\xd7\x02*+\n~\n\x02\x04\x07\x12\x06\xdc\
    \x02\0\xf2\x02\x01\x1ap\x20The\x20streamed\x20response\x20for\x20[Firest\
    ore.BatchGetDocuments][google.firestore.v1beta1.Firestore.BatchGetDocume\
    nts].\n\n\x0b\n\x03\x04\x07\x01\x12\x04\xdc\x02\x08!\nd\n\x04\x04\x07\
    \x08\0\x12\x06\xdf\x02\x02\xe6\x02\x03\x1aT\x20A\x20single\x20result.\n\
    \x20This\x20can\x20be\x20empty\x20if\x20the\x20server\x20is\x20just\x20r\
    eturning\x20a\x20transaction.\n\n\r\n\x05\x04\x07\x08\0\x01\x12\x04\xdf\
    \x02\x08\x0e\n.\n\x04\x04\x07\x02\0\x12\x04\xe1\x02\x04\x17\x1a\x20\x20A\
    \x20document\x20that\x20was\x20requested.\n\n\r\n\x05\x04\x07\x02\0\x06\
    \x12\x04\xe1\x02\x04\x0c\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe1\x02\r\
    \x12\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe1\x02\x15\x16\n\xa2\x01\n\x04\
    \x04\x07\x02\x01\x12\x04\xe5\x02\x04\x17\x1a\x93\x01\x20A\x20document\
    \x20name\x20that\x20was\x20requested\x20but\x20does\x20not\x20exist.\x20\
    In\x20the\x20format:\n\x20`projects/{project_id}/databases/{database_id}\
    /documents/{document_path}`.\n\n\r\n\x05\x04\x07\x02\x01\x05\x12\x04\xe5\
    \x02\x04\n\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xe5\x02\x0b\x12\n\r\n\
    \x05\x04\x07\x02\x01\x03\x12\x04\xe5\x02\x15\x16\n\x86\x02\n\x04\x04\x07\
    \x02\x02\x12\x04\xeb\x02\x02\x18\x1a\xf7\x01\x20The\x20transaction\x20th\
    at\x20was\x20started\x20as\x20part\x20of\x20this\x20request.\n\x20Will\
    \x20only\x20be\x20set\x20in\x20the\x20first\x20response,\x20and\x20only\
    \x20if\n\x20[BatchGetDocumentsRequest.new_transaction][google.firestore.\
    v1beta1.BatchGetDocumentsRequest.new_transaction]\x20was\x20set\x20in\
    \x20the\x20request.\n\n\x0f\n\x05\x04\x07\x02\x02\x04\x12\x06\xeb\x02\
    \x02\xe6\x02\x03\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xeb\x02\x02\x07\n\
    \r\n\x05\x04\x07\x02\x02\x01\x12\x04\xeb\x02\x08\x13\n\r\n\x05\x04\x07\
    \x02\x02\x03\x12\x04\xeb\x02\x16\x17\n\xe2\x01\n\x04\x04\x07\x02\x03\x12\
    \x04\xf1\x02\x02*\x1a\xd3\x01\x20The\x20time\x20at\x20which\x20the\x20do\
    cument\x20was\x20read.\n\x20This\x20may\x20be\x20monotically\x20increasi\
    ng,\x20in\x20this\x20case\x20the\x20previous\x20documents\x20in\n\x20the\
    \x20result\x20stream\x20are\x20guaranteed\x20not\x20to\x20have\x20change\
    d\x20between\x20their\n\x20read_time\x20and\x20this\x20one.\n\n\x0f\n\
    \x05\x04\x07\x02\x03\x04\x12\x06\xf1\x02\x02\xeb\x02\x18\n\r\n\x05\x04\
    \x07\x02\x03\x06\x12\x04\xf1\x02\x02\x1b\n\r\n\x05\x04\x07\x02\x03\x01\
    \x12\x04\xf1\x02\x1c%\n\r\n\x05\x04\x07\x02\x03\x03\x12\x04\xf1\x02()\nr\
    \n\x02\x04\x08\x12\x06\xf5\x02\0\xfd\x02\x01\x1ad\x20The\x20request\x20f\
    or\x20[Firestore.BeginTransaction][google.firestore.v1beta1.Firestore.Be\
    ginTransaction].\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xf5\x02\x08\x1f\nc\n\
    \x04\x04\x08\x02\0\x12\x04\xf8\x02\x02\x16\x1aU\x20The\x20database\x20na\
    me.\x20In\x20the\x20format:\n\x20`projects/{project_id}/databases/{datab\
    ase_id}`.\n\n\x0f\n\x05\x04\x08\x02\0\x04\x12\x06\xf8\x02\x02\xf5\x02!\n\
    \r\n\x05\x04\x08\x02\0\x05\x12\x04\xf8\x02\x02\x08\n\r\n\x05\x04\x08\x02\
    \0\x01\x12\x04\xf8\x02\t\x11\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xf8\x02\
    \x14\x15\nW\n\x04\x04\x08\x02\x01\x12\x04\xfc\x02\x02!\x1aI\x20The\x20op\
    tions\x20for\x20the\x20transaction.\n\x20Defaults\x20to\x20a\x20read-wri\
    te\x20transaction.\n\n\x0f\n\x05\x04\x08\x02\x01\x04\x12\x06\xfc\x02\x02\
    \xf8\x02\x16\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\xfc\x02\x02\x14\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\xfc\x02\x15\x1c\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xfc\x02\x1f\x20\ns\n\x02\x04\t\x12\x06\x80\x03\0\x83\
    \x03\x01\x1ae\x20The\x20response\x20for\x20[Firestore.BeginTransaction][\
    google.firestore.v1beta1.Firestore.BeginTransaction].\n\n\x0b\n\x03\x04\
    \t\x01\x12\x04\x80\x03\x08\x20\n1\n\x04\x04\t\x02\0\x12\x04\x82\x03\x02\
    \x18\x1a#\x20The\x20transaction\x20that\x20was\x20started.\n\n\x0f\n\x05\
    \x04\t\x02\0\x04\x12\x06\x82\x03\x02\x80\x03\"\n\r\n\x05\x04\t\x02\0\x05\
    \x12\x04\x82\x03\x02\x07\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x82\x03\x08\
    \x13\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x82\x03\x16\x17\n^\n\x02\x04\n\
    \x12\x06\x86\x03\0\x92\x03\x01\x1aP\x20The\x20request\x20for\x20[Firesto\
    re.Commit][google.firestore.v1beta1.Firestore.Commit].\n\n\x0b\n\x03\x04\
    \n\x01\x12\x04\x86\x03\x08\x15\nc\n\x04\x04\n\x02\0\x12\x04\x89\x03\x02\
    \x16\x1aU\x20The\x20database\x20name.\x20In\x20the\x20format:\n\x20`proj\
    ects/{project_id}/databases/{database_id}`.\n\n\x0f\n\x05\x04\n\x02\0\
    \x04\x12\x06\x89\x03\x02\x86\x03\x17\n\r\n\x05\x04\n\x02\0\x05\x12\x04\
    \x89\x03\x02\x08\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x89\x03\t\x11\n\r\n\
    \x05\x04\n\x02\0\x03\x12\x04\x89\x03\x14\x15\nO\n\x04\x04\n\x02\x01\x12\
    \x04\x8e\x03\x02\x1c\x1aA\x20The\x20writes\x20to\x20apply.\n\n\x20Always\
    \x20executed\x20atomically\x20and\x20in\x20order.\n\n\r\n\x05\x04\n\x02\
    \x01\x04\x12\x04\x8e\x03\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x8e\
    \x03\x0b\x10\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x8e\x03\x11\x17\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\x8e\x03\x1a\x1b\nO\n\x04\x04\n\x02\x02\
    \x12\x04\x91\x03\x02\x18\x1aA\x20If\x20set,\x20applies\x20all\x20writes\
    \x20in\x20this\x20transaction,\x20and\x20commits\x20it.\n\n\x0f\n\x05\
    \x04\n\x02\x02\x04\x12\x06\x91\x03\x02\x8e\x03\x1c\n\r\n\x05\x04\n\x02\
    \x02\x05\x12\x04\x91\x03\x02\x07\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x91\
    \x03\x08\x13\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\x91\x03\x16\x17\n_\n\
    \x02\x04\x0b\x12\x06\x95\x03\0\x9e\x03\x01\x1aQ\x20The\x20response\x20fo\
    r\x20[Firestore.Commit][google.firestore.v1beta1.Firestore.Commit].\n\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\x95\x03\x08\x16\nz\n\x04\x04\x0b\x02\0\
    \x12\x04\x9a\x03\x02)\x1al\x20The\x20result\x20of\x20applying\x20the\x20\
    writes.\n\n\x20This\x20i-th\x20write\x20result\x20corresponds\x20to\x20t\
    he\x20i-th\x20write\x20in\x20the\n\x20request.\n\n\r\n\x05\x04\x0b\x02\0\
    \x04\x12\x04\x9a\x03\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\x9a\x03\
    \x0b\x16\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x9a\x03\x17$\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\x9a\x03'(\n6\n\x04\x04\x0b\x02\x01\x12\x04\x9d\
    \x03\x02,\x1a(\x20The\x20time\x20at\x20which\x20the\x20commit\x20occurre\
    d.\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\x06\x9d\x03\x02\x9a\x03)\n\r\n\
    \x05\x04\x0b\x02\x01\x06\x12\x04\x9d\x03\x02\x1b\n\r\n\x05\x04\x0b\x02\
    \x01\x01\x12\x04\x9d\x03\x1c'\n\r\n\x05\x04\x0b\x02\x01\x03\x12\x04\x9d\
    \x03*+\nb\n\x02\x04\x0c\x12\x06\xa1\x03\0\xa8\x03\x01\x1aT\x20The\x20req\
    uest\x20for\x20[Firestore.Rollback][google.firestore.v1beta1.Firestore.R\
    ollback].\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xa1\x03\x08\x17\nc\n\x04\x04\
    \x0c\x02\0\x12\x04\xa4\x03\x02\x16\x1aU\x20The\x20database\x20name.\x20I\
    n\x20the\x20format:\n\x20`projects/{project_id}/databases/{database_id}`\
    .\n\n\x0f\n\x05\x04\x0c\x02\0\x04\x12\x06\xa4\x03\x02\xa1\x03\x19\n\r\n\
    \x05\x04\x0c\x02\0\x05\x12\x04\xa4\x03\x02\x08\n\r\n\x05\x04\x0c\x02\0\
    \x01\x12\x04\xa4\x03\t\x11\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xa4\x03\
    \x14\x15\n-\n\x04\x04\x0c\x02\x01\x12\x04\xa7\x03\x02\x18\x1a\x1f\x20The\
    \x20transaction\x20to\x20roll\x20back.\n\n\x0f\n\x05\x04\x0c\x02\x01\x04\
    \x12\x06\xa7\x03\x02\xa4\x03\x16\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\
    \xa7\x03\x02\x07\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa7\x03\x08\x13\n\
    \r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xa7\x03\x16\x17\nb\n\x02\x04\r\x12\
    \x06\xab\x03\0\xca\x03\x01\x1aT\x20The\x20request\x20for\x20[Firestore.R\
    unQuery][google.firestore.v1beta1.Firestore.RunQuery].\n\n\x0b\n\x03\x04\
    \r\x01\x12\x04\xab\x03\x08\x17\n\xd8\x02\n\x04\x04\r\x02\0\x12\x04\xb2\
    \x03\x02\x14\x1a\xc9\x02\x20The\x20parent\x20resource\x20name.\x20In\x20\
    the\x20format:\n\x20`projects/{project_id}/databases/{database_id}/docum\
    ents`\x20or\n\x20`projects/{project_id}/databases/{database_id}/document\
    s/{document_path}`.\n\x20For\x20example:\n\x20`projects/my-project/datab\
    ases/my-database/documents`\x20or\n\x20`projects/my-project/databases/my\
    -database/documents/chatrooms/my-chatroom`\n\n\x0f\n\x05\x04\r\x02\0\x04\
    \x12\x06\xb2\x03\x02\xab\x03\x19\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xb2\
    \x03\x02\x08\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xb2\x03\t\x0f\n\r\n\x05\
    \x04\r\x02\0\x03\x12\x04\xb2\x03\x12\x13\n#\n\x04\x04\r\x08\0\x12\x06\
    \xb5\x03\x02\xb8\x03\x03\x1a\x13\x20The\x20query\x20to\x20run.\n\n\r\n\
    \x05\x04\r\x08\0\x01\x12\x04\xb5\x03\x08\x12\n#\n\x04\x04\r\x02\x01\x12\
    \x04\xb7\x03\x04)\x1a\x15\x20A\x20structured\x20query.\n\n\r\n\x05\x04\r\
    \x02\x01\x06\x12\x04\xb7\x03\x04\x13\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\
    \xb7\x03\x14$\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xb7\x03'(\ni\n\x04\x04\
    \r\x08\x01\x12\x06\xbc\x03\x02\xc9\x03\x03\x1aY\x20The\x20consistency\
    \x20mode\x20for\x20this\x20transaction.\n\x20If\x20not\x20set,\x20defaul\
    ts\x20to\x20strong\x20consistency.\n\n\r\n\x05\x04\r\x08\x01\x01\x12\x04\
    \xbc\x03\x08\x1c\n1\n\x04\x04\r\x02\x02\x12\x04\xbe\x03\x04\x1a\x1a#\x20\
    Reads\x20documents\x20in\x20a\x20transaction.\n\n\r\n\x05\x04\r\x02\x02\
    \x05\x12\x04\xbe\x03\x04\t\n\r\n\x05\x04\r\x02\x02\x01\x12\x04\xbe\x03\n\
    \x15\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xbe\x03\x18\x19\n\xb7\x01\n\x04\
    \x04\r\x02\x03\x12\x04\xc4\x03\x04+\x1a\xa8\x01\x20Starts\x20a\x20new\
    \x20transaction\x20and\x20reads\x20the\x20documents.\n\x20Defaults\x20to\
    \x20a\x20read-only\x20transaction.\n\x20The\x20new\x20transaction\x20ID\
    \x20will\x20be\x20returned\x20as\x20the\x20first\x20response\x20in\x20th\
    e\n\x20stream.\n\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xc4\x03\x04\x16\n\r\
    \n\x05\x04\r\x02\x03\x01\x12\x04\xc4\x03\x17&\n\r\n\x05\x04\r\x02\x03\
    \x03\x12\x04\xc4\x03)*\ng\n\x04\x04\r\x02\x04\x12\x04\xc8\x03\x04,\x1aY\
    \x20Reads\x20documents\x20as\x20they\x20were\x20at\x20the\x20given\x20ti\
    me.\n\x20This\x20may\x20not\x20be\x20older\x20than\x2060\x20seconds.\n\n\
    \r\n\x05\x04\r\x02\x04\x06\x12\x04\xc8\x03\x04\x1d\n\r\n\x05\x04\r\x02\
    \x04\x01\x12\x04\xc8\x03\x1e'\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\xc8\
    \x03*+\nc\n\x02\x04\x0e\x12\x06\xcd\x03\0\xe4\x03\x01\x1aU\x20The\x20res\
    ponse\x20for\x20[Firestore.RunQuery][google.firestore.v1beta1.Firestore.\
    RunQuery].\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xcd\x03\x08\x18\n\xaa\x02\n\
    \x04\x04\x0e\x02\0\x12\x04\xd2\x03\x02\x18\x1a\x9b\x02\x20The\x20transac\
    tion\x20that\x20was\x20started\x20as\x20part\x20of\x20this\x20request.\n\
    \x20Can\x20only\x20be\x20set\x20in\x20the\x20first\x20response,\x20and\
    \x20only\x20if\n\x20[RunQueryRequest.new_transaction][google.firestore.v\
    1beta1.RunQueryRequest.new_transaction]\x20was\x20set\x20in\x20the\x20re\
    quest.\n\x20If\x20set,\x20no\x20other\x20fields\x20will\x20be\x20set\x20\
    in\x20this\x20response.\n\n\x0f\n\x05\x04\x0e\x02\0\x04\x12\x06\xd2\x03\
    \x02\xcd\x03\x1a\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xd2\x03\x02\x07\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xd2\x03\x08\x13\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xd2\x03\x16\x17\nI\n\x04\x04\x0e\x02\x01\x12\x04\xd6\x03\
    \x02\x18\x1a;\x20A\x20query\x20result.\n\x20Not\x20set\x20when\x20report\
    ing\x20partial\x20progress.\n\n\x0f\n\x05\x04\x0e\x02\x01\x04\x12\x06\
    \xd6\x03\x02\xd2\x03\x18\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xd6\x03\
    \x02\n\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xd6\x03\x0b\x13\n\r\n\x05\
    \x04\x0e\x02\x01\x03\x12\x04\xd6\x03\x16\x17\n\x80\x03\n\x04\x04\x0e\x02\
    \x02\x12\x04\xdf\x03\x02*\x1a\xf1\x02\x20The\x20time\x20at\x20which\x20t\
    he\x20document\x20was\x20read.\x20This\x20may\x20be\x20monotonically\n\
    \x20increasing;\x20in\x20this\x20case,\x20the\x20previous\x20documents\
    \x20in\x20the\x20result\x20stream\x20are\n\x20guaranteed\x20not\x20to\
    \x20have\x20changed\x20between\x20their\x20`read_time`\x20and\x20this\
    \x20one.\n\n\x20If\x20the\x20query\x20returns\x20no\x20results,\x20a\x20\
    response\x20with\x20`read_time`\x20and\x20no\n\x20`document`\x20will\x20\
    be\x20sent,\x20and\x20this\x20represents\x20the\x20time\x20at\x20which\
    \x20the\x20query\n\x20was\x20run.\n\n\x0f\n\x05\x04\x0e\x02\x02\x04\x12\
    \x06\xdf\x03\x02\xd6\x03\x18\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\xdf\
    \x03\x02\x1b\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xdf\x03\x1c%\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\xdf\x03()\n\x82\x01\n\x04\x04\x0e\x02\
    \x03\x12\x04\xe3\x03\x02\x1c\x1at\x20The\x20number\x20of\x20results\x20t\
    hat\x20have\x20been\x20skipped\x20due\x20to\x20an\x20offset\x20between\n\
    \x20the\x20last\x20response\x20and\x20the\x20current\x20response.\n\n\
    \x0f\n\x05\x04\x0e\x02\x03\x04\x12\x06\xe3\x03\x02\xdf\x03*\n\r\n\x05\
    \x04\x0e\x02\x03\x05\x12\x04\xe3\x03\x02\x07\n\r\n\x05\x04\x0e\x02\x03\
    \x01\x12\x04\xe3\x03\x08\x17\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\xe3\
    \x03\x1a\x1b\n\xdd\x03\n\x02\x04\x0f\x12\x06\xf0\x03\0\x95\x04\x01\x1a\
    \xce\x03\x20The\x20request\x20for\x20[Firestore.Write][google.firestore.\
    v1beta1.Firestore.Write].\n\n\x20The\x20first\x20request\x20creates\x20a\
    \x20stream,\x20or\x20resumes\x20an\x20existing\x20one\x20from\x20a\x20to\
    ken.\n\n\x20When\x20creating\x20a\x20new\x20stream,\x20the\x20server\x20\
    replies\x20with\x20a\x20response\x20containing\n\x20only\x20an\x20ID\x20\
    and\x20a\x20token,\x20to\x20use\x20in\x20the\x20next\x20request.\n\n\x20\
    When\x20resuming\x20a\x20stream,\x20the\x20server\x20first\x20streams\
    \x20any\x20responses\x20later\x20than\x20the\n\x20given\x20token,\x20the\
    n\x20a\x20response\x20containing\x20only\x20an\x20up-to-date\x20token,\
    \x20to\x20use\x20in\n\x20the\x20next\x20request.\n\n\x0b\n\x03\x04\x0f\
    \x01\x12\x04\xf0\x03\x08\x14\n\x91\x01\n\x04\x04\x0f\x02\0\x12\x04\xf4\
    \x03\x02\x16\x1a\x82\x01\x20The\x20database\x20name.\x20In\x20the\x20for\
    mat:\n\x20`projects/{project_id}/databases/{database_id}`.\n\x20This\x20\
    is\x20only\x20required\x20in\x20the\x20first\x20message.\n\n\x0f\n\x05\
    \x04\x0f\x02\0\x04\x12\x06\xf4\x03\x02\xf0\x03\x16\n\r\n\x05\x04\x0f\x02\
    \0\x05\x12\x04\xf4\x03\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xf4\
    \x03\t\x11\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xf4\x03\x14\x15\n\x98\x01\
    \n\x04\x04\x0f\x02\x01\x12\x04\xf9\x03\x02\x17\x1a\x89\x01\x20The\x20ID\
    \x20of\x20the\x20write\x20stream\x20to\x20resume.\n\x20This\x20may\x20on\
    ly\x20be\x20set\x20in\x20the\x20first\x20message.\x20When\x20left\x20emp\
    ty,\x20a\x20new\x20write\n\x20stream\x20will\x20be\x20created.\n\n\x0f\n\
    \x05\x04\x0f\x02\x01\x04\x12\x06\xf9\x03\x02\xf4\x03\x16\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xf9\x03\x02\x08\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\xf9\x03\t\x12\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xf9\x03\x15\
    \x16\n\xd1\x01\n\x04\x04\x0f\x02\x02\x12\x04\x81\x04\x02\x1c\x1a\xc2\x01\
    \x20The\x20writes\x20to\x20apply.\n\n\x20Always\x20executed\x20atomicall\
    y\x20and\x20in\x20order.\n\x20This\x20must\x20be\x20empty\x20on\x20the\
    \x20first\x20request.\n\x20This\x20may\x20be\x20empty\x20on\x20the\x20la\
    st\x20request.\n\x20This\x20must\x20not\x20be\x20empty\x20on\x20all\x20o\
    ther\x20requests.\n\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\x81\x04\x02\n\
    \n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\x81\x04\x0b\x10\n\r\n\x05\x04\x0f\
    \x02\x02\x01\x12\x04\x81\x04\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x03\x12\
    \x04\x81\x04\x1a\x1b\n\xf5\x04\n\x04\x04\x0f\x02\x03\x12\x04\x91\x04\x02\
    \x19\x1a\xe6\x04\x20A\x20stream\x20token\x20that\x20was\x20previously\
    \x20sent\x20by\x20the\x20server.\n\n\x20The\x20client\x20should\x20set\
    \x20this\x20field\x20to\x20the\x20token\x20from\x20the\x20most\x20recent\
    \n\x20[WriteResponse][google.firestore.v1beta1.WriteResponse]\x20it\x20h\
    as\x20received.\x20This\x20acknowledges\x20that\x20the\x20client\x20has\
    \n\x20received\x20responses\x20up\x20to\x20this\x20token.\x20After\x20se\
    nding\x20this\x20token,\x20earlier\n\x20tokens\x20may\x20not\x20be\x20us\
    ed\x20anymore.\n\n\x20The\x20server\x20may\x20close\x20the\x20stream\x20\
    if\x20there\x20are\x20too\x20many\x20unacknowledged\n\x20responses.\n\n\
    \x20Leave\x20this\x20field\x20unset\x20when\x20creating\x20a\x20new\x20s\
    tream.\x20To\x20resume\x20a\x20stream\x20at\n\x20a\x20specific\x20point,\
    \x20set\x20this\x20field\x20and\x20the\x20`stream_id`\x20field.\n\n\x20L\
    eave\x20this\x20field\x20unset\x20when\x20creating\x20a\x20new\x20stream\
    .\n\n\x0f\n\x05\x04\x0f\x02\x03\x04\x12\x06\x91\x04\x02\x81\x04\x1c\n\r\
    \n\x05\x04\x0f\x02\x03\x05\x12\x04\x91\x04\x02\x07\n\r\n\x05\x04\x0f\x02\
    \x03\x01\x12\x04\x91\x04\x08\x14\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\
    \x91\x04\x17\x18\n:\n\x04\x04\x0f\x02\x04\x12\x04\x94\x04\x02!\x1a,\x20L\
    abels\x20associated\x20with\x20this\x20write\x20request.\n\n\x0f\n\x05\
    \x04\x0f\x02\x04\x04\x12\x06\x94\x04\x02\x91\x04\x19\n\r\n\x05\x04\x0f\
    \x02\x04\x06\x12\x04\x94\x04\x02\x15\n\r\n\x05\x04\x0f\x02\x04\x01\x12\
    \x04\x94\x04\x16\x1c\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\x94\x04\x1f\
    \x20\n]\n\x02\x04\x10\x12\x06\x98\x04\0\xab\x04\x01\x1aO\x20The\x20respo\
    nse\x20for\x20[Firestore.Write][google.firestore.v1beta1.Firestore.Write\
    ].\n\n\x0b\n\x03\x04\x10\x01\x12\x04\x98\x04\x08\x15\nd\n\x04\x04\x10\
    \x02\0\x12\x04\x9b\x04\x02\x17\x1aV\x20The\x20ID\x20of\x20the\x20stream.\
    \n\x20Only\x20set\x20on\x20the\x20first\x20message,\x20when\x20a\x20new\
    \x20stream\x20was\x20created.\n\n\x0f\n\x05\x04\x10\x02\0\x04\x12\x06\
    \x9b\x04\x02\x98\x04\x17\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\x9b\x04\x02\
    \x08\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\x9b\x04\t\x12\n\r\n\x05\x04\x10\
    \x02\0\x03\x12\x04\x9b\x04\x15\x16\n\xb3\x01\n\x04\x04\x10\x02\x01\x12\
    \x04\xa1\x04\x02\x19\x1a\xa4\x01\x20A\x20token\x20that\x20represents\x20\
    the\x20position\x20of\x20this\x20response\x20in\x20the\x20stream.\n\x20T\
    his\x20can\x20be\x20used\x20by\x20a\x20client\x20to\x20resume\x20the\x20\
    stream\x20at\x20this\x20point.\n\n\x20This\x20field\x20is\x20always\x20s\
    et.\n\n\x0f\n\x05\x04\x10\x02\x01\x04\x12\x06\xa1\x04\x02\x9b\x04\x17\n\
    \r\n\x05\x04\x10\x02\x01\x05\x12\x04\xa1\x04\x02\x07\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xa1\x04\x08\x14\n\r\n\x05\x04\x10\x02\x01\x03\x12\
    \x04\xa1\x04\x17\x18\nz\n\x04\x04\x10\x02\x02\x12\x04\xa7\x04\x02)\x1al\
    \x20The\x20result\x20of\x20applying\x20the\x20writes.\n\n\x20This\x20i-t\
    h\x20write\x20result\x20corresponds\x20to\x20the\x20i-th\x20write\x20in\
    \x20the\n\x20request.\n\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xa7\x04\
    \x02\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xa7\x04\x0b\x16\n\r\n\x05\
    \x04\x10\x02\x02\x01\x12\x04\xa7\x04\x17$\n\r\n\x05\x04\x10\x02\x02\x03\
    \x12\x04\xa7\x04'(\n6\n\x04\x04\x10\x02\x03\x12\x04\xaa\x04\x02,\x1a(\
    \x20The\x20time\x20at\x20which\x20the\x20commit\x20occurred.\n\n\x0f\n\
    \x05\x04\x10\x02\x03\x04\x12\x06\xaa\x04\x02\xa7\x04)\n\r\n\x05\x04\x10\
    \x02\x03\x06\x12\x04\xaa\x04\x02\x1b\n\r\n\x05\x04\x10\x02\x03\x01\x12\
    \x04\xaa\x04\x1c'\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xaa\x04*+\n[\n\
    \x02\x04\x11\x12\x06\xae\x04\0\xbe\x04\x01\x1aM\x20A\x20request\x20for\
    \x20[Firestore.Listen][google.firestore.v1beta1.Firestore.Listen]\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xae\x04\x08\x15\nc\n\x04\x04\x11\x02\0\
    \x12\x04\xb1\x04\x02\x16\x1aU\x20The\x20database\x20name.\x20In\x20the\
    \x20format:\n\x20`projects/{project_id}/databases/{database_id}`.\n\n\
    \x0f\n\x05\x04\x11\x02\0\x04\x12\x06\xb1\x04\x02\xae\x04\x17\n\r\n\x05\
    \x04\x11\x02\0\x05\x12\x04\xb1\x04\x02\x08\n\r\n\x05\x04\x11\x02\0\x01\
    \x12\x04\xb1\x04\t\x11\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb1\x04\x14\
    \x15\n/\n\x04\x04\x11\x08\0\x12\x06\xb4\x04\x02\xba\x04\x03\x1a\x1f\x20T\
    he\x20supported\x20target\x20changes.\n\n\r\n\x05\x04\x11\x08\0\x01\x12\
    \x04\xb4\x04\x08\x15\n/\n\x04\x04\x11\x02\x01\x12\x04\xb6\x04\x04\x1a\
    \x1a!\x20A\x20target\x20to\x20add\x20to\x20this\x20stream.\n\n\r\n\x05\
    \x04\x11\x02\x01\x06\x12\x04\xb6\x04\x04\n\n\r\n\x05\x04\x11\x02\x01\x01\
    \x12\x04\xb6\x04\x0b\x15\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb6\x04\
    \x18\x19\n>\n\x04\x04\x11\x02\x02\x12\x04\xb9\x04\x04\x1c\x1a0\x20The\
    \x20ID\x20of\x20a\x20target\x20to\x20remove\x20from\x20this\x20stream.\n\
    \n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xb9\x04\x04\t\n\r\n\x05\x04\x11\
    \x02\x02\x01\x12\x04\xb9\x04\n\x17\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\
    \xb9\x04\x1a\x1b\n:\n\x04\x04\x11\x02\x03\x12\x04\xbd\x04\x02!\x1a,\x20L\
    abels\x20associated\x20with\x20this\x20target\x20change.\n\n\x0f\n\x05\
    \x04\x11\x02\x03\x04\x12\x06\xbd\x04\x02\xba\x04\x03\n\r\n\x05\x04\x11\
    \x02\x03\x06\x12\x04\xbd\x04\x02\x15\n\r\n\x05\x04\x11\x02\x03\x01\x12\
    \x04\xbd\x04\x16\x1c\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xbd\x04\x1f\
    \x20\n_\n\x02\x04\x12\x12\x06\xc1\x04\0\xd8\x04\x01\x1aQ\x20The\x20respo\
    nse\x20for\x20[Firestore.Listen][google.firestore.v1beta1.Firestore.List\
    en].\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xc1\x04\x08\x16\n*\n\x04\x04\x12\
    \x08\0\x12\x06\xc3\x04\x02\xd7\x04\x03\x1a\x1a\x20The\x20supported\x20re\
    sponses.\n\n\r\n\x05\x04\x12\x08\0\x01\x12\x04\xc3\x04\x08\x15\n%\n\x04\
    \x04\x12\x02\0\x12\x04\xc5\x04\x04#\x1a\x17\x20Targets\x20have\x20change\
    d.\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xc5\x04\x04\x10\n\r\n\x05\x04\
    \x12\x02\0\x01\x12\x04\xc5\x04\x11\x1e\n\r\n\x05\x04\x12\x02\0\x03\x12\
    \x04\xc5\x04!\"\nL\n\x04\x04\x12\x02\x01\x12\x04\xc8\x04\x04'\x1a>\x20A\
    \x20[Document][google.firestore.v1beta1.Document]\x20has\x20changed.\n\n\
    \r\n\x05\x04\x12\x02\x01\x06\x12\x04\xc8\x04\x04\x12\n\r\n\x05\x04\x12\
    \x02\x01\x01\x12\x04\xc8\x04\x13\"\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xc8\x04%&\nQ\n\x04\x04\x12\x02\x02\x12\x04\xcb\x04\x04'\x1aC\x20A\x20[D\
    ocument][google.firestore.v1beta1.Document]\x20has\x20been\x20deleted.\n\
    \n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xcb\x04\x04\x12\n\r\n\x05\x04\x12\
    \x02\x02\x01\x12\x04\xcb\x04\x13\"\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\
    \xcb\x04%&\n\x93\x01\n\x04\x04\x12\x02\x03\x12\x04\xcf\x04\x04'\x1a\x84\
    \x01\x20A\x20[Document][google.firestore.v1beta1.Document]\x20has\x20bee\
    n\x20removed\x20from\x20a\x20target\x20(because\x20it\x20is\x20no\x20lon\
    ger\n\x20relevant\x20to\x20that\x20target).\n\n\r\n\x05\x04\x12\x02\x03\
    \x06\x12\x04\xcf\x04\x04\x12\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xcf\
    \x04\x13\"\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xcf\x04%&\n\xd2\x01\n\
    \x04\x04\x12\x02\x04\x12\x04\xd6\x04\x04\x1f\x1a\xc3\x01\x20A\x20filter\
    \x20to\x20apply\x20to\x20the\x20set\x20of\x20documents\x20previously\x20\
    returned\x20for\x20the\n\x20given\x20target.\n\n\x20Returned\x20when\x20\
    documents\x20may\x20have\x20been\x20removed\x20from\x20the\x20given\x20t\
    arget,\x20but\n\x20the\x20exact\x20documents\x20are\x20unknown.\n\n\r\n\
    \x05\x04\x12\x02\x04\x06\x12\x04\xd6\x04\x04\x13\n\r\n\x05\x04\x12\x02\
    \x04\x01\x12\x04\xd6\x04\x14\x1a\n\r\n\x05\x04\x12\x02\x04\x03\x12\x04\
    \xd6\x04\x1d\x1e\nC\n\x02\x04\x13\x12\x06\xdb\x04\0\x9b\x05\x01\x1a5\x20\
    A\x20specification\x20of\x20a\x20set\x20of\x20documents\x20to\x20listen\
    \x20to.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xdb\x04\x08\x0e\nA\n\x04\x04\
    \x13\x03\0\x12\x06\xdd\x04\x02\xe3\x04\x03\x1a1\x20A\x20target\x20specif\
    ied\x20by\x20a\x20set\x20of\x20documents\x20names.\n\n\r\n\x05\x04\x13\
    \x03\0\x01\x12\x04\xdd\x04\n\x19\n\x95\x02\n\x06\x04\x13\x03\0\x02\0\x12\
    \x04\xe2\x04\x04\"\x1a\x84\x02\x20The\x20names\x20of\x20the\x20documents\
    \x20to\x20retrieve.\x20In\x20the\x20format:\n\x20`projects/{project_id}/\
    databases/{database_id}/documents/{document_path}`.\n\x20The\x20request\
    \x20will\x20fail\x20if\x20any\x20of\x20the\x20document\x20is\x20not\x20a\
    \x20child\x20resource\x20of\n\x20the\x20given\x20`database`.\x20Duplicat\
    e\x20names\x20will\x20be\x20elided.\n\n\x0f\n\x07\x04\x13\x03\0\x02\0\
    \x04\x12\x04\xe2\x04\x04\x0c\n\x0f\n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\
    \xe2\x04\r\x13\n\x0f\n\x07\x04\x13\x03\0\x02\0\x01\x12\x04\xe2\x04\x14\
    \x1d\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\x04\xe2\x04\x20!\n0\n\x04\
    \x04\x13\x03\x01\x12\x06\xe6\x04\x02\xf4\x04\x03\x1a\x20\x20A\x20target\
    \x20specified\x20by\x20a\x20query.\n\n\r\n\x05\x04\x13\x03\x01\x01\x12\
    \x04\xe6\x04\n\x15\n\xda\x02\n\x06\x04\x13\x03\x01\x02\0\x12\x04\xed\x04\
    \x04\x16\x1a\xc9\x02\x20The\x20parent\x20resource\x20name.\x20In\x20the\
    \x20format:\n\x20`projects/{project_id}/databases/{database_id}/document\
    s`\x20or\n\x20`projects/{project_id}/databases/{database_id}/documents/{\
    document_path}`.\n\x20For\x20example:\n\x20`projects/my-project/database\
    s/my-database/documents`\x20or\n\x20`projects/my-project/databases/my-da\
    tabase/documents/chatrooms/my-chatroom`\n\n\x11\n\x07\x04\x13\x03\x01\
    \x02\0\x04\x12\x06\xed\x04\x04\xe6\x04\x17\n\x0f\n\x07\x04\x13\x03\x01\
    \x02\0\x05\x12\x04\xed\x04\x04\n\n\x0f\n\x07\x04\x13\x03\x01\x02\0\x01\
    \x12\x04\xed\x04\x0b\x11\n\x0f\n\x07\x04\x13\x03\x01\x02\0\x03\x12\x04\
    \xed\x04\x14\x15\n%\n\x06\x04\x13\x03\x01\x08\0\x12\x06\xf0\x04\x04\xf3\
    \x04\x05\x1a\x13\x20The\x20query\x20to\x20run.\n\n\x0f\n\x07\x04\x13\x03\
    \x01\x08\0\x01\x12\x04\xf0\x04\n\x14\n%\n\x06\x04\x13\x03\x01\x02\x01\
    \x12\x04\xf2\x04\x06+\x1a\x15\x20A\x20structured\x20query.\n\n\x0f\n\x07\
    \x04\x13\x03\x01\x02\x01\x06\x12\x04\xf2\x04\x06\x15\n\x0f\n\x07\x04\x13\
    \x03\x01\x02\x01\x01\x12\x04\xf2\x04\x16&\n\x0f\n\x07\x04\x13\x03\x01\
    \x02\x01\x03\x12\x04\xf2\x04)*\n2\n\x04\x04\x13\x08\0\x12\x06\xf7\x04\
    \x02\xfd\x04\x03\x1a\"\x20The\x20type\x20of\x20target\x20to\x20listen\
    \x20to.\n\n\r\n\x05\x04\x13\x08\0\x01\x12\x04\xf7\x04\x08\x13\n.\n\x04\
    \x04\x13\x02\0\x12\x04\xf9\x04\x04\x1a\x1a\x20\x20A\x20target\x20specifi\
    ed\x20by\x20a\x20query.\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xf9\x04\
    \x04\x0f\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xf9\x04\x10\x15\n\r\n\x05\
    \x04\x13\x02\0\x03\x12\x04\xf9\x04\x18\x19\n>\n\x04\x04\x13\x02\x01\x12\
    \x04\xfc\x04\x04\"\x1a0\x20A\x20target\x20specified\x20by\x20a\x20set\
    \x20of\x20document\x20names.\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xfc\
    \x04\x04\x13\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xfc\x04\x14\x1d\n\r\n\
    \x05\x04\x13\x02\x01\x03\x12\x04\xfc\x04\x20!\n\x82\x01\n\x04\x04\x13\
    \x08\x01\x12\x06\x83\x05\x02\x8d\x05\x03\x1ar\x20When\x20to\x20start\x20\
    listening.\n\n\x20If\x20not\x20specified,\x20all\x20matching\x20Document\
    s\x20are\x20returned\x20before\x20any\n\x20subsequent\x20changes.\n\n\r\
    \n\x05\x04\x13\x08\x01\x01\x12\x04\x83\x05\x08\x13\n\xc7\x01\n\x04\x04\
    \x13\x02\x02\x12\x04\x87\x05\x04\x1b\x1a\xb8\x01\x20A\x20resume\x20token\
    \x20from\x20a\x20prior\x20[TargetChange][google.firestore.v1beta1.Target\
    Change]\x20for\x20an\x20identical\x20target.\n\n\x20Using\x20a\x20resume\
    \x20token\x20with\x20a\x20different\x20target\x20is\x20unsupported\x20an\
    d\x20may\x20fail.\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\x87\x05\x04\t\
    \n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x87\x05\n\x16\n\r\n\x05\x04\x13\
    \x02\x02\x03\x12\x04\x87\x05\x19\x1a\n\x82\x01\n\x04\x04\x13\x02\x03\x12\
    \x04\x8c\x05\x04-\x1at\x20Start\x20listening\x20after\x20a\x20specific\
    \x20`read_time`.\n\n\x20The\x20client\x20must\x20know\x20the\x20state\
    \x20of\x20matching\x20documents\x20at\x20this\x20time.\n\n\r\n\x05\x04\
    \x13\x02\x03\x06\x12\x04\x8c\x05\x04\x1d\n\r\n\x05\x04\x13\x02\x03\x01\
    \x12\x04\x8c\x05\x1e'\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x8c\x05*,\n\
    \xdb\x02\n\x04\x04\x13\x02\x04\x12\x04\x97\x05\x02\x16\x1a\xcc\x02\x20A\
    \x20client\x20provided\x20target\x20ID.\n\n\x20If\x20not\x20set,\x20the\
    \x20server\x20will\x20assign\x20an\x20ID\x20for\x20the\x20target.\n\n\
    \x20Used\x20for\x20resuming\x20a\x20target\x20without\x20changing\x20IDs\
    .\x20The\x20IDs\x20can\x20either\x20be\n\x20client-assigned\x20or\x20be\
    \x20server-assigned\x20in\x20a\x20previous\x20stream.\x20All\x20targets\
    \n\x20with\x20client\x20provided\x20IDs\x20must\x20be\x20added\x20before\
    \x20adding\x20a\x20target\x20that\x20needs\n\x20a\x20server-assigned\x20\
    id.\n\n\x0f\n\x05\x04\x13\x02\x04\x04\x12\x06\x97\x05\x02\x8d\x05\x03\n\
    \r\n\x05\x04\x13\x02\x04\x05\x12\x04\x97\x05\x02\x07\n\r\n\x05\x04\x13\
    \x02\x04\x01\x12\x04\x97\x05\x08\x11\n\r\n\x05\x04\x13\x02\x04\x03\x12\
    \x04\x97\x05\x14\x15\nR\n\x04\x04\x13\x02\x05\x12\x04\x9a\x05\x02\x10\
    \x1aD\x20If\x20the\x20target\x20should\x20be\x20removed\x20once\x20it\
    \x20is\x20current\x20and\x20consistent.\n\n\x0f\n\x05\x04\x13\x02\x05\
    \x04\x12\x06\x9a\x05\x02\x97\x05\x16\n\r\n\x05\x04\x13\x02\x05\x05\x12\
    \x04\x9a\x05\x02\x06\n\r\n\x05\x04\x13\x02\x05\x01\x12\x04\x9a\x05\x07\
    \x0b\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\x9a\x05\x0e\x0f\n3\n\x02\x04\
    \x14\x12\x06\x9e\x05\0\xde\x05\x01\x1a%\x20Targets\x20being\x20watched\
    \x20have\x20changed.\n\n\x0b\n\x03\x04\x14\x01\x12\x04\x9e\x05\x08\x14\n\
    %\n\x04\x04\x14\x04\0\x12\x06\xa0\x05\x02\xba\x05\x03\x1a\x15\x20The\x20\
    type\x20of\x20change.\n\n\r\n\x05\x04\x14\x04\0\x01\x12\x04\xa0\x05\x07\
    \x17\nV\n\x06\x04\x14\x04\0\x02\0\x12\x04\xa2\x05\x04\x12\x1aF\x20No\x20\
    change\x20has\x20occurred.\x20Used\x20only\x20to\x20send\x20an\x20update\
    d\x20`resume_token`.\n\n\x0f\n\x07\x04\x14\x04\0\x02\0\x01\x12\x04\xa2\
    \x05\x04\r\n\x0f\n\x07\x04\x14\x04\0\x02\0\x02\x12\x04\xa2\x05\x10\x11\n\
    .\n\x06\x04\x14\x04\0\x02\x01\x12\x04\xa5\x05\x04\x0c\x1a\x1e\x20The\x20\
    targets\x20have\x20been\x20added.\n\n\x0f\n\x07\x04\x14\x04\0\x02\x01\
    \x01\x12\x04\xa5\x05\x04\x07\n\x0f\n\x07\x04\x14\x04\0\x02\x01\x02\x12\
    \x04\xa5\x05\n\x0b\n0\n\x06\x04\x14\x04\0\x02\x02\x12\x04\xa8\x05\x04\
    \x0f\x1a\x20\x20The\x20targets\x20have\x20been\x20removed.\n\n\x0f\n\x07\
    \x04\x14\x04\0\x02\x02\x01\x12\x04\xa8\x05\x04\n\n\x0f\n\x07\x04\x14\x04\
    \0\x02\x02\x02\x12\x04\xa8\x05\r\x0e\n\xb7\x02\n\x06\x04\x14\x04\0\x02\
    \x03\x12\x04\xb2\x05\x04\x10\x1a\xa6\x02\x20The\x20targets\x20reflect\
    \x20all\x20changes\x20committed\x20before\x20the\x20targets\x20were\x20a\
    dded\n\x20to\x20the\x20stream.\n\n\x20This\x20will\x20be\x20sent\x20afte\
    r\x20or\x20with\x20a\x20`read_time`\x20that\x20is\x20greater\x20than\x20\
    or\n\x20equal\x20to\x20the\x20time\x20at\x20which\x20the\x20targets\x20w\
    ere\x20added.\n\n\x20Listeners\x20can\x20wait\x20for\x20this\x20change\
    \x20if\x20read-after-write\x20semantics\n\x20are\x20desired.\n\n\x0f\n\
    \x07\x04\x14\x04\0\x02\x03\x01\x12\x04\xb2\x05\x04\x0b\n\x0f\n\x07\x04\
    \x14\x04\0\x02\x03\x02\x12\x04\xb2\x05\x0e\x0f\n\x80\x02\n\x06\x04\x14\
    \x04\0\x02\x04\x12\x04\xb9\x05\x04\x0e\x1a\xef\x01\x20The\x20targets\x20\
    have\x20been\x20reset,\x20and\x20a\x20new\x20initial\x20state\x20for\x20\
    the\x20targets\n\x20will\x20be\x20returned\x20in\x20subsequent\x20change\
    s.\n\n\x20After\x20the\x20initial\x20state\x20is\x20complete,\x20`CURREN\
    T`\x20will\x20be\x20returned\x20even\n\x20if\x20the\x20target\x20was\x20\
    previously\x20indicated\x20to\x20be\x20`CURRENT`.\n\n\x0f\n\x07\x04\x14\
    \x04\0\x02\x04\x01\x12\x04\xb9\x05\x04\t\n\x0f\n\x07\x04\x14\x04\0\x02\
    \x04\x02\x12\x04\xb9\x05\x0c\r\n1\n\x04\x04\x14\x02\0\x12\x04\xbd\x05\
    \x02*\x1a#\x20The\x20type\x20of\x20change\x20that\x20occurred.\n\n\x0f\n\
    \x05\x04\x14\x02\0\x04\x12\x06\xbd\x05\x02\xba\x05\x03\n\r\n\x05\x04\x14\
    \x02\0\x06\x12\x04\xbd\x05\x02\x12\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\
    \xbd\x05\x13%\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xbd\x05()\n\xfe\x02\n\
    \x04\x04\x14\x02\x01\x12\x04\xc8\x05\x02\x20\x1a\xef\x02\x20The\x20targe\
    t\x20IDs\x20of\x20targets\x20that\x20have\x20changed.\n\n\x20If\x20empty\
    ,\x20the\x20change\x20applies\x20to\x20all\x20targets.\n\n\x20For\x20`ta\
    rget_change_type=ADD`,\x20the\x20order\x20of\x20the\x20target\x20IDs\x20\
    matches\x20the\x20order\n\x20of\x20the\x20requests\x20to\x20add\x20the\
    \x20targets.\x20This\x20allows\x20clients\x20to\x20unambiguously\n\x20as\
    sociate\x20server-assigned\x20target\x20IDs\x20with\x20added\x20targets.\
    \n\n\x20For\x20other\x20states,\x20the\x20order\x20of\x20the\x20target\
    \x20IDs\x20is\x20not\x20defined.\n\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\
    \xc8\x05\x02\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xc8\x05\x0b\x10\n\r\
    \n\x05\x04\x14\x02\x01\x01\x12\x04\xc8\x05\x11\x1b\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\xc8\x05\x1e\x1f\nF\n\x04\x04\x14\x02\x02\x12\x04\xcb\
    \x05\x02\x1e\x1a8\x20The\x20error\x20that\x20resulted\x20in\x20this\x20c\
    hange,\x20if\x20applicable.\n\n\x0f\n\x05\x04\x14\x02\x02\x04\x12\x06\
    \xcb\x05\x02\xc8\x05\x20\n\r\n\x05\x04\x14\x02\x02\x06\x12\x04\xcb\x05\
    \x02\x13\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xcb\x05\x14\x19\n\r\n\x05\
    \x04\x14\x02\x02\x03\x12\x04\xcb\x05\x1c\x1d\n\xa6\x01\n\x04\x04\x14\x02\
    \x03\x12\x04\xd1\x05\x02\x19\x1a\x97\x01\x20A\x20token\x20that\x20can\
    \x20be\x20used\x20to\x20resume\x20the\x20stream\x20for\x20the\x20given\
    \x20`target_ids`,\n\x20or\x20all\x20targets\x20if\x20`target_ids`\x20is\
    \x20empty.\n\n\x20Not\x20set\x20on\x20every\x20target\x20change.\n\n\x0f\
    \n\x05\x04\x14\x02\x03\x04\x12\x06\xd1\x05\x02\xcb\x05\x1e\n\r\n\x05\x04\
    \x14\x02\x03\x05\x12\x04\xd1\x05\x02\x07\n\r\n\x05\x04\x14\x02\x03\x01\
    \x12\x04\xd1\x05\x08\x14\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xd1\x05\
    \x17\x18\n\xf5\x03\n\x04\x04\x14\x02\x04\x12\x04\xdd\x05\x02*\x1a\xe6\
    \x03\x20The\x20consistent\x20`read_time`\x20for\x20the\x20given\x20`targ\
    et_ids`\x20(omitted\x20when\x20the\n\x20target_ids\x20are\x20not\x20at\
    \x20a\x20consistent\x20snapshot).\n\n\x20The\x20stream\x20is\x20guarante\
    ed\x20to\x20send\x20a\x20`read_time`\x20with\x20`target_ids`\x20empty\n\
    \x20whenever\x20the\x20entire\x20stream\x20reaches\x20a\x20new\x20consis\
    tent\x20snapshot.\x20ADD,\n\x20CURRENT,\x20and\x20RESET\x20messages\x20a\
    re\x20guaranteed\x20to\x20(eventually)\x20result\x20in\x20a\n\x20new\x20\
    consistent\x20snapshot\x20(while\x20NO_CHANGE\x20and\x20REMOVE\x20messag\
    es\x20are\x20not).\n\n\x20For\x20a\x20given\x20stream,\x20`read_time`\
    \x20is\x20guaranteed\x20to\x20be\x20monotonically\n\x20increasing.\n\n\
    \x0f\n\x05\x04\x14\x02\x04\x04\x12\x06\xdd\x05\x02\xd1\x05\x19\n\r\n\x05\
    \x04\x14\x02\x04\x06\x12\x04\xdd\x05\x02\x1b\n\r\n\x05\x04\x14\x02\x04\
    \x01\x12\x04\xdd\x05\x1c%\n\r\n\x05\x04\x14\x02\x04\x03\x12\x04\xdd\x05(\
    )\nt\n\x02\x04\x15\x12\x06\xe1\x05\0\xee\x05\x01\x1af\x20The\x20request\
    \x20for\x20[Firestore.ListCollectionIds][google.firestore.v1beta1.Firest\
    ore.ListCollectionIds].\n\n\x0b\n\x03\x04\x15\x01\x12\x04\xe1\x05\x08\
    \x20\n\xdb\x01\n\x04\x04\x15\x02\0\x12\x04\xe6\x05\x02\x14\x1a\xcc\x01\
    \x20The\x20parent\x20document.\x20In\x20the\x20format:\n\x20`projects/{p\
    roject_id}/databases/{database_id}/documents/{document_path}`.\n\x20For\
    \x20example:\n\x20`projects/my-project/databases/my-database/documents/c\
    hatrooms/my-chatroom`\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\xe6\x05\
    \x02\xe1\x05\"\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xe6\x05\x02\x08\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\xe6\x05\t\x0f\n\r\n\x05\x04\x15\x02\0\x03\
    \x12\x04\xe6\x05\x12\x13\n8\n\x04\x04\x15\x02\x01\x12\x04\xe9\x05\x02\
    \x16\x1a*\x20The\x20maximum\x20number\x20of\x20results\x20to\x20return.\
    \n\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\xe9\x05\x02\xe6\x05\x14\n\r\n\
    \x05\x04\x15\x02\x01\x05\x12\x04\xe9\x05\x02\x07\n\r\n\x05\x04\x15\x02\
    \x01\x01\x12\x04\xe9\x05\x08\x11\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xe9\x05\x14\x15\n\x84\x01\n\x04\x04\x15\x02\x02\x12\x04\xed\x05\x02\x18\
    \x1av\x20A\x20page\x20token.\x20Must\x20be\x20a\x20value\x20from\n\x20[L\
    istCollectionIdsResponse][google.firestore.v1beta1.ListCollectionIdsResp\
    onse].\n\n\x0f\n\x05\x04\x15\x02\x02\x04\x12\x06\xed\x05\x02\xe9\x05\x16\
    \n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xed\x05\x02\x08\n\r\n\x05\x04\x15\
    \x02\x02\x01\x12\x04\xed\x05\t\x13\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\
    \xed\x05\x16\x17\nv\n\x02\x04\x16\x12\x06\xf1\x05\0\xf7\x05\x01\x1ah\x20\
    The\x20response\x20from\x20[Firestore.ListCollectionIds][google.firestor\
    e.v1beta1.Firestore.ListCollectionIds].\n\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\xf1\x05\x08!\n#\n\x04\x04\x16\x02\0\x12\x04\xf3\x05\x02%\x1a\x15\
    \x20The\x20collection\x20ids.\n\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xf3\
    \x05\x02\n\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xf3\x05\x0b\x11\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xf3\x05\x12\x20\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xf3\x05#$\nC\n\x04\x04\x16\x02\x01\x12\x04\xf6\x05\x02\x1d\x1a5\
    \x20A\x20page\x20token\x20that\x20may\x20be\x20used\x20to\x20continue\
    \x20the\x20list.\n\n\x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\xf6\x05\x02\
    \xf3\x05%\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xf6\x05\x02\x08\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\xf6\x05\t\x18\n\r\n\x05\x04\x16\x02\x01\
    \x03\x12\x04\xf6\x05\x1b\x1cb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
