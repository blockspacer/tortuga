// This file is generated by rust-protobuf 2.0.5. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery {
    // message fields
    pub select: ::protobuf::SingularPtrField<StructuredQuery_Projection>,
    pub from: ::protobuf::RepeatedField<StructuredQuery_CollectionSelector>,
    pub field_where: ::protobuf::SingularPtrField<StructuredQuery_Filter>,
    pub order_by: ::protobuf::RepeatedField<StructuredQuery_Order>,
    pub start_at: ::protobuf::SingularPtrField<Cursor>,
    pub end_at: ::protobuf::SingularPtrField<Cursor>,
    pub offset: i32,
    pub limit: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery {
    pub fn new() -> StructuredQuery {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.Projection select = 1;

    pub fn clear_select(&mut self) {
        self.select.clear();
    }

    pub fn has_select(&self) -> bool {
        self.select.is_some()
    }

    // Param is passed by value, moved
    pub fn set_select(&mut self, v: StructuredQuery_Projection) {
        self.select = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_select(&mut self) -> &mut StructuredQuery_Projection {
        if self.select.is_none() {
            self.select.set_default();
        }
        self.select.as_mut().unwrap()
    }

    // Take field
    pub fn take_select(&mut self) -> StructuredQuery_Projection {
        self.select.take().unwrap_or_else(|| StructuredQuery_Projection::new())
    }

    pub fn get_select(&self) -> &StructuredQuery_Projection {
        self.select.as_ref().unwrap_or_else(|| StructuredQuery_Projection::default_instance())
    }

    // repeated .google.firestore.v1beta1.StructuredQuery.CollectionSelector from = 2;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::protobuf::RepeatedField<StructuredQuery_CollectionSelector>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    pub fn mut_from(&mut self) -> &mut ::protobuf::RepeatedField<StructuredQuery_CollectionSelector> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::protobuf::RepeatedField<StructuredQuery_CollectionSelector> {
        ::std::mem::replace(&mut self.from, ::protobuf::RepeatedField::new())
    }

    pub fn get_from(&self) -> &[StructuredQuery_CollectionSelector] {
        &self.from
    }

    // .google.firestore.v1beta1.StructuredQuery.Filter where = 3;

    pub fn clear_field_where(&mut self) {
        self.field_where.clear();
    }

    pub fn has_field_where(&self) -> bool {
        self.field_where.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_where(&mut self, v: StructuredQuery_Filter) {
        self.field_where = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_where(&mut self) -> &mut StructuredQuery_Filter {
        if self.field_where.is_none() {
            self.field_where.set_default();
        }
        self.field_where.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_where(&mut self) -> StructuredQuery_Filter {
        self.field_where.take().unwrap_or_else(|| StructuredQuery_Filter::new())
    }

    pub fn get_field_where(&self) -> &StructuredQuery_Filter {
        self.field_where.as_ref().unwrap_or_else(|| StructuredQuery_Filter::default_instance())
    }

    // repeated .google.firestore.v1beta1.StructuredQuery.Order order_by = 4;

    pub fn clear_order_by(&mut self) {
        self.order_by.clear();
    }

    // Param is passed by value, moved
    pub fn set_order_by(&mut self, v: ::protobuf::RepeatedField<StructuredQuery_Order>) {
        self.order_by = v;
    }

    // Mutable pointer to the field.
    pub fn mut_order_by(&mut self) -> &mut ::protobuf::RepeatedField<StructuredQuery_Order> {
        &mut self.order_by
    }

    // Take field
    pub fn take_order_by(&mut self) -> ::protobuf::RepeatedField<StructuredQuery_Order> {
        ::std::mem::replace(&mut self.order_by, ::protobuf::RepeatedField::new())
    }

    pub fn get_order_by(&self) -> &[StructuredQuery_Order] {
        &self.order_by
    }

    // .google.firestore.v1beta1.Cursor start_at = 7;

    pub fn clear_start_at(&mut self) {
        self.start_at.clear();
    }

    pub fn has_start_at(&self) -> bool {
        self.start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_at(&mut self, v: Cursor) {
        self.start_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_at(&mut self) -> &mut Cursor {
        if self.start_at.is_none() {
            self.start_at.set_default();
        }
        self.start_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_at(&mut self) -> Cursor {
        self.start_at.take().unwrap_or_else(|| Cursor::new())
    }

    pub fn get_start_at(&self) -> &Cursor {
        self.start_at.as_ref().unwrap_or_else(|| Cursor::default_instance())
    }

    // .google.firestore.v1beta1.Cursor end_at = 8;

    pub fn clear_end_at(&mut self) {
        self.end_at.clear();
    }

    pub fn has_end_at(&self) -> bool {
        self.end_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_at(&mut self, v: Cursor) {
        self.end_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_at(&mut self) -> &mut Cursor {
        if self.end_at.is_none() {
            self.end_at.set_default();
        }
        self.end_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_at(&mut self) -> Cursor {
        self.end_at.take().unwrap_or_else(|| Cursor::new())
    }

    pub fn get_end_at(&self) -> &Cursor {
        self.end_at.as_ref().unwrap_or_else(|| Cursor::default_instance())
    }

    // int32 offset = 6;

    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = v;
    }

    pub fn get_offset(&self) -> i32 {
        self.offset
    }

    // .google.protobuf.Int32Value limit = 5;

    pub fn clear_limit(&mut self) {
        self.limit.clear();
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.limit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_limit(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.limit.is_none() {
            self.limit.set_default();
        }
        self.limit.as_mut().unwrap()
    }

    // Take field
    pub fn take_limit(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.limit.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_limit(&self) -> &::protobuf::well_known_types::Int32Value {
        self.limit.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }
}

impl ::protobuf::Message for StructuredQuery {
    fn is_initialized(&self) -> bool {
        for v in &self.select {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.from {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.field_where {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.order_by {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.select)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.from)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_where)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.order_by)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_at)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_at)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.limit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.select.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.from {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_where.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.order_by {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.start_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(6, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.limit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.select.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.from {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_where.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.order_by {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.start_at.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_at.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int32(6, self.offset)?;
        }
        if let Some(ref v) = self.limit.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery {
        StructuredQuery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_Projection>>(
                    "select",
                    |m: &StructuredQuery| { &m.select },
                    |m: &mut StructuredQuery| { &mut m.select },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_CollectionSelector>>(
                    "from",
                    |m: &StructuredQuery| { &m.from },
                    |m: &mut StructuredQuery| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_Filter>>(
                    "where",
                    |m: &StructuredQuery| { &m.field_where },
                    |m: &mut StructuredQuery| { &mut m.field_where },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_Order>>(
                    "order_by",
                    |m: &StructuredQuery| { &m.order_by },
                    |m: &mut StructuredQuery| { &mut m.order_by },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cursor>>(
                    "start_at",
                    |m: &StructuredQuery| { &m.start_at },
                    |m: &mut StructuredQuery| { &mut m.start_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cursor>>(
                    "end_at",
                    |m: &StructuredQuery| { &m.end_at },
                    |m: &mut StructuredQuery| { &mut m.end_at },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "offset",
                    |m: &StructuredQuery| { &m.offset },
                    |m: &mut StructuredQuery| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "limit",
                    |m: &StructuredQuery| { &m.limit },
                    |m: &mut StructuredQuery| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery>(
                    "StructuredQuery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery,
        };
        unsafe {
            instance.get(StructuredQuery::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery {
    fn clear(&mut self) {
        self.clear_select();
        self.clear_from();
        self.clear_field_where();
        self.clear_order_by();
        self.clear_start_at();
        self.clear_end_at();
        self.clear_offset();
        self.clear_limit();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_CollectionSelector {
    // message fields
    pub collection_id: ::std::string::String,
    pub all_descendants: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_CollectionSelector {
    pub fn new() -> StructuredQuery_CollectionSelector {
        ::std::default::Default::default()
    }

    // string collection_id = 2;

    pub fn clear_collection_id(&mut self) {
        self.collection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_collection_id(&mut self, v: ::std::string::String) {
        self.collection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collection_id(&mut self) -> &mut ::std::string::String {
        &mut self.collection_id
    }

    // Take field
    pub fn take_collection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collection_id, ::std::string::String::new())
    }

    pub fn get_collection_id(&self) -> &str {
        &self.collection_id
    }

    // bool all_descendants = 3;

    pub fn clear_all_descendants(&mut self) {
        self.all_descendants = false;
    }

    // Param is passed by value, moved
    pub fn set_all_descendants(&mut self, v: bool) {
        self.all_descendants = v;
    }

    pub fn get_all_descendants(&self) -> bool {
        self.all_descendants
    }
}

impl ::protobuf::Message for StructuredQuery_CollectionSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collection_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.all_descendants = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.collection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection_id);
        }
        if self.all_descendants != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.collection_id.is_empty() {
            os.write_string(2, &self.collection_id)?;
        }
        if self.all_descendants != false {
            os.write_bool(3, self.all_descendants)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_CollectionSelector {
        StructuredQuery_CollectionSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "collection_id",
                    |m: &StructuredQuery_CollectionSelector| { &m.collection_id },
                    |m: &mut StructuredQuery_CollectionSelector| { &mut m.collection_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "all_descendants",
                    |m: &StructuredQuery_CollectionSelector| { &m.all_descendants },
                    |m: &mut StructuredQuery_CollectionSelector| { &mut m.all_descendants },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_CollectionSelector>(
                    "StructuredQuery_CollectionSelector",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_CollectionSelector {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_CollectionSelector> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_CollectionSelector,
        };
        unsafe {
            instance.get(StructuredQuery_CollectionSelector::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_CollectionSelector {
    fn clear(&mut self) {
        self.clear_collection_id();
        self.clear_all_descendants();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_CollectionSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_CollectionSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_Filter {
    // message oneof groups
    pub filter_type: ::std::option::Option<StructuredQuery_Filter_oneof_filter_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum StructuredQuery_Filter_oneof_filter_type {
    composite_filter(StructuredQuery_CompositeFilter),
    field_filter(StructuredQuery_FieldFilter),
    unary_filter(StructuredQuery_UnaryFilter),
}

impl StructuredQuery_Filter {
    pub fn new() -> StructuredQuery_Filter {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.CompositeFilter composite_filter = 1;

    pub fn clear_composite_filter(&mut self) {
        self.filter_type = ::std::option::Option::None;
    }

    pub fn has_composite_filter(&self) -> bool {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_composite_filter(&mut self, v: StructuredQuery_CompositeFilter) {
        self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_composite_filter(&mut self) -> &mut StructuredQuery_CompositeFilter {
        if let ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(_)) = self.filter_type {
        } else {
            self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(StructuredQuery_CompositeFilter::new()));
        }
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_composite_filter(&mut self) -> StructuredQuery_CompositeFilter {
        if self.has_composite_filter() {
            match self.filter_type.take() {
                ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            StructuredQuery_CompositeFilter::new()
        }
    }

    pub fn get_composite_filter(&self) -> &StructuredQuery_CompositeFilter {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(ref v)) => v,
            _ => StructuredQuery_CompositeFilter::default_instance(),
        }
    }

    // .google.firestore.v1beta1.StructuredQuery.FieldFilter field_filter = 2;

    pub fn clear_field_filter(&mut self) {
        self.filter_type = ::std::option::Option::None;
    }

    pub fn has_field_filter(&self) -> bool {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_filter(&mut self, v: StructuredQuery_FieldFilter) {
        self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_filter(&mut self) -> &mut StructuredQuery_FieldFilter {
        if let ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(_)) = self.filter_type {
        } else {
            self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(StructuredQuery_FieldFilter::new()));
        }
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_filter(&mut self) -> StructuredQuery_FieldFilter {
        if self.has_field_filter() {
            match self.filter_type.take() {
                ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            StructuredQuery_FieldFilter::new()
        }
    }

    pub fn get_field_filter(&self) -> &StructuredQuery_FieldFilter {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(ref v)) => v,
            _ => StructuredQuery_FieldFilter::default_instance(),
        }
    }

    // .google.firestore.v1beta1.StructuredQuery.UnaryFilter unary_filter = 3;

    pub fn clear_unary_filter(&mut self) {
        self.filter_type = ::std::option::Option::None;
    }

    pub fn has_unary_filter(&self) -> bool {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unary_filter(&mut self, v: StructuredQuery_UnaryFilter) {
        self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unary_filter(&mut self) -> &mut StructuredQuery_UnaryFilter {
        if let ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(_)) = self.filter_type {
        } else {
            self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(StructuredQuery_UnaryFilter::new()));
        }
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unary_filter(&mut self) -> StructuredQuery_UnaryFilter {
        if self.has_unary_filter() {
            match self.filter_type.take() {
                ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(v)) => v,
                _ => panic!(),
            }
        } else {
            StructuredQuery_UnaryFilter::new()
        }
    }

    pub fn get_unary_filter(&self) -> &StructuredQuery_UnaryFilter {
        match self.filter_type {
            ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(ref v)) => v,
            _ => StructuredQuery_UnaryFilter::default_instance(),
        }
    }
}

impl ::protobuf::Message for StructuredQuery_Filter {
    fn is_initialized(&self) -> bool {
        if let Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(ref v)) = self.filter_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredQuery_Filter_oneof_filter_type::field_filter(ref v)) = self.filter_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(ref v)) = self.filter_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::composite_filter(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::field_filter(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.filter_type = ::std::option::Option::Some(StructuredQuery_Filter_oneof_filter_type::unary_filter(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.filter_type {
            match v {
                &StructuredQuery_Filter_oneof_filter_type::composite_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredQuery_Filter_oneof_filter_type::field_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StructuredQuery_Filter_oneof_filter_type::unary_filter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.filter_type {
            match v {
                &StructuredQuery_Filter_oneof_filter_type::composite_filter(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredQuery_Filter_oneof_filter_type::field_filter(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StructuredQuery_Filter_oneof_filter_type::unary_filter(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_Filter {
        StructuredQuery_Filter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StructuredQuery_CompositeFilter>(
                    "composite_filter",
                    StructuredQuery_Filter::has_composite_filter,
                    StructuredQuery_Filter::get_composite_filter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StructuredQuery_FieldFilter>(
                    "field_filter",
                    StructuredQuery_Filter::has_field_filter,
                    StructuredQuery_Filter::get_field_filter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StructuredQuery_UnaryFilter>(
                    "unary_filter",
                    StructuredQuery_Filter::has_unary_filter,
                    StructuredQuery_Filter::get_unary_filter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_Filter>(
                    "StructuredQuery_Filter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_Filter {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_Filter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_Filter,
        };
        unsafe {
            instance.get(StructuredQuery_Filter::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_Filter {
    fn clear(&mut self) {
        self.clear_composite_filter();
        self.clear_field_filter();
        self.clear_unary_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_Filter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_CompositeFilter {
    // message fields
    pub op: StructuredQuery_CompositeFilter_Operator,
    pub filters: ::protobuf::RepeatedField<StructuredQuery_Filter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_CompositeFilter {
    pub fn new() -> StructuredQuery_CompositeFilter {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.CompositeFilter.Operator op = 1;

    pub fn clear_op(&mut self) {
        self.op = StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: StructuredQuery_CompositeFilter_Operator) {
        self.op = v;
    }

    pub fn get_op(&self) -> StructuredQuery_CompositeFilter_Operator {
        self.op
    }

    // repeated .google.firestore.v1beta1.StructuredQuery.Filter filters = 2;

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<StructuredQuery_Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters(&mut self) -> &mut ::protobuf::RepeatedField<StructuredQuery_Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<StructuredQuery_Filter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }

    pub fn get_filters(&self) -> &[StructuredQuery_Filter] {
        &self.filters
    }
}

impl ::protobuf::Message for StructuredQuery_CompositeFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.filters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op != StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.op);
        }
        for value in &self.filters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.op != StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED {
            os.write_enum(1, self.op.value())?;
        }
        for v in &self.filters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_CompositeFilter {
        StructuredQuery_CompositeFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructuredQuery_CompositeFilter_Operator>>(
                    "op",
                    |m: &StructuredQuery_CompositeFilter| { &m.op },
                    |m: &mut StructuredQuery_CompositeFilter| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_Filter>>(
                    "filters",
                    |m: &StructuredQuery_CompositeFilter| { &m.filters },
                    |m: &mut StructuredQuery_CompositeFilter| { &mut m.filters },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_CompositeFilter>(
                    "StructuredQuery_CompositeFilter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_CompositeFilter {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_CompositeFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_CompositeFilter,
        };
        unsafe {
            instance.get(StructuredQuery_CompositeFilter::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_CompositeFilter {
    fn clear(&mut self) {
        self.clear_op();
        self.clear_filters();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_CompositeFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_CompositeFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructuredQuery_CompositeFilter_Operator {
    OPERATOR_UNSPECIFIED = 0,
    AND = 1,
}

impl ::protobuf::ProtobufEnum for StructuredQuery_CompositeFilter_Operator {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructuredQuery_CompositeFilter_Operator> {
        match value {
            0 => ::std::option::Option::Some(StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED),
            1 => ::std::option::Option::Some(StructuredQuery_CompositeFilter_Operator::AND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructuredQuery_CompositeFilter_Operator] = &[
            StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED,
            StructuredQuery_CompositeFilter_Operator::AND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructuredQuery_CompositeFilter_Operator", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructuredQuery_CompositeFilter_Operator {
}

impl ::std::default::Default for StructuredQuery_CompositeFilter_Operator {
    fn default() -> Self {
        StructuredQuery_CompositeFilter_Operator::OPERATOR_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_CompositeFilter_Operator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_FieldFilter {
    // message fields
    pub field: ::protobuf::SingularPtrField<StructuredQuery_FieldReference>,
    pub op: StructuredQuery_FieldFilter_Operator,
    pub value: ::protobuf::SingularPtrField<super::document::Value>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_FieldFilter {
    pub fn new() -> StructuredQuery_FieldFilter {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.FieldReference field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: StructuredQuery_FieldReference) {
        self.field = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut StructuredQuery_FieldReference {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> StructuredQuery_FieldReference {
        self.field.take().unwrap_or_else(|| StructuredQuery_FieldReference::new())
    }

    pub fn get_field(&self) -> &StructuredQuery_FieldReference {
        self.field.as_ref().unwrap_or_else(|| StructuredQuery_FieldReference::default_instance())
    }

    // .google.firestore.v1beta1.StructuredQuery.FieldFilter.Operator op = 2;

    pub fn clear_op(&mut self) {
        self.op = StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: StructuredQuery_FieldFilter_Operator) {
        self.op = v;
    }

    pub fn get_op(&self) -> StructuredQuery_FieldFilter_Operator {
        self.op
    }

    // .google.firestore.v1beta1.Value value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::document::Value) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::document::Value {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::document::Value {
        self.value.take().unwrap_or_else(|| super::document::Value::new())
    }

    pub fn get_value(&self) -> &super::document::Value {
        self.value.as_ref().unwrap_or_else(|| super::document::Value::default_instance())
    }
}

impl ::protobuf::Message for StructuredQuery_FieldFilter {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.op != StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.op);
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.op != StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED {
            os.write_enum(2, self.op.value())?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_FieldFilter {
        StructuredQuery_FieldFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_FieldReference>>(
                    "field",
                    |m: &StructuredQuery_FieldFilter| { &m.field },
                    |m: &mut StructuredQuery_FieldFilter| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructuredQuery_FieldFilter_Operator>>(
                    "op",
                    |m: &StructuredQuery_FieldFilter| { &m.op },
                    |m: &mut StructuredQuery_FieldFilter| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Value>>(
                    "value",
                    |m: &StructuredQuery_FieldFilter| { &m.value },
                    |m: &mut StructuredQuery_FieldFilter| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_FieldFilter>(
                    "StructuredQuery_FieldFilter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_FieldFilter {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_FieldFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_FieldFilter,
        };
        unsafe {
            instance.get(StructuredQuery_FieldFilter::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_FieldFilter {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_op();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_FieldFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_FieldFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructuredQuery_FieldFilter_Operator {
    OPERATOR_UNSPECIFIED = 0,
    LESS_THAN = 1,
    LESS_THAN_OR_EQUAL = 2,
    GREATER_THAN = 3,
    GREATER_THAN_OR_EQUAL = 4,
    EQUAL = 5,
    ARRAY_CONTAINS = 7,
}

impl ::protobuf::ProtobufEnum for StructuredQuery_FieldFilter_Operator {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructuredQuery_FieldFilter_Operator> {
        match value {
            0 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED),
            1 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::LESS_THAN),
            2 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::LESS_THAN_OR_EQUAL),
            3 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::GREATER_THAN),
            4 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::GREATER_THAN_OR_EQUAL),
            5 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::EQUAL),
            7 => ::std::option::Option::Some(StructuredQuery_FieldFilter_Operator::ARRAY_CONTAINS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructuredQuery_FieldFilter_Operator] = &[
            StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED,
            StructuredQuery_FieldFilter_Operator::LESS_THAN,
            StructuredQuery_FieldFilter_Operator::LESS_THAN_OR_EQUAL,
            StructuredQuery_FieldFilter_Operator::GREATER_THAN,
            StructuredQuery_FieldFilter_Operator::GREATER_THAN_OR_EQUAL,
            StructuredQuery_FieldFilter_Operator::EQUAL,
            StructuredQuery_FieldFilter_Operator::ARRAY_CONTAINS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructuredQuery_FieldFilter_Operator", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructuredQuery_FieldFilter_Operator {
}

impl ::std::default::Default for StructuredQuery_FieldFilter_Operator {
    fn default() -> Self {
        StructuredQuery_FieldFilter_Operator::OPERATOR_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_FieldFilter_Operator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_UnaryFilter {
    // message fields
    pub op: StructuredQuery_UnaryFilter_Operator,
    // message oneof groups
    pub operand_type: ::std::option::Option<StructuredQuery_UnaryFilter_oneof_operand_type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum StructuredQuery_UnaryFilter_oneof_operand_type {
    field(StructuredQuery_FieldReference),
}

impl StructuredQuery_UnaryFilter {
    pub fn new() -> StructuredQuery_UnaryFilter {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.UnaryFilter.Operator op = 1;

    pub fn clear_op(&mut self) {
        self.op = StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: StructuredQuery_UnaryFilter_Operator) {
        self.op = v;
    }

    pub fn get_op(&self) -> StructuredQuery_UnaryFilter_Operator {
        self.op
    }

    // .google.firestore.v1beta1.StructuredQuery.FieldReference field = 2;

    pub fn clear_field(&mut self) {
        self.operand_type = ::std::option::Option::None;
    }

    pub fn has_field(&self) -> bool {
        match self.operand_type {
            ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: StructuredQuery_FieldReference) {
        self.operand_type = ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field(&mut self) -> &mut StructuredQuery_FieldReference {
        if let ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(_)) = self.operand_type {
        } else {
            self.operand_type = ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(StructuredQuery_FieldReference::new()));
        }
        match self.operand_type {
            ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field(&mut self) -> StructuredQuery_FieldReference {
        if self.has_field() {
            match self.operand_type.take() {
                ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(v)) => v,
                _ => panic!(),
            }
        } else {
            StructuredQuery_FieldReference::new()
        }
    }

    pub fn get_field(&self) -> &StructuredQuery_FieldReference {
        match self.operand_type {
            ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(ref v)) => v,
            _ => StructuredQuery_FieldReference::default_instance(),
        }
    }
}

impl ::protobuf::Message for StructuredQuery_UnaryFilter {
    fn is_initialized(&self) -> bool {
        if let Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(ref v)) = self.operand_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.op, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.operand_type = ::std::option::Option::Some(StructuredQuery_UnaryFilter_oneof_operand_type::field(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op != StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.op);
        }
        if let ::std::option::Option::Some(ref v) = self.operand_type {
            match v {
                &StructuredQuery_UnaryFilter_oneof_operand_type::field(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.op != StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED {
            os.write_enum(1, self.op.value())?;
        }
        if let ::std::option::Option::Some(ref v) = self.operand_type {
            match v {
                &StructuredQuery_UnaryFilter_oneof_operand_type::field(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_UnaryFilter {
        StructuredQuery_UnaryFilter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructuredQuery_UnaryFilter_Operator>>(
                    "op",
                    |m: &StructuredQuery_UnaryFilter| { &m.op },
                    |m: &mut StructuredQuery_UnaryFilter| { &mut m.op },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StructuredQuery_FieldReference>(
                    "field",
                    StructuredQuery_UnaryFilter::has_field,
                    StructuredQuery_UnaryFilter::get_field,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_UnaryFilter>(
                    "StructuredQuery_UnaryFilter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_UnaryFilter {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_UnaryFilter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_UnaryFilter,
        };
        unsafe {
            instance.get(StructuredQuery_UnaryFilter::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_UnaryFilter {
    fn clear(&mut self) {
        self.clear_op();
        self.clear_field();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_UnaryFilter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_UnaryFilter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructuredQuery_UnaryFilter_Operator {
    OPERATOR_UNSPECIFIED = 0,
    IS_NAN = 2,
    IS_NULL = 3,
}

impl ::protobuf::ProtobufEnum for StructuredQuery_UnaryFilter_Operator {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructuredQuery_UnaryFilter_Operator> {
        match value {
            0 => ::std::option::Option::Some(StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED),
            2 => ::std::option::Option::Some(StructuredQuery_UnaryFilter_Operator::IS_NAN),
            3 => ::std::option::Option::Some(StructuredQuery_UnaryFilter_Operator::IS_NULL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructuredQuery_UnaryFilter_Operator] = &[
            StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED,
            StructuredQuery_UnaryFilter_Operator::IS_NAN,
            StructuredQuery_UnaryFilter_Operator::IS_NULL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructuredQuery_UnaryFilter_Operator", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructuredQuery_UnaryFilter_Operator {
}

impl ::std::default::Default for StructuredQuery_UnaryFilter_Operator {
    fn default() -> Self {
        StructuredQuery_UnaryFilter_Operator::OPERATOR_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_UnaryFilter_Operator {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_Order {
    // message fields
    pub field: ::protobuf::SingularPtrField<StructuredQuery_FieldReference>,
    pub direction: StructuredQuery_Direction,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_Order {
    pub fn new() -> StructuredQuery_Order {
        ::std::default::Default::default()
    }

    // .google.firestore.v1beta1.StructuredQuery.FieldReference field = 1;

    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: StructuredQuery_FieldReference) {
        self.field = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut StructuredQuery_FieldReference {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> StructuredQuery_FieldReference {
        self.field.take().unwrap_or_else(|| StructuredQuery_FieldReference::new())
    }

    pub fn get_field(&self) -> &StructuredQuery_FieldReference {
        self.field.as_ref().unwrap_or_else(|| StructuredQuery_FieldReference::default_instance())
    }

    // .google.firestore.v1beta1.StructuredQuery.Direction direction = 2;

    pub fn clear_direction(&mut self) {
        self.direction = StructuredQuery_Direction::DIRECTION_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: StructuredQuery_Direction) {
        self.direction = v;
    }

    pub fn get_direction(&self) -> StructuredQuery_Direction {
        self.direction
    }
}

impl ::protobuf::Message for StructuredQuery_Order {
    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.direction, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.direction != StructuredQuery_Direction::DIRECTION_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(2, self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.direction != StructuredQuery_Direction::DIRECTION_UNSPECIFIED {
            os.write_enum(2, self.direction.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_Order {
        StructuredQuery_Order::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_FieldReference>>(
                    "field",
                    |m: &StructuredQuery_Order| { &m.field },
                    |m: &mut StructuredQuery_Order| { &mut m.field },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StructuredQuery_Direction>>(
                    "direction",
                    |m: &StructuredQuery_Order| { &m.direction },
                    |m: &mut StructuredQuery_Order| { &mut m.direction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_Order>(
                    "StructuredQuery_Order",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_Order {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_Order> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_Order,
        };
        unsafe {
            instance.get(StructuredQuery_Order::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_Order {
    fn clear(&mut self) {
        self.clear_field();
        self.clear_direction();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_Order {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_Order {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_FieldReference {
    // message fields
    pub field_path: ::std::string::String,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_FieldReference {
    pub fn new() -> StructuredQuery_FieldReference {
        ::std::default::Default::default()
    }

    // string field_path = 2;

    pub fn clear_field_path(&mut self) {
        self.field_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_path(&mut self, v: ::std::string::String) {
        self.field_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_path(&mut self) -> &mut ::std::string::String {
        &mut self.field_path
    }

    // Take field
    pub fn take_field_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_path, ::std::string::String::new())
    }

    pub fn get_field_path(&self) -> &str {
        &self.field_path
    }
}

impl ::protobuf::Message for StructuredQuery_FieldReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.field_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.field_path.is_empty() {
            os.write_string(2, &self.field_path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_FieldReference {
        StructuredQuery_FieldReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "field_path",
                    |m: &StructuredQuery_FieldReference| { &m.field_path },
                    |m: &mut StructuredQuery_FieldReference| { &mut m.field_path },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_FieldReference>(
                    "StructuredQuery_FieldReference",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_FieldReference {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_FieldReference> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_FieldReference,
        };
        unsafe {
            instance.get(StructuredQuery_FieldReference::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_FieldReference {
    fn clear(&mut self) {
        self.clear_field_path();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_FieldReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_FieldReference {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StructuredQuery_Projection {
    // message fields
    pub fields: ::protobuf::RepeatedField<StructuredQuery_FieldReference>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl StructuredQuery_Projection {
    pub fn new() -> StructuredQuery_Projection {
        ::std::default::Default::default()
    }

    // repeated .google.firestore.v1beta1.StructuredQuery.FieldReference fields = 2;

    pub fn clear_fields(&mut self) {
        self.fields.clear();
    }

    // Param is passed by value, moved
    pub fn set_fields(&mut self, v: ::protobuf::RepeatedField<StructuredQuery_FieldReference>) {
        self.fields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fields(&mut self) -> &mut ::protobuf::RepeatedField<StructuredQuery_FieldReference> {
        &mut self.fields
    }

    // Take field
    pub fn take_fields(&mut self) -> ::protobuf::RepeatedField<StructuredQuery_FieldReference> {
        ::std::mem::replace(&mut self.fields, ::protobuf::RepeatedField::new())
    }

    pub fn get_fields(&self) -> &[StructuredQuery_FieldReference] {
        &self.fields
    }
}

impl ::protobuf::Message for StructuredQuery_Projection {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StructuredQuery_Projection {
        StructuredQuery_Projection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StructuredQuery_FieldReference>>(
                    "fields",
                    |m: &StructuredQuery_Projection| { &m.fields },
                    |m: &mut StructuredQuery_Projection| { &mut m.fields },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StructuredQuery_Projection>(
                    "StructuredQuery_Projection",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StructuredQuery_Projection {
        static mut instance: ::protobuf::lazy::Lazy<StructuredQuery_Projection> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StructuredQuery_Projection,
        };
        unsafe {
            instance.get(StructuredQuery_Projection::new)
        }
    }
}

impl ::protobuf::Clear for StructuredQuery_Projection {
    fn clear(&mut self) {
        self.clear_fields();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StructuredQuery_Projection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_Projection {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StructuredQuery_Direction {
    DIRECTION_UNSPECIFIED = 0,
    ASCENDING = 1,
    DESCENDING = 2,
}

impl ::protobuf::ProtobufEnum for StructuredQuery_Direction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StructuredQuery_Direction> {
        match value {
            0 => ::std::option::Option::Some(StructuredQuery_Direction::DIRECTION_UNSPECIFIED),
            1 => ::std::option::Option::Some(StructuredQuery_Direction::ASCENDING),
            2 => ::std::option::Option::Some(StructuredQuery_Direction::DESCENDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StructuredQuery_Direction] = &[
            StructuredQuery_Direction::DIRECTION_UNSPECIFIED,
            StructuredQuery_Direction::ASCENDING,
            StructuredQuery_Direction::DESCENDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StructuredQuery_Direction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StructuredQuery_Direction {
}

impl ::std::default::Default for StructuredQuery_Direction {
    fn default() -> Self {
        StructuredQuery_Direction::DIRECTION_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for StructuredQuery_Direction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cursor {
    // message fields
    pub values: ::protobuf::RepeatedField<super::document::Value>,
    pub before: bool,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl Cursor {
    pub fn new() -> Cursor {
        ::std::default::Default::default()
    }

    // repeated .google.firestore.v1beta1.Value values = 1;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<super::document::Value>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<super::document::Value> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<super::document::Value> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values(&self) -> &[super::document::Value] {
        &self.values
    }

    // bool before = 2;

    pub fn clear_before(&mut self) {
        self.before = false;
    }

    // Param is passed by value, moved
    pub fn set_before(&mut self, v: bool) {
        self.before = v;
    }

    pub fn get_before(&self) -> bool {
        self.before
    }
}

impl ::protobuf::Message for Cursor {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.before = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.before != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.values {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.before != false {
            os.write_bool(2, self.before)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cursor {
        Cursor::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::document::Value>>(
                    "values",
                    |m: &Cursor| { &m.values },
                    |m: &mut Cursor| { &mut m.values },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "before",
                    |m: &Cursor| { &m.before },
                    |m: &mut Cursor| { &mut m.before },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cursor>(
                    "Cursor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cursor {
        static mut instance: ::protobuf::lazy::Lazy<Cursor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cursor,
        };
        unsafe {
            instance.get(Cursor::new)
        }
    }
}

impl ::protobuf::Clear for Cursor {
    fn clear(&mut self) {
        self.clear_values();
        self.clear_before();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cursor {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$google/firestore/v1beta1/query.proto\x12\x18google.firestore.v1beta1\
    \x1a\x1cgoogle/api/annotations.proto\x1a'google/firestore/v1beta1/docume\
    nt.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x8e\x11\n\x0fStructured\
    Query\x12L\n\x06select\x18\x01\x20\x01(\x0b24.google.firestore.v1beta1.S\
    tructuredQuery.ProjectionR\x06select\x12P\n\x04from\x18\x02\x20\x03(\x0b\
    2<.google.firestore.v1beta1.StructuredQuery.CollectionSelectorR\x04from\
    \x12F\n\x05where\x18\x03\x20\x01(\x0b20.google.firestore.v1beta1.Structu\
    redQuery.FilterR\x05where\x12J\n\x08order_by\x18\x04\x20\x03(\x0b2/.goog\
    le.firestore.v1beta1.StructuredQuery.OrderR\x07orderBy\x12;\n\x08start_a\
    t\x18\x07\x20\x01(\x0b2\x20.google.firestore.v1beta1.CursorR\x07startAt\
    \x127\n\x06end_at\x18\x08\x20\x01(\x0b2\x20.google.firestore.v1beta1.Cur\
    sorR\x05endAt\x12\x16\n\x06offset\x18\x06\x20\x01(\x05R\x06offset\x121\n\
    \x05limit\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x05limit\
    \x1ab\n\x12CollectionSelector\x12#\n\rcollection_id\x18\x02\x20\x01(\tR\
    \x0ccollectionId\x12'\n\x0fall_descendants\x18\x03\x20\x01(\x08R\x0eallD\
    escendants\x1a\xb7\x02\n\x06Filter\x12f\n\x10composite_filter\x18\x01\
    \x20\x01(\x0b29.google.firestore.v1beta1.StructuredQuery.CompositeFilter\
    H\0R\x0fcompositeFilter\x12Z\n\x0cfield_filter\x18\x02\x20\x01(\x0b25.go\
    ogle.firestore.v1beta1.StructuredQuery.FieldFilterH\0R\x0bfieldFilter\
    \x12Z\n\x0cunary_filter\x18\x03\x20\x01(\x0b25.google.firestore.v1beta1.\
    StructuredQuery.UnaryFilterH\0R\x0bunaryFilterB\r\n\x0bfilter_type\x1a\
    \xe0\x01\n\x0fCompositeFilter\x12R\n\x02op\x18\x01\x20\x01(\x0e2B.google\
    .firestore.v1beta1.StructuredQuery.CompositeFilter.OperatorR\x02op\x12J\
    \n\x07filters\x18\x02\x20\x03(\x0b20.google.firestore.v1beta1.Structured\
    Query.FilterR\x07filters\"-\n\x08Operator\x12\x18\n\x14OPERATOR_UNSPECIF\
    IED\x10\0\x12\x07\n\x03AND\x10\x01\x1a\xfe\x02\n\x0bFieldFilter\x12N\n\
    \x05field\x18\x01\x20\x01(\x0b28.google.firestore.v1beta1.StructuredQuer\
    y.FieldReferenceR\x05field\x12N\n\x02op\x18\x02\x20\x01(\x0e2>.google.fi\
    restore.v1beta1.StructuredQuery.FieldFilter.OperatorR\x02op\x125\n\x05va\
    lue\x18\x03\x20\x01(\x0b2\x1f.google.firestore.v1beta1.ValueR\x05value\"\
    \x97\x01\n\x08Operator\x12\x18\n\x14OPERATOR_UNSPECIFIED\x10\0\x12\r\n\t\
    LESS_THAN\x10\x01\x12\x16\n\x12LESS_THAN_OR_EQUAL\x10\x02\x12\x10\n\x0cG\
    REATER_THAN\x10\x03\x12\x19\n\x15GREATER_THAN_OR_EQUAL\x10\x04\x12\t\n\
    \x05EQUAL\x10\x05\x12\x12\n\x0eARRAY_CONTAINS\x10\x07\x1a\xfe\x01\n\x0bU\
    naryFilter\x12N\n\x02op\x18\x01\x20\x01(\x0e2>.google.firestore.v1beta1.\
    StructuredQuery.UnaryFilter.OperatorR\x02op\x12P\n\x05field\x18\x02\x20\
    \x01(\x0b28.google.firestore.v1beta1.StructuredQuery.FieldReferenceH\0R\
    \x05field\"=\n\x08Operator\x12\x18\n\x14OPERATOR_UNSPECIFIED\x10\0\x12\n\
    \n\x06IS_NAN\x10\x02\x12\x0b\n\x07IS_NULL\x10\x03B\x0e\n\x0coperand_type\
    \x1a\xaa\x01\n\x05Order\x12N\n\x05field\x18\x01\x20\x01(\x0b28.google.fi\
    restore.v1beta1.StructuredQuery.FieldReferenceR\x05field\x12Q\n\tdirecti\
    on\x18\x02\x20\x01(\x0e23.google.firestore.v1beta1.StructuredQuery.Direc\
    tionR\tdirection\x1a/\n\x0eFieldReference\x12\x1d\n\nfield_path\x18\x02\
    \x20\x01(\tR\tfieldPath\x1a^\n\nProjection\x12P\n\x06fields\x18\x02\x20\
    \x03(\x0b28.google.firestore.v1beta1.StructuredQuery.FieldReferenceR\x06\
    fields\"E\n\tDirection\x12\x19\n\x15DIRECTION_UNSPECIFIED\x10\0\x12\r\n\
    \tASCENDING\x10\x01\x12\x0e\n\nDESCENDING\x10\x02\"Y\n\x06Cursor\x127\n\
    \x06values\x18\x01\x20\x03(\x0b2\x1f.google.firestore.v1beta1.ValueR\x06\
    values\x12\x16\n\x06before\x18\x02\x20\x01(\x08R\x06beforeB\xb8\x01\n\
    \x1ccom.google.firestore.v1beta1B\nQueryProtoP\x01ZAgoogle.golang.org/ge\
    nproto/googleapis/firestore/v1beta1;firestore\xa2\x02\x04GCFS\xaa\x02\
    \x1eGoogle.Cloud.Firestore.V1Beta1\xca\x02\x1eGoogle\\Cloud\\Firestore\\\
    V1beta1J\xc6>\n\x07\x12\x05\x0e\0\xea\x01\x01\n\xbc\x04\n\x01\x0c\x12\
    \x03\x0e\0\x122\xb1\x04\x20Copyright\x202018\x20Google\x20LLC\n\n\x20Lic\
    ensed\x20under\x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\
    \x20\"License\");\n\x20you\x20may\x20not\x20use\x20this\x20file\x20excep\
    t\x20in\x20compliance\x20with\x20the\x20License.\n\x20You\x20may\x20obta\
    in\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\x20\x20\x20\x20\x20htt\
    p://www.apache.org/licenses/LICENSE-2.0\n\n\x20Unless\x20required\x20by\
    \x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20writing,\x20softwar\
    e\n\x20distributed\x20under\x20the\x20License\x20is\x20distributed\x20on\
    \x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20WARRANTIES\x20OR\x20CON\
    DITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\x20implied.\n\
    \x20See\x20the\x20License\x20for\x20the\x20specific\x20language\x20gover\
    ning\x20permissions\x20and\n\x20limitations\x20under\x20the\x20License.\
    \n\n\x08\n\x01\x02\x12\x03\x10\x08\x20\n\t\n\x02\x03\0\x12\x03\x12\x07%\
    \n\t\n\x02\x03\x01\x12\x03\x13\x070\n\t\n\x02\x03\x02\x12\x03\x14\x07'\n\
    \x08\n\x01\x08\x12\x03\x16\0;\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x16\0;\n\
    \x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x16\x07\x17\n\r\n\x06\x08\xe7\x07\0\
    \x02\0\x12\x03\x16\x07\x17\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\
    \x16\x07\x17\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x16\x1a:\n\x08\n\x01\
    \x08\x12\x03\x17\0X\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x17\0X\n\x0c\n\
    \x05\x08\xe7\x07\x01\x02\x12\x03\x17\x07\x11\n\r\n\x06\x08\xe7\x07\x01\
    \x02\0\x12\x03\x17\x07\x11\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\
    \x17\x07\x11\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x17\x14W\n\x08\n\
    \x01\x08\x12\x03\x18\0\"\n\x0b\n\x04\x08\xe7\x07\x02\x12\x03\x18\0\"\n\
    \x0c\n\x05\x08\xe7\x07\x02\x02\x12\x03\x18\x07\x1a\n\r\n\x06\x08\xe7\x07\
    \x02\x02\0\x12\x03\x18\x07\x1a\n\x0e\n\x07\x08\xe7\x07\x02\x02\0\x01\x12\
    \x03\x18\x07\x1a\n\x0c\n\x05\x08\xe7\x07\x02\x03\x12\x03\x18\x1d!\n\x08\
    \n\x01\x08\x12\x03\x19\0+\n\x0b\n\x04\x08\xe7\x07\x03\x12\x03\x19\0+\n\
    \x0c\n\x05\x08\xe7\x07\x03\x02\x12\x03\x19\x07\x1b\n\r\n\x06\x08\xe7\x07\
    \x03\x02\0\x12\x03\x19\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x03\x02\0\x01\x12\
    \x03\x19\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x03\x07\x12\x03\x19\x1e*\n\x08\
    \n\x01\x08\x12\x03\x1a\05\n\x0b\n\x04\x08\xe7\x07\x04\x12\x03\x1a\05\n\
    \x0c\n\x05\x08\xe7\x07\x04\x02\x12\x03\x1a\x07\x13\n\r\n\x06\x08\xe7\x07\
    \x04\x02\0\x12\x03\x1a\x07\x13\n\x0e\n\x07\x08\xe7\x07\x04\x02\0\x01\x12\
    \x03\x1a\x07\x13\n\x0c\n\x05\x08\xe7\x07\x04\x07\x12\x03\x1a\x164\n\x08\
    \n\x01\x08\x12\x03\x1b\0\"\n\x0b\n\x04\x08\xe7\x07\x05\x12\x03\x1b\0\"\n\
    \x0c\n\x05\x08\xe7\x07\x05\x02\x12\x03\x1b\x07\x18\n\r\n\x06\x08\xe7\x07\
    \x05\x02\0\x12\x03\x1b\x07\x18\n\x0e\n\x07\x08\xe7\x07\x05\x02\0\x01\x12\
    \x03\x1b\x07\x18\n\x0c\n\x05\x08\xe7\x07\x05\x07\x12\x03\x1b\x1b!\n\x08\
    \n\x01\x08\x12\x03\x1c\0;\n\x0b\n\x04\x08\xe7\x07\x06\x12\x03\x1c\0;\n\
    \x0c\n\x05\x08\xe7\x07\x06\x02\x12\x03\x1c\x07\x14\n\r\n\x06\x08\xe7\x07\
    \x06\x02\0\x12\x03\x1c\x07\x14\n\x0e\n\x07\x08\xe7\x07\x06\x02\0\x01\x12\
    \x03\x1c\x07\x14\n\x0c\n\x05\x08\xe7\x07\x06\x07\x12\x03\x1c\x17:\n!\n\
    \x02\x04\0\x12\x05\x20\0\xdd\x01\x01\x1a\x14\x20A\x20Firestore\x20query.\
    \n\n\n\n\x03\x04\0\x01\x12\x03\x20\x08\x17\nF\n\x04\x04\0\x03\0\x12\x04\
    \"\x02+\x03\x1a8\x20A\x20selection\x20of\x20a\x20collection,\x20such\x20\
    as\x20`messages\x20as\x20m1`.\n\n\x0c\n\x05\x04\0\x03\0\x01\x12\x03\"\n\
    \x1c\nU\n\x06\x04\0\x03\0\x02\0\x12\x03%\x04\x1d\x1aF\x20The\x20collecti\
    on\x20ID.\n\x20When\x20set,\x20selects\x20only\x20collections\x20with\
    \x20this\x20ID.\n\n\x0f\n\x07\x04\0\x03\0\x02\0\x04\x12\x04%\x04\"\x1e\n\
    \x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03%\x04\n\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x01\x12\x03%\x0b\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03%\
    \x1b\x1c\n\xc2\x01\n\x06\x04\0\x03\0\x02\x01\x12\x03*\x04\x1d\x1a\xb2\
    \x01\x20When\x20false,\x20selects\x20only\x20collections\x20that\x20are\
    \x20immediate\x20children\x20of\n\x20the\x20`parent`\x20specified\x20in\
    \x20the\x20containing\x20`RunQueryRequest`.\n\x20When\x20true,\x20select\
    s\x20all\x20descendant\x20collections.\n\n\x0f\n\x07\x04\0\x03\0\x02\x01\
    \x04\x12\x04*\x04%\x1d\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03*\x04\
    \x08\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03*\t\x18\n\x0e\n\x07\x04\
    \0\x03\0\x02\x01\x03\x12\x03*\x1b\x1c\n\x19\n\x04\x04\0\x03\x01\x12\x04.\
    \x02:\x03\x1a\x0b\x20A\x20filter.\n\n\x0c\n\x05\x04\0\x03\x01\x01\x12\
    \x03.\n\x10\n%\n\x06\x04\0\x03\x01\x08\0\x12\x040\x049\x05\x1a\x15\x20Th\
    e\x20type\x20of\x20filter.\n\n\x0e\n\x07\x04\0\x03\x01\x08\0\x01\x12\x03\
    0\n\x15\n$\n\x06\x04\0\x03\x01\x02\0\x12\x032\x06+\x1a\x15\x20A\x20compo\
    site\x20filter.\n\n\x0e\n\x07\x04\0\x03\x01\x02\0\x06\x12\x032\x06\x15\n\
    \x0e\n\x07\x04\0\x03\x01\x02\0\x01\x12\x032\x16&\n\x0e\n\x07\x04\0\x03\
    \x01\x02\0\x03\x12\x032)*\n.\n\x06\x04\0\x03\x01\x02\x01\x12\x035\x06#\
    \x1a\x1f\x20A\x20filter\x20on\x20a\x20document\x20field.\n\n\x0e\n\x07\
    \x04\0\x03\x01\x02\x01\x06\x12\x035\x06\x11\n\x0e\n\x07\x04\0\x03\x01\
    \x02\x01\x01\x12\x035\x12\x1e\n\x0e\n\x07\x04\0\x03\x01\x02\x01\x03\x12\
    \x035!\"\n:\n\x06\x04\0\x03\x01\x02\x02\x12\x038\x06#\x1a+\x20A\x20filte\
    r\x20that\x20takes\x20exactly\x20one\x20argument.\n\n\x0e\n\x07\x04\0\
    \x03\x01\x02\x02\x06\x12\x038\x06\x11\n\x0e\n\x07\x04\0\x03\x01\x02\x02\
    \x01\x12\x038\x12\x1e\n\x0e\n\x07\x04\0\x03\x01\x02\x02\x03\x12\x038!\"\
    \nU\n\x04\x04\0\x03\x02\x12\x04=\x02M\x03\x1aG\x20A\x20filter\x20that\
    \x20merges\x20multiple\x20other\x20filters\x20using\x20the\x20given\x20o\
    perator.\n\n\x0c\n\x05\x04\0\x03\x02\x01\x12\x03=\n\x19\n.\n\x06\x04\0\
    \x03\x02\x04\0\x12\x04?\x04E\x05\x1a\x1e\x20A\x20composite\x20filter\x20\
    operator.\n\n\x0e\n\x07\x04\0\x03\x02\x04\0\x01\x12\x03?\t\x11\n<\n\x08\
    \x04\0\x03\x02\x04\0\x02\0\x12\x03A\x06\x1f\x1a+\x20Unspecified.\x20This\
    \x20value\x20must\x20not\x20be\x20used.\n\n\x10\n\t\x04\0\x03\x02\x04\0\
    \x02\0\x01\x12\x03A\x06\x1a\n\x10\n\t\x04\0\x03\x02\x04\0\x02\0\x02\x12\
    \x03A\x1d\x1e\nT\n\x08\x04\0\x03\x02\x04\0\x02\x01\x12\x03D\x06\x0e\x1aC\
    \x20The\x20results\x20are\x20required\x20to\x20satisfy\x20each\x20of\x20\
    the\x20combined\x20filters.\n\n\x10\n\t\x04\0\x03\x02\x04\0\x02\x01\x01\
    \x12\x03D\x06\t\n\x10\n\t\x04\0\x03\x02\x04\0\x02\x01\x02\x12\x03D\x0c\r\
    \n=\n\x06\x04\0\x03\x02\x02\0\x12\x03H\x04\x14\x1a.\x20The\x20operator\
    \x20for\x20combining\x20multiple\x20filters.\n\n\x0f\n\x07\x04\0\x03\x02\
    \x02\0\x04\x12\x04H\x04E\x05\n\x0e\n\x07\x04\0\x03\x02\x02\0\x06\x12\x03\
    H\x04\x0c\n\x0e\n\x07\x04\0\x03\x02\x02\0\x01\x12\x03H\r\x0f\n\x0e\n\x07\
    \x04\0\x03\x02\x02\0\x03\x12\x03H\x12\x13\nS\n\x06\x04\0\x03\x02\x02\x01\
    \x12\x03L\x04\x20\x1aD\x20The\x20list\x20of\x20filters\x20to\x20combine.\
    \n\x20Must\x20contain\x20at\x20least\x20one\x20filter.\n\n\x0e\n\x07\x04\
    \0\x03\x02\x02\x01\x04\x12\x03L\x04\x0c\n\x0e\n\x07\x04\0\x03\x02\x02\
    \x01\x06\x12\x03L\r\x13\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x01\x12\x03L\
    \x14\x1b\n\x0e\n\x07\x04\0\x03\x02\x02\x01\x03\x12\x03L\x1e\x1f\n-\n\x04\
    \x04\0\x03\x03\x12\x04P\x02r\x03\x1a\x1f\x20A\x20filter\x20on\x20a\x20sp\
    ecific\x20field.\n\n\x0c\n\x05\x04\0\x03\x03\x01\x12\x03P\n\x15\n*\n\x06\
    \x04\0\x03\x03\x04\0\x12\x04R\x04h\x05\x1a\x1a\x20A\x20field\x20filter\
    \x20operator.\n\n\x0e\n\x07\x04\0\x03\x03\x04\0\x01\x12\x03R\t\x11\n<\n\
    \x08\x04\0\x03\x03\x04\0\x02\0\x12\x03T\x06\x1f\x1a+\x20Unspecified.\x20\
    This\x20value\x20must\x20not\x20be\x20used.\n\n\x10\n\t\x04\0\x03\x03\
    \x04\0\x02\0\x01\x12\x03T\x06\x1a\n\x10\n\t\x04\0\x03\x03\x04\0\x02\0\
    \x02\x12\x03T\x1d\x1e\nO\n\x08\x04\0\x03\x03\x04\0\x02\x01\x12\x03W\x06\
    \x14\x1a>\x20Less\x20than.\x20Requires\x20that\x20the\x20field\x20come\
    \x20first\x20in\x20`order_by`.\n\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x01\
    \x01\x12\x03W\x06\x0f\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x01\x02\x12\x03W\
    \x12\x13\nX\n\x08\x04\0\x03\x03\x04\0\x02\x02\x12\x03Z\x06\x1d\x1aG\x20L\
    ess\x20than\x20or\x20equal.\x20Requires\x20that\x20the\x20field\x20come\
    \x20first\x20in\x20`order_by`.\n\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x02\
    \x01\x12\x03Z\x06\x18\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x02\x02\x12\x03Z\
    \x1b\x1c\nR\n\x08\x04\0\x03\x03\x04\0\x02\x03\x12\x03]\x06\x17\x1aA\x20G\
    reater\x20than.\x20Requires\x20that\x20the\x20field\x20come\x20first\x20\
    in\x20`order_by`.\n\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x03\x01\x12\x03]\
    \x06\x12\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x03\x02\x12\x03]\x15\x16\n\\\
    \n\x08\x04\0\x03\x03\x04\0\x02\x04\x12\x03a\x06\x20\x1aK\x20Greater\x20t\
    han\x20or\x20equal.\x20Requires\x20that\x20the\x20field\x20come\x20first\
    \x20in\n\x20`order_by`.\n\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x04\x01\x12\
    \x03a\x06\x1b\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x04\x02\x12\x03a\x1e\x1f\
    \n\x19\n\x08\x04\0\x03\x03\x04\0\x02\x05\x12\x03d\x06\x10\x1a\x08\x20Equ\
    al.\n\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x05\x01\x12\x03d\x06\x0b\n\x10\n\
    \t\x04\0\x03\x03\x04\0\x02\x05\x02\x12\x03d\x0e\x0f\nA\n\x08\x04\0\x03\
    \x03\x04\0\x02\x06\x12\x03g\x06\x19\x1a0\x20Contains.\x20Requires\x20tha\
    t\x20the\x20field\x20is\x20an\x20array.\n\n\x10\n\t\x04\0\x03\x03\x04\0\
    \x02\x06\x01\x12\x03g\x06\x14\n\x10\n\t\x04\0\x03\x03\x04\0\x02\x06\x02\
    \x12\x03g\x17\x18\n(\n\x06\x04\0\x03\x03\x02\0\x12\x03k\x04\x1d\x1a\x19\
    \x20The\x20field\x20to\x20filter\x20by.\n\n\x0f\n\x07\x04\0\x03\x03\x02\
    \0\x04\x12\x04k\x04h\x05\n\x0e\n\x07\x04\0\x03\x03\x02\0\x06\x12\x03k\
    \x04\x12\n\x0e\n\x07\x04\0\x03\x03\x02\0\x01\x12\x03k\x13\x18\n\x0e\n\
    \x07\x04\0\x03\x03\x02\0\x03\x12\x03k\x1b\x1c\n+\n\x06\x04\0\x03\x03\x02\
    \x01\x12\x03n\x04\x14\x1a\x1c\x20The\x20operator\x20to\x20filter\x20by.\
    \n\n\x0f\n\x07\x04\0\x03\x03\x02\x01\x04\x12\x04n\x04k\x1d\n\x0e\n\x07\
    \x04\0\x03\x03\x02\x01\x06\x12\x03n\x04\x0c\n\x0e\n\x07\x04\0\x03\x03\
    \x02\x01\x01\x12\x03n\r\x0f\n\x0e\n\x07\x04\0\x03\x03\x02\x01\x03\x12\
    \x03n\x12\x13\n)\n\x06\x04\0\x03\x03\x02\x02\x12\x03q\x04\x14\x1a\x1a\
    \x20The\x20value\x20to\x20compare\x20to.\n\n\x0f\n\x07\x04\0\x03\x03\x02\
    \x02\x04\x12\x04q\x04n\x14\n\x0e\n\x07\x04\0\x03\x03\x02\x02\x06\x12\x03\
    q\x04\t\n\x0e\n\x07\x04\0\x03\x03\x02\x02\x01\x12\x03q\n\x0f\n\x0e\n\x07\
    \x04\0\x03\x03\x02\x02\x03\x12\x03q\x12\x13\n0\n\x04\x04\0\x03\x04\x12\
    \x05u\x02\x8a\x01\x03\x1a!\x20A\x20filter\x20with\x20a\x20single\x20oper\
    and.\n\n\x0c\n\x05\x04\0\x03\x04\x01\x12\x03u\n\x15\n$\n\x06\x04\0\x03\
    \x04\x04\0\x12\x05w\x04\x80\x01\x05\x1a\x13\x20A\x20unary\x20operator.\n\
    \n\x0e\n\x07\x04\0\x03\x04\x04\0\x01\x12\x03w\t\x11\n<\n\x08\x04\0\x03\
    \x04\x04\0\x02\0\x12\x03y\x06\x1f\x1a+\x20Unspecified.\x20This\x20value\
    \x20must\x20not\x20be\x20used.\n\n\x10\n\t\x04\0\x03\x04\x04\0\x02\0\x01\
    \x12\x03y\x06\x1a\n\x10\n\t\x04\0\x03\x04\x04\0\x02\0\x02\x12\x03y\x1d\
    \x1e\n3\n\x08\x04\0\x03\x04\x04\0\x02\x01\x12\x03|\x06\x11\x1a\"\x20Test\
    \x20if\x20a\x20field\x20is\x20equal\x20to\x20NaN.\n\n\x10\n\t\x04\0\x03\
    \x04\x04\0\x02\x01\x01\x12\x03|\x06\x0c\n\x10\n\t\x04\0\x03\x04\x04\0\
    \x02\x01\x02\x12\x03|\x0f\x10\n;\n\x08\x04\0\x03\x04\x04\0\x02\x02\x12\
    \x03\x7f\x06\x12\x1a*\x20Test\x20if\x20an\x20exprestion\x20evaluates\x20\
    to\x20Null.\n\n\x10\n\t\x04\0\x03\x04\x04\0\x02\x02\x01\x12\x03\x7f\x06\
    \r\n\x10\n\t\x04\0\x03\x04\x04\0\x02\x02\x02\x12\x03\x7f\x10\x11\n.\n\
    \x06\x04\0\x03\x04\x02\0\x12\x04\x83\x01\x04\x14\x1a\x1e\x20The\x20unary\
    \x20operator\x20to\x20apply.\n\n\x11\n\x07\x04\0\x03\x04\x02\0\x04\x12\
    \x06\x83\x01\x04\x80\x01\x05\n\x0f\n\x07\x04\0\x03\x04\x02\0\x06\x12\x04\
    \x83\x01\x04\x0c\n\x0f\n\x07\x04\0\x03\x04\x02\0\x01\x12\x04\x83\x01\r\
    \x0f\n\x0f\n\x07\x04\0\x03\x04\x02\0\x03\x12\x04\x83\x01\x12\x13\n/\n\
    \x06\x04\0\x03\x04\x08\0\x12\x06\x86\x01\x04\x89\x01\x05\x1a\x1d\x20The\
    \x20argument\x20to\x20the\x20filter.\n\n\x0f\n\x07\x04\0\x03\x04\x08\0\
    \x01\x12\x04\x86\x01\n\x16\n;\n\x06\x04\0\x03\x04\x02\x01\x12\x04\x88\
    \x01\x06\x1f\x1a+\x20The\x20field\x20to\x20which\x20to\x20apply\x20the\
    \x20operator.\n\n\x0f\n\x07\x04\0\x03\x04\x02\x01\x06\x12\x04\x88\x01\
    \x06\x14\n\x0f\n\x07\x04\0\x03\x04\x02\x01\x01\x12\x04\x88\x01\x15\x1a\n\
    \x0f\n\x07\x04\0\x03\x04\x02\x01\x03\x12\x04\x88\x01\x1d\x1e\n&\n\x04\
    \x04\0\x03\x05\x12\x06\x8d\x01\x02\x93\x01\x03\x1a\x16\x20An\x20order\
    \x20on\x20a\x20field.\n\n\r\n\x05\x04\0\x03\x05\x01\x12\x04\x8d\x01\n\
    \x0f\n(\n\x06\x04\0\x03\x05\x02\0\x12\x04\x8f\x01\x04\x1d\x1a\x18\x20The\
    \x20field\x20to\x20order\x20by.\n\n\x11\n\x07\x04\0\x03\x05\x02\0\x04\
    \x12\x06\x8f\x01\x04\x8d\x01\x11\n\x0f\n\x07\x04\0\x03\x05\x02\0\x06\x12\
    \x04\x8f\x01\x04\x12\n\x0f\n\x07\x04\0\x03\x05\x02\0\x01\x12\x04\x8f\x01\
    \x13\x18\n\x0f\n\x07\x04\0\x03\x05\x02\0\x03\x12\x04\x8f\x01\x1b\x1c\nE\
    \n\x06\x04\0\x03\x05\x02\x01\x12\x04\x92\x01\x04\x1c\x1a5\x20The\x20dire\
    ction\x20to\x20order\x20by.\x20Defaults\x20to\x20`ASCENDING`.\n\n\x11\n\
    \x07\x04\0\x03\x05\x02\x01\x04\x12\x06\x92\x01\x04\x8f\x01\x1d\n\x0f\n\
    \x07\x04\0\x03\x05\x02\x01\x06\x12\x04\x92\x01\x04\r\n\x0f\n\x07\x04\0\
    \x03\x05\x02\x01\x01\x12\x04\x92\x01\x0e\x17\n\x0f\n\x07\x04\0\x03\x05\
    \x02\x01\x03\x12\x04\x92\x01\x1a\x1b\nS\n\x04\x04\0\x03\x06\x12\x06\x96\
    \x01\x02\x98\x01\x03\x1aC\x20A\x20reference\x20to\x20a\x20field,\x20such\
    \x20as\x20`max(messages.time)\x20as\x20max_time`.\n\n\r\n\x05\x04\0\x03\
    \x06\x01\x12\x04\x96\x01\n\x18\n\x0e\n\x06\x04\0\x03\x06\x02\0\x12\x04\
    \x97\x01\x04\x1a\n\x11\n\x07\x04\0\x03\x06\x02\0\x04\x12\x06\x97\x01\x04\
    \x96\x01\x1a\n\x0f\n\x07\x04\0\x03\x06\x02\0\x05\x12\x04\x97\x01\x04\n\n\
    \x0f\n\x07\x04\0\x03\x06\x02\0\x01\x12\x04\x97\x01\x0b\x15\n\x0f\n\x07\
    \x04\0\x03\x06\x02\0\x03\x12\x04\x97\x01\x18\x19\n@\n\x04\x04\0\x03\x07\
    \x12\x06\x9b\x01\x02\xa1\x01\x03\x1a0\x20The\x20projection\x20of\x20docu\
    ment's\x20fields\x20to\x20return.\n\n\r\n\x05\x04\0\x03\x07\x01\x12\x04\
    \x9b\x01\n\x14\n\x8a\x01\n\x06\x04\0\x03\x07\x02\0\x12\x04\xa0\x01\x04'\
    \x1az\x20The\x20fields\x20to\x20return.\n\n\x20If\x20empty,\x20all\x20fi\
    elds\x20are\x20returned.\x20To\x20only\x20return\x20the\x20name\n\x20of\
    \x20the\x20document,\x20use\x20`['__name__']`.\n\n\x0f\n\x07\x04\0\x03\
    \x07\x02\0\x04\x12\x04\xa0\x01\x04\x0c\n\x0f\n\x07\x04\0\x03\x07\x02\0\
    \x06\x12\x04\xa0\x01\r\x1b\n\x0f\n\x07\x04\0\x03\x07\x02\0\x01\x12\x04\
    \xa0\x01\x1c\"\n\x0f\n\x07\x04\0\x03\x07\x02\0\x03\x12\x04\xa0\x01%&\n#\
    \n\x04\x04\0\x04\0\x12\x06\xa4\x01\x02\xad\x01\x03\x1a\x13\x20A\x20sort\
    \x20direction.\n\n\r\n\x05\x04\0\x04\0\x01\x12\x04\xa4\x01\x07\x10\n\x1e\
    \n\x06\x04\0\x04\0\x02\0\x12\x04\xa6\x01\x04\x1e\x1a\x0e\x20Unspecified.\
    \n\n\x0f\n\x07\x04\0\x04\0\x02\0\x01\x12\x04\xa6\x01\x04\x19\n\x0f\n\x07\
    \x04\0\x04\0\x02\0\x02\x12\x04\xa6\x01\x1c\x1d\n\x1c\n\x06\x04\0\x04\0\
    \x02\x01\x12\x04\xa9\x01\x04\x12\x1a\x0c\x20Ascending.\n\n\x0f\n\x07\x04\
    \0\x04\0\x02\x01\x01\x12\x04\xa9\x01\x04\r\n\x0f\n\x07\x04\0\x04\0\x02\
    \x01\x02\x12\x04\xa9\x01\x10\x11\n\x1d\n\x06\x04\0\x04\0\x02\x02\x12\x04\
    \xac\x01\x04\x13\x1a\r\x20Descending.\n\n\x0f\n\x07\x04\0\x04\0\x02\x02\
    \x01\x12\x04\xac\x01\x04\x0e\n\x0f\n\x07\x04\0\x04\0\x02\x02\x02\x12\x04\
    \xac\x01\x11\x12\n)\n\x04\x04\0\x02\0\x12\x04\xb0\x01\x02\x18\x1a\x1b\
    \x20The\x20projection\x20to\x20return.\n\n\x0f\n\x05\x04\0\x02\0\x04\x12\
    \x06\xb0\x01\x02\xad\x01\x03\n\r\n\x05\x04\0\x02\0\x06\x12\x04\xb0\x01\
    \x02\x0c\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xb0\x01\r\x13\n\r\n\x05\x04\0\
    \x02\0\x03\x12\x04\xb0\x01\x16\x17\n)\n\x04\x04\0\x02\x01\x12\x04\xb3\
    \x01\x02'\x1a\x1b\x20The\x20collections\x20to\x20query.\n\n\r\n\x05\x04\
    \0\x02\x01\x04\x12\x04\xb3\x01\x02\n\n\r\n\x05\x04\0\x02\x01\x06\x12\x04\
    \xb3\x01\x0b\x1d\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xb3\x01\x1e\"\n\r\n\
    \x05\x04\0\x02\x01\x03\x12\x04\xb3\x01%&\n$\n\x04\x04\0\x02\x02\x12\x04\
    \xb6\x01\x02\x13\x1a\x16\x20The\x20filter\x20to\x20apply.\n\n\x0f\n\x05\
    \x04\0\x02\x02\x04\x12\x06\xb6\x01\x02\xb3\x01'\n\r\n\x05\x04\0\x02\x02\
    \x06\x12\x04\xb6\x01\x02\x08\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\xb6\x01\
    \t\x0e\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xb6\x01\x11\x12\n\x96\x06\n\
    \x04\x04\0\x02\x03\x12\x04\xca\x01\x02\x1e\x1a\x87\x06\x20The\x20order\
    \x20to\x20apply\x20to\x20the\x20query\x20results.\n\n\x20Firestore\x20gu\
    arantees\x20a\x20stable\x20ordering\x20through\x20the\x20following\x20ru\
    les:\n\n\x20\x20*\x20Any\x20field\x20required\x20to\x20appear\x20in\x20`\
    order_by`,\x20that\x20is\x20not\x20already\n\x20\x20\x20\x20specified\
    \x20in\x20`order_by`,\x20is\x20appended\x20to\x20the\x20order\x20in\x20f\
    ield\x20name\x20order\n\x20\x20\x20\x20by\x20default.\n\x20\x20*\x20If\
    \x20an\x20order\x20on\x20`__name__`\x20is\x20not\x20specified,\x20it\x20\
    is\x20appended\x20by\x20default.\n\n\x20Fields\x20are\x20appended\x20wit\
    h\x20the\x20same\x20sort\x20direction\x20as\x20the\x20last\x20order\n\
    \x20specified,\x20or\x20'ASCENDING'\x20if\x20no\x20order\x20was\x20speci\
    fied.\x20For\x20example:\n\n\x20\x20*\x20`SELECT\x20*\x20FROM\x20Foo\x20\
    ORDER\x20BY\x20A`\x20becomes\n\x20\x20\x20\x20`SELECT\x20*\x20FROM\x20Fo\
    o\x20ORDER\x20BY\x20A,\x20__name__`\n\x20\x20*\x20`SELECT\x20*\x20FROM\
    \x20Foo\x20ORDER\x20BY\x20A\x20DESC`\x20becomes\n\x20\x20\x20\x20`SELECT\
    \x20*\x20FROM\x20Foo\x20ORDER\x20BY\x20A\x20DESC,\x20__name__\x20DESC`\n\
    \x20\x20*\x20`SELECT\x20*\x20FROM\x20Foo\x20WHERE\x20A\x20>\x201`\x20bec\
    omes\n\x20\x20\x20\x20`SELECT\x20*\x20FROM\x20Foo\x20WHERE\x20A\x20>\x20\
    1\x20ORDER\x20BY\x20A,\x20__name__`\n\n\r\n\x05\x04\0\x02\x03\x04\x12\
    \x04\xca\x01\x02\n\n\r\n\x05\x04\0\x02\x03\x06\x12\x04\xca\x01\x0b\x10\n\
    \r\n\x05\x04\0\x02\x03\x01\x12\x04\xca\x01\x11\x19\n\r\n\x05\x04\0\x02\
    \x03\x03\x12\x04\xca\x01\x1c\x1d\n7\n\x04\x04\0\x02\x04\x12\x04\xcd\x01\
    \x02\x16\x1a)\x20A\x20starting\x20point\x20for\x20the\x20query\x20result\
    s.\n\n\x0f\n\x05\x04\0\x02\x04\x04\x12\x06\xcd\x01\x02\xca\x01\x1e\n\r\n\
    \x05\x04\0\x02\x04\x06\x12\x04\xcd\x01\x02\x08\n\r\n\x05\x04\0\x02\x04\
    \x01\x12\x04\xcd\x01\t\x11\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xcd\x01\
    \x14\x15\n2\n\x04\x04\0\x02\x05\x12\x04\xd0\x01\x02\x14\x1a$\x20A\x20end\
    \x20point\x20for\x20the\x20query\x20results.\n\n\x0f\n\x05\x04\0\x02\x05\
    \x04\x12\x06\xd0\x01\x02\xcd\x01\x16\n\r\n\x05\x04\0\x02\x05\x06\x12\x04\
    \xd0\x01\x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xd0\x01\t\x0f\n\r\n\
    \x05\x04\0\x02\x05\x03\x12\x04\xd0\x01\x12\x13\n\x83\x01\n\x04\x04\0\x02\
    \x06\x12\x04\xd6\x01\x02\x13\x1au\x20The\x20number\x20of\x20results\x20t\
    o\x20skip.\n\n\x20Applies\x20before\x20limit,\x20but\x20after\x20all\x20\
    other\x20constraints.\x20Must\x20be\x20>=\x200\x20if\n\x20specified.\n\n\
    \x0f\n\x05\x04\0\x02\x06\x04\x12\x06\xd6\x01\x02\xd0\x01\x14\n\r\n\x05\
    \x04\0\x02\x06\x05\x12\x04\xd6\x01\x02\x07\n\r\n\x05\x04\0\x02\x06\x01\
    \x12\x04\xd6\x01\x08\x0e\n\r\n\x05\x04\0\x02\x06\x03\x12\x04\xd6\x01\x11\
    \x12\n{\n\x04\x04\0\x02\x07\x12\x04\xdc\x01\x02'\x1am\x20The\x20maximum\
    \x20number\x20of\x20results\x20to\x20return.\n\n\x20Applies\x20after\x20\
    all\x20other\x20constraints.\n\x20Must\x20be\x20>=\x200\x20if\x20specifi\
    ed.\n\n\x0f\n\x05\x04\0\x02\x07\x04\x12\x06\xdc\x01\x02\xd6\x01\x13\n\r\
    \n\x05\x04\0\x02\x07\x06\x12\x04\xdc\x01\x02\x1c\n\r\n\x05\x04\0\x02\x07\
    \x01\x12\x04\xdc\x01\x1d\"\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\xdc\x01%&\
    \n1\n\x02\x04\x01\x12\x06\xe0\x01\0\xea\x01\x01\x1a#\x20A\x20position\
    \x20in\x20a\x20query\x20result\x20set.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\
    \xe0\x01\x08\x0e\n\xb5\x01\n\x04\x04\x01\x02\0\x12\x04\xe5\x01\x02\x1c\
    \x1a\xa6\x01\x20The\x20values\x20that\x20represent\x20a\x20position,\x20\
    in\x20the\x20order\x20they\x20appear\x20in\n\x20the\x20order\x20by\x20cl\
    ause\x20of\x20a\x20query.\n\n\x20Can\x20contain\x20fewer\x20values\x20th\
    an\x20specified\x20in\x20the\x20order\x20by\x20clause.\n\n\r\n\x05\x04\
    \x01\x02\0\x04\x12\x04\xe5\x01\x02\n\n\r\n\x05\x04\x01\x02\0\x06\x12\x04\
    \xe5\x01\x0b\x10\n\r\n\x05\x04\x01\x02\0\x01\x12\x04\xe5\x01\x11\x17\n\r\
    \n\x05\x04\x01\x02\0\x03\x12\x04\xe5\x01\x1a\x1b\n\x80\x01\n\x04\x04\x01\
    \x02\x01\x12\x04\xe9\x01\x02\x12\x1ar\x20If\x20the\x20position\x20is\x20\
    just\x20before\x20or\x20just\x20after\x20the\x20given\x20values,\x20rela\
    tive\n\x20to\x20the\x20sort\x20order\x20defined\x20by\x20the\x20query.\n\
    \n\x0f\n\x05\x04\x01\x02\x01\x04\x12\x06\xe9\x01\x02\xe5\x01\x1c\n\r\n\
    \x05\x04\x01\x02\x01\x05\x12\x04\xe9\x01\x02\x06\n\r\n\x05\x04\x01\x02\
    \x01\x01\x12\x04\xe9\x01\x07\r\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xe9\
    \x01\x10\x11b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
