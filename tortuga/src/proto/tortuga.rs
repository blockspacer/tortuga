// This file is generated by rust-protobuf 2.2.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Worker {
    // message fields
    pub worker_id: ::std::string::String,
    pub uuid: ::std::string::String,
    pub capabilities: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Worker {
    pub fn new() -> Worker {
        ::std::default::Default::default()
    }

    // string worker_id = 1;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }

    // string uuid = 2;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::string::String) {
        self.uuid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid(&mut self) -> &mut ::std::string::String {
        &mut self.uuid
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uuid, ::std::string::String::new())
    }

    pub fn get_uuid(&self) -> &str {
        &self.uuid
    }

    // repeated string capabilities = 3;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.capabilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_capabilities(&self) -> &[::std::string::String] {
        &self.capabilities
    }
}

impl ::protobuf::Message for Worker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uuid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.capabilities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.worker_id);
        }
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.uuid);
        }
        for value in &self.capabilities {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.worker_id.is_empty() {
            os.write_string(1, &self.worker_id)?;
        }
        if !self.uuid.is_empty() {
            os.write_string(2, &self.uuid)?;
        }
        for v in &self.capabilities {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Worker {
        Worker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &Worker| { &m.worker_id },
                    |m: &mut Worker| { &mut m.worker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uuid",
                    |m: &Worker| { &m.uuid },
                    |m: &mut Worker| { &mut m.uuid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "capabilities",
                    |m: &Worker| { &m.capabilities },
                    |m: &mut Worker| { &mut m.capabilities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Worker>(
                    "Worker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Worker {
        static mut instance: ::protobuf::lazy::Lazy<Worker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Worker,
        };
        unsafe {
            instance.get(Worker::new)
        }
    }
}

impl ::protobuf::Clear for Worker {
    fn clear(&mut self) {
        self.clear_worker_id();
        self.clear_uuid();
        self.clear_capabilities();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Worker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Worker {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatReq {
    // message fields
    pub worker_beats: ::protobuf::RepeatedField<HeartbeatReq_WorkerBeat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HeartbeatReq {
    pub fn new() -> HeartbeatReq {
        ::std::default::Default::default()
    }

    // repeated .tortuga.HeartbeatReq.WorkerBeat worker_beats = 1;

    pub fn clear_worker_beats(&mut self) {
        self.worker_beats.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_beats(&mut self, v: ::protobuf::RepeatedField<HeartbeatReq_WorkerBeat>) {
        self.worker_beats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_worker_beats(&mut self) -> &mut ::protobuf::RepeatedField<HeartbeatReq_WorkerBeat> {
        &mut self.worker_beats
    }

    // Take field
    pub fn take_worker_beats(&mut self) -> ::protobuf::RepeatedField<HeartbeatReq_WorkerBeat> {
        ::std::mem::replace(&mut self.worker_beats, ::protobuf::RepeatedField::new())
    }

    pub fn get_worker_beats(&self) -> &[HeartbeatReq_WorkerBeat] {
        &self.worker_beats
    }
}

impl ::protobuf::Message for HeartbeatReq {
    fn is_initialized(&self) -> bool {
        for v in &self.worker_beats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.worker_beats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.worker_beats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.worker_beats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatReq {
        HeartbeatReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeartbeatReq_WorkerBeat>>(
                    "worker_beats",
                    |m: &HeartbeatReq| { &m.worker_beats },
                    |m: &mut HeartbeatReq| { &mut m.worker_beats },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HeartbeatReq>(
                    "HeartbeatReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HeartbeatReq {
        static mut instance: ::protobuf::lazy::Lazy<HeartbeatReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HeartbeatReq,
        };
        unsafe {
            instance.get(HeartbeatReq::new)
        }
    }
}

impl ::protobuf::Clear for HeartbeatReq {
    fn clear(&mut self) {
        self.clear_worker_beats();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeartbeatReq_WorkerBeat {
    // message fields
    pub worker: ::protobuf::SingularPtrField<Worker>,
    pub current_task_handles: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl HeartbeatReq_WorkerBeat {
    pub fn new() -> HeartbeatReq_WorkerBeat {
        ::std::default::Default::default()
    }

    // .tortuga.Worker worker = 1;

    pub fn clear_worker(&mut self) {
        self.worker.clear();
    }

    pub fn has_worker(&self) -> bool {
        self.worker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker(&mut self, v: Worker) {
        self.worker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker(&mut self) -> &mut Worker {
        if self.worker.is_none() {
            self.worker.set_default();
        }
        self.worker.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker(&mut self) -> Worker {
        self.worker.take().unwrap_or_else(|| Worker::new())
    }

    pub fn get_worker(&self) -> &Worker {
        self.worker.as_ref().unwrap_or_else(|| Worker::default_instance())
    }

    // repeated int64 current_task_handles = 2;

    pub fn clear_current_task_handles(&mut self) {
        self.current_task_handles.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_task_handles(&mut self, v: ::std::vec::Vec<i64>) {
        self.current_task_handles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_current_task_handles(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.current_task_handles
    }

    // Take field
    pub fn take_current_task_handles(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.current_task_handles, ::std::vec::Vec::new())
    }

    pub fn get_current_task_handles(&self) -> &[i64] {
        &self.current_task_handles
    }
}

impl ::protobuf::Message for HeartbeatReq_WorkerBeat {
    fn is_initialized(&self) -> bool {
        for v in &self.worker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.current_task_handles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.current_task_handles {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.worker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.current_task_handles {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeartbeatReq_WorkerBeat {
        HeartbeatReq_WorkerBeat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Worker>>(
                    "worker",
                    |m: &HeartbeatReq_WorkerBeat| { &m.worker },
                    |m: &mut HeartbeatReq_WorkerBeat| { &mut m.worker },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "current_task_handles",
                    |m: &HeartbeatReq_WorkerBeat| { &m.current_task_handles },
                    |m: &mut HeartbeatReq_WorkerBeat| { &mut m.current_task_handles },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HeartbeatReq_WorkerBeat>(
                    "HeartbeatReq_WorkerBeat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HeartbeatReq_WorkerBeat {
        static mut instance: ::protobuf::lazy::Lazy<HeartbeatReq_WorkerBeat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HeartbeatReq_WorkerBeat,
        };
        unsafe {
            instance.get(HeartbeatReq_WorkerBeat::new)
        }
    }
}

impl ::protobuf::Clear for HeartbeatReq_WorkerBeat {
    fn clear(&mut self) {
        self.clear_worker();
        self.clear_current_task_handles();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeartbeatReq_WorkerBeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeartbeatReq_WorkerBeat {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskReq {
    // message fields
    pub worker: ::protobuf::SingularPtrField<Worker>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskReq {
    pub fn new() -> TaskReq {
        ::std::default::Default::default()
    }

    // .tortuga.Worker worker = 1;

    pub fn clear_worker(&mut self) {
        self.worker.clear();
    }

    pub fn has_worker(&self) -> bool {
        self.worker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker(&mut self, v: Worker) {
        self.worker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker(&mut self) -> &mut Worker {
        if self.worker.is_none() {
            self.worker.set_default();
        }
        self.worker.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker(&mut self) -> Worker {
        self.worker.take().unwrap_or_else(|| Worker::new())
    }

    pub fn get_worker(&self) -> &Worker {
        self.worker.as_ref().unwrap_or_else(|| Worker::default_instance())
    }
}

impl ::protobuf::Message for TaskReq {
    fn is_initialized(&self) -> bool {
        for v in &self.worker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.worker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskReq {
        TaskReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Worker>>(
                    "worker",
                    |m: &TaskReq| { &m.worker },
                    |m: &mut TaskReq| { &mut m.worker },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskReq>(
                    "TaskReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskReq {
        static mut instance: ::protobuf::lazy::Lazy<TaskReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskReq,
        };
        unsafe {
            instance.get(TaskReq::new)
        }
    }
}

impl ::protobuf::Clear for TaskReq {
    fn clear(&mut self) {
        self.clear_worker();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskResp {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub handle: ::std::string::String,
    pub none: bool,
    pub retry_ctx: ::protobuf::SingularPtrField<TaskResp_RetryContext>,
    pub priority: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskResp {
    pub fn new() -> TaskResp {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }

    // .google.protobuf.Any data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::well_known_types::Any) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::well_known_types::Any {
        self.data.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    pub fn get_data(&self) -> &::protobuf::well_known_types::Any {
        self.data.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }

    // string handle = 4;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // bool none = 5;

    pub fn clear_none(&mut self) {
        self.none = false;
    }

    // Param is passed by value, moved
    pub fn set_none(&mut self, v: bool) {
        self.none = v;
    }

    pub fn get_none(&self) -> bool {
        self.none
    }

    // .tortuga.TaskResp.RetryContext retry_ctx = 6;

    pub fn clear_retry_ctx(&mut self) {
        self.retry_ctx.clear();
    }

    pub fn has_retry_ctx(&self) -> bool {
        self.retry_ctx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_ctx(&mut self, v: TaskResp_RetryContext) {
        self.retry_ctx = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_ctx(&mut self) -> &mut TaskResp_RetryContext {
        if self.retry_ctx.is_none() {
            self.retry_ctx.set_default();
        }
        self.retry_ctx.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_ctx(&mut self) -> TaskResp_RetryContext {
        self.retry_ctx.take().unwrap_or_else(|| TaskResp_RetryContext::new())
    }

    pub fn get_retry_ctx(&self) -> &TaskResp_RetryContext {
        self.retry_ctx.as_ref().unwrap_or_else(|| TaskResp_RetryContext::default_instance())
    }

    // int32 priority = 7;

    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = v;
    }

    pub fn get_priority(&self) -> i32 {
        self.priority
    }
}

impl ::protobuf::Message for TaskResp {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_ctx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.none = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_ctx)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.handle);
        }
        if self.none != false {
            my_size += 2;
        }
        if let Some(ref v) = self.retry_ctx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(7, self.priority, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.handle.is_empty() {
            os.write_string(4, &self.handle)?;
        }
        if self.none != false {
            os.write_bool(5, self.none)?;
        }
        if let Some(ref v) = self.retry_ctx.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.priority != 0 {
            os.write_int32(7, self.priority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskResp {
        TaskResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &TaskResp| { &m.id },
                    |m: &mut TaskResp| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &TaskResp| { &m.field_type },
                    |m: &mut TaskResp| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "data",
                    |m: &TaskResp| { &m.data },
                    |m: &mut TaskResp| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &TaskResp| { &m.handle },
                    |m: &mut TaskResp| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "none",
                    |m: &TaskResp| { &m.none },
                    |m: &mut TaskResp| { &mut m.none },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TaskResp_RetryContext>>(
                    "retry_ctx",
                    |m: &TaskResp| { &m.retry_ctx },
                    |m: &mut TaskResp| { &mut m.retry_ctx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "priority",
                    |m: &TaskResp| { &m.priority },
                    |m: &mut TaskResp| { &mut m.priority },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskResp>(
                    "TaskResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskResp {
        static mut instance: ::protobuf::lazy::Lazy<TaskResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskResp,
        };
        unsafe {
            instance.get(TaskResp::new)
        }
    }
}

impl ::protobuf::Clear for TaskResp {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.clear_data();
        self.clear_handle();
        self.clear_none();
        self.clear_retry_ctx();
        self.clear_priority();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskResp_RetryContext {
    // message fields
    pub retries: i32,
    pub progress_metadata: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskResp_RetryContext {
    pub fn new() -> TaskResp_RetryContext {
        ::std::default::Default::default()
    }

    // int32 retries = 1;

    pub fn clear_retries(&mut self) {
        self.retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_retries(&mut self, v: i32) {
        self.retries = v;
    }

    pub fn get_retries(&self) -> i32 {
        self.retries
    }

    // string progress_metadata = 2;

    pub fn clear_progress_metadata(&mut self) {
        self.progress_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_progress_metadata(&mut self, v: ::std::string::String) {
        self.progress_metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.progress_metadata
    }

    // Take field
    pub fn take_progress_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.progress_metadata, ::std::string::String::new())
    }

    pub fn get_progress_metadata(&self) -> &str {
        &self.progress_metadata
    }
}

impl ::protobuf::Message for TaskResp_RetryContext {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.retries = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.progress_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.retries != 0 {
            my_size += ::protobuf::rt::value_size(1, self.retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.progress_metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.progress_metadata);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.retries != 0 {
            os.write_int32(1, self.retries)?;
        }
        if !self.progress_metadata.is_empty() {
            os.write_string(2, &self.progress_metadata)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskResp_RetryContext {
        TaskResp_RetryContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "retries",
                    |m: &TaskResp_RetryContext| { &m.retries },
                    |m: &mut TaskResp_RetryContext| { &mut m.retries },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "progress_metadata",
                    |m: &TaskResp_RetryContext| { &m.progress_metadata },
                    |m: &mut TaskResp_RetryContext| { &mut m.progress_metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskResp_RetryContext>(
                    "TaskResp_RetryContext",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskResp_RetryContext {
        static mut instance: ::protobuf::lazy::Lazy<TaskResp_RetryContext> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskResp_RetryContext,
        };
        unsafe {
            instance.get(TaskResp_RetryContext::new)
        }
    }
}

impl ::protobuf::Clear for TaskResp_RetryContext {
    fn clear(&mut self) {
        self.clear_retries();
        self.clear_progress_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskResp_RetryContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskResp_RetryContext {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Task {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub priority: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub max_retries: ::protobuf::SingularPtrField<::protobuf::well_known_types::Int32Value>,
    pub delay: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub modules: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Task {
    pub fn new() -> Task {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }

    // .google.protobuf.Any data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::well_known_types::Any) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::well_known_types::Any {
        self.data.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    pub fn get_data(&self) -> &::protobuf::well_known_types::Any {
        self.data.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Any::default_instance())
    }

    // .google.protobuf.Int32Value priority = 4;

    pub fn clear_priority(&mut self) {
        self.priority.clear();
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.priority = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priority(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.priority.is_none() {
            self.priority.set_default();
        }
        self.priority.as_mut().unwrap()
    }

    // Take field
    pub fn take_priority(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.priority.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_priority(&self) -> &::protobuf::well_known_types::Int32Value {
        self.priority.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.Int32Value max_retries = 5;

    pub fn clear_max_retries(&mut self) {
        self.max_retries.clear();
    }

    pub fn has_max_retries(&self) -> bool {
        self.max_retries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_retries(&mut self, v: ::protobuf::well_known_types::Int32Value) {
        self.max_retries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_retries(&mut self) -> &mut ::protobuf::well_known_types::Int32Value {
        if self.max_retries.is_none() {
            self.max_retries.set_default();
        }
        self.max_retries.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_retries(&mut self) -> ::protobuf::well_known_types::Int32Value {
        self.max_retries.take().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::new())
    }

    pub fn get_max_retries(&self) -> &::protobuf::well_known_types::Int32Value {
        self.max_retries.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Int32Value::default_instance())
    }

    // .google.protobuf.Duration delay = 6;

    pub fn clear_delay(&mut self) {
        self.delay.clear();
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.delay = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delay(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.delay.is_none() {
            self.delay.set_default();
        }
        self.delay.as_mut().unwrap()
    }

    // Take field
    pub fn take_delay(&mut self) -> ::protobuf::well_known_types::Duration {
        self.delay.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    pub fn get_delay(&self) -> &::protobuf::well_known_types::Duration {
        self.delay.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Duration::default_instance())
    }

    // repeated string modules = 7;

    pub fn clear_modules(&mut self) {
        self.modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_modules(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_modules(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.modules
    }

    // Take field
    pub fn take_modules(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.modules, ::protobuf::RepeatedField::new())
    }

    pub fn get_modules(&self) -> &[::std::string::String] {
        &self.modules
    }
}

impl ::protobuf::Message for Task {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.priority {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_retries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.delay {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.priority)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_retries)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delay)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.modules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.priority.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_retries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.delay.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.modules {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.priority.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_retries.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.delay.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.modules {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Task {
        Task::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &Task| { &m.id },
                    |m: &mut Task| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &Task| { &m.field_type },
                    |m: &mut Task| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                    "data",
                    |m: &Task| { &m.data },
                    |m: &mut Task| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "priority",
                    |m: &Task| { &m.priority },
                    |m: &mut Task| { &mut m.priority },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Int32Value>>(
                    "max_retries",
                    |m: &Task| { &m.max_retries },
                    |m: &mut Task| { &mut m.max_retries },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                    "delay",
                    |m: &Task| { &m.delay },
                    |m: &mut Task| { &mut m.delay },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "modules",
                    |m: &Task| { &m.modules },
                    |m: &mut Task| { &mut m.modules },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Task>(
                    "Task",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Task {
        static mut instance: ::protobuf::lazy::Lazy<Task> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Task,
        };
        unsafe {
            instance.get(Task::new)
        }
    }
}

impl ::protobuf::Clear for Task {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.clear_data();
        self.clear_priority();
        self.clear_max_retries();
        self.clear_delay();
        self.clear_modules();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Task {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskProgress {
    // message fields
    pub handle: ::std::string::String,
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    pub max_retries: i32,
    pub retries: i32,
    pub priority: i32,
    pub worked_on: bool,
    pub done: bool,
    pub created: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub started_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub done_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    pub progress: f32,
    pub progress_message: ::std::string::String,
    pub progress_metadata: ::std::string::String,
    pub logs: ::std::string::String,
    pub worker_id: ::std::string::String,
    pub output: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskProgress {
    pub fn new() -> TaskProgress {
        ::std::default::Default::default()
    }

    // string handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // string id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string type = 3;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }

    // int32 max_retries = 4;

    pub fn clear_max_retries(&mut self) {
        self.max_retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_retries(&mut self, v: i32) {
        self.max_retries = v;
    }

    pub fn get_max_retries(&self) -> i32 {
        self.max_retries
    }

    // int32 retries = 5;

    pub fn clear_retries(&mut self) {
        self.retries = 0;
    }

    // Param is passed by value, moved
    pub fn set_retries(&mut self, v: i32) {
        self.retries = v;
    }

    pub fn get_retries(&self) -> i32 {
        self.retries
    }

    // int32 priority = 6;

    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = v;
    }

    pub fn get_priority(&self) -> i32 {
        self.priority
    }

    // bool worked_on = 7;

    pub fn clear_worked_on(&mut self) {
        self.worked_on = false;
    }

    // Param is passed by value, moved
    pub fn set_worked_on(&mut self, v: bool) {
        self.worked_on = v;
    }

    pub fn get_worked_on(&self) -> bool {
        self.worked_on
    }

    // bool done = 8;

    pub fn clear_done(&mut self) {
        self.done = false;
    }

    // Param is passed by value, moved
    pub fn set_done(&mut self, v: bool) {
        self.done = v;
    }

    pub fn get_done(&self) -> bool {
        self.done
    }

    // .google.protobuf.Timestamp created = 9;

    pub fn clear_created(&mut self) {
        self.created.clear();
    }

    pub fn has_created(&self) -> bool {
        self.created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created.is_none() {
            self.created.set_default();
        }
        self.created.as_mut().unwrap()
    }

    // Take field
    pub fn take_created(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_created(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp started_time = 10;

    pub fn clear_started_time(&mut self) {
        self.started_time.clear();
    }

    pub fn has_started_time(&self) -> bool {
        self.started_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.started_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_started_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.started_time.is_none() {
            self.started_time.set_default();
        }
        self.started_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_started_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.started_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_started_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.started_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.protobuf.Timestamp done_time = 11;

    pub fn clear_done_time(&mut self) {
        self.done_time.clear();
    }

    pub fn has_done_time(&self) -> bool {
        self.done_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_done_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.done_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_done_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.done_time.is_none() {
            self.done_time.set_default();
        }
        self.done_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_done_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.done_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    pub fn get_done_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.done_time.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::default_instance())
    }

    // .google.rpc.Status status = 12;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| super::status::Status::default_instance())
    }

    // float progress = 13;

    pub fn clear_progress(&mut self) {
        self.progress = 0.;
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = v;
    }

    pub fn get_progress(&self) -> f32 {
        self.progress
    }

    // string progress_message = 14;

    pub fn clear_progress_message(&mut self) {
        self.progress_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_progress_message(&mut self, v: ::std::string::String) {
        self.progress_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress_message(&mut self) -> &mut ::std::string::String {
        &mut self.progress_message
    }

    // Take field
    pub fn take_progress_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.progress_message, ::std::string::String::new())
    }

    pub fn get_progress_message(&self) -> &str {
        &self.progress_message
    }

    // string progress_metadata = 18;

    pub fn clear_progress_metadata(&mut self) {
        self.progress_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_progress_metadata(&mut self, v: ::std::string::String) {
        self.progress_metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.progress_metadata
    }

    // Take field
    pub fn take_progress_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.progress_metadata, ::std::string::String::new())
    }

    pub fn get_progress_metadata(&self) -> &str {
        &self.progress_metadata
    }

    // string logs = 15;

    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::std::string::String) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logs(&mut self) -> &mut ::std::string::String {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logs, ::std::string::String::new())
    }

    pub fn get_logs(&self) -> &str {
        &self.logs
    }

    // string worker_id = 16;

    pub fn clear_worker_id(&mut self) {
        self.worker_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_worker_id(&mut self, v: ::std::string::String) {
        self.worker_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_id(&mut self) -> &mut ::std::string::String {
        &mut self.worker_id
    }

    // Take field
    pub fn take_worker_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.worker_id, ::std::string::String::new())
    }

    pub fn get_worker_id(&self) -> &str {
        &self.worker_id
    }

    // string output = 17;

    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }

    pub fn get_output(&self) -> &str {
        &self.output
    }
}

impl ::protobuf::Message for TaskProgress {
    fn is_initialized(&self) -> bool {
        for v in &self.created {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.started_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.done_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_retries = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.retries = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.worked_on = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.done = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.started_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.done_time)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.progress = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.progress_message)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.progress_metadata)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logs)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.worker_id)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.handle);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.field_type);
        }
        if self.max_retries != 0 {
            my_size += ::protobuf::rt::value_size(4, self.max_retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.retries != 0 {
            my_size += ::protobuf::rt::value_size(5, self.retries, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(6, self.priority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.worked_on != false {
            my_size += 2;
        }
        if self.done != false {
            my_size += 2;
        }
        if let Some(ref v) = self.created.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.started_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.done_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.progress != 0. {
            my_size += 5;
        }
        if !self.progress_message.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.progress_message);
        }
        if !self.progress_metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.progress_metadata);
        }
        if !self.logs.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.logs);
        }
        if !self.worker_id.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.worker_id);
        }
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.handle.is_empty() {
            os.write_string(1, &self.handle)?;
        }
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(3, &self.field_type)?;
        }
        if self.max_retries != 0 {
            os.write_int32(4, self.max_retries)?;
        }
        if self.retries != 0 {
            os.write_int32(5, self.retries)?;
        }
        if self.priority != 0 {
            os.write_int32(6, self.priority)?;
        }
        if self.worked_on != false {
            os.write_bool(7, self.worked_on)?;
        }
        if self.done != false {
            os.write_bool(8, self.done)?;
        }
        if let Some(ref v) = self.created.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.started_time.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.done_time.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.progress != 0. {
            os.write_float(13, self.progress)?;
        }
        if !self.progress_message.is_empty() {
            os.write_string(14, &self.progress_message)?;
        }
        if !self.progress_metadata.is_empty() {
            os.write_string(18, &self.progress_metadata)?;
        }
        if !self.logs.is_empty() {
            os.write_string(15, &self.logs)?;
        }
        if !self.worker_id.is_empty() {
            os.write_string(16, &self.worker_id)?;
        }
        if !self.output.is_empty() {
            os.write_string(17, &self.output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskProgress {
        TaskProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &TaskProgress| { &m.handle },
                    |m: &mut TaskProgress| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &TaskProgress| { &m.id },
                    |m: &mut TaskProgress| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &TaskProgress| { &m.field_type },
                    |m: &mut TaskProgress| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "max_retries",
                    |m: &TaskProgress| { &m.max_retries },
                    |m: &mut TaskProgress| { &mut m.max_retries },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "retries",
                    |m: &TaskProgress| { &m.retries },
                    |m: &mut TaskProgress| { &mut m.retries },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "priority",
                    |m: &TaskProgress| { &m.priority },
                    |m: &mut TaskProgress| { &mut m.priority },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "worked_on",
                    |m: &TaskProgress| { &m.worked_on },
                    |m: &mut TaskProgress| { &mut m.worked_on },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "done",
                    |m: &TaskProgress| { &m.done },
                    |m: &mut TaskProgress| { &mut m.done },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "created",
                    |m: &TaskProgress| { &m.created },
                    |m: &mut TaskProgress| { &mut m.created },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "started_time",
                    |m: &TaskProgress| { &m.started_time },
                    |m: &mut TaskProgress| { &mut m.started_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                    "done_time",
                    |m: &TaskProgress| { &m.done_time },
                    |m: &mut TaskProgress| { &mut m.done_time },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                    "status",
                    |m: &TaskProgress| { &m.status },
                    |m: &mut TaskProgress| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "progress",
                    |m: &TaskProgress| { &m.progress },
                    |m: &mut TaskProgress| { &mut m.progress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "progress_message",
                    |m: &TaskProgress| { &m.progress_message },
                    |m: &mut TaskProgress| { &mut m.progress_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "progress_metadata",
                    |m: &TaskProgress| { &m.progress_metadata },
                    |m: &mut TaskProgress| { &mut m.progress_metadata },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logs",
                    |m: &TaskProgress| { &m.logs },
                    |m: &mut TaskProgress| { &mut m.logs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "worker_id",
                    |m: &TaskProgress| { &m.worker_id },
                    |m: &mut TaskProgress| { &mut m.worker_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output",
                    |m: &TaskProgress| { &m.output },
                    |m: &mut TaskProgress| { &mut m.output },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskProgress>(
                    "TaskProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskProgress {
        static mut instance: ::protobuf::lazy::Lazy<TaskProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskProgress,
        };
        unsafe {
            instance.get(TaskProgress::new)
        }
    }
}

impl ::protobuf::Clear for TaskProgress {
    fn clear(&mut self) {
        self.clear_handle();
        self.clear_id();
        self.clear_field_type();
        self.clear_max_retries();
        self.clear_retries();
        self.clear_priority();
        self.clear_worked_on();
        self.clear_done();
        self.clear_created();
        self.clear_started_time();
        self.clear_done_time();
        self.clear_status();
        self.clear_progress();
        self.clear_progress_message();
        self.clear_progress_metadata();
        self.clear_logs();
        self.clear_worker_id();
        self.clear_output();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateReq {
    // message fields
    pub task: ::protobuf::SingularPtrField<Task>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CreateReq {
    pub fn new() -> CreateReq {
        ::std::default::Default::default()
    }

    // .tortuga.Task task = 1;

    pub fn clear_task(&mut self) {
        self.task.clear();
    }

    pub fn has_task(&self) -> bool {
        self.task.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task(&mut self, v: Task) {
        self.task = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task(&mut self) -> &mut Task {
        if self.task.is_none() {
            self.task.set_default();
        }
        self.task.as_mut().unwrap()
    }

    // Take field
    pub fn take_task(&mut self) -> Task {
        self.task.take().unwrap_or_else(|| Task::new())
    }

    pub fn get_task(&self) -> &Task {
        self.task.as_ref().unwrap_or_else(|| Task::default_instance())
    }
}

impl ::protobuf::Message for CreateReq {
    fn is_initialized(&self) -> bool {
        for v in &self.task {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.task.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.task.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateReq {
        CreateReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Task>>(
                    "task",
                    |m: &CreateReq| { &m.task },
                    |m: &mut CreateReq| { &mut m.task },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateReq>(
                    "CreateReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateReq {
        static mut instance: ::protobuf::lazy::Lazy<CreateReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateReq,
        };
        unsafe {
            instance.get(CreateReq::new)
        }
    }
}

impl ::protobuf::Clear for CreateReq {
    fn clear(&mut self) {
        self.clear_task();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateResp {
    // message fields
    pub handle: ::std::string::String,
    pub created: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CreateResp {
    pub fn new() -> CreateResp {
        ::std::default::Default::default()
    }

    // string handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // bool created = 2;

    pub fn clear_created(&mut self) {
        self.created = false;
    }

    // Param is passed by value, moved
    pub fn set_created(&mut self, v: bool) {
        self.created = v;
    }

    pub fn get_created(&self) -> bool {
        self.created
    }
}

impl ::protobuf::Message for CreateResp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.created = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.handle);
        }
        if self.created != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.handle.is_empty() {
            os.write_string(1, &self.handle)?;
        }
        if self.created != false {
            os.write_bool(2, self.created)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateResp {
        CreateResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &CreateResp| { &m.handle },
                    |m: &mut CreateResp| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "created",
                    |m: &CreateResp| { &m.created },
                    |m: &mut CreateResp| { &mut m.created },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateResp>(
                    "CreateResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateResp {
        static mut instance: ::protobuf::lazy::Lazy<CreateResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateResp,
        };
        unsafe {
            instance.get(CreateResp::new)
        }
    }
}

impl ::protobuf::Clear for CreateResp {
    fn clear(&mut self) {
        self.clear_handle();
        self.clear_created();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteTaskReq {
    // message fields
    pub worker: ::protobuf::SingularPtrField<Worker>,
    pub handle: ::std::string::String,
    pub code: i32,
    pub error_message: ::std::string::String,
    pub logs: ::std::string::String,
    pub output: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl CompleteTaskReq {
    pub fn new() -> CompleteTaskReq {
        ::std::default::Default::default()
    }

    // .tortuga.Worker worker = 1;

    pub fn clear_worker(&mut self) {
        self.worker.clear();
    }

    pub fn has_worker(&self) -> bool {
        self.worker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker(&mut self, v: Worker) {
        self.worker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker(&mut self) -> &mut Worker {
        if self.worker.is_none() {
            self.worker.set_default();
        }
        self.worker.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker(&mut self) -> Worker {
        self.worker.take().unwrap_or_else(|| Worker::new())
    }

    pub fn get_worker(&self) -> &Worker {
        self.worker.as_ref().unwrap_or_else(|| Worker::default_instance())
    }

    // string handle = 2;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // int32 code = 3;

    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    pub fn get_code(&self) -> i32 {
        self.code
    }

    // string error_message = 4;

    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    pub fn get_error_message(&self) -> &str {
        &self.error_message
    }

    // string logs = 5;

    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::std::string::String) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logs(&mut self) -> &mut ::std::string::String {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logs, ::std::string::String::new())
    }

    pub fn get_logs(&self) -> &str {
        &self.logs
    }

    // string output = 6;

    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::std::string::String) {
        self.output = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut ::std::string::String {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.output, ::std::string::String::new())
    }

    pub fn get_output(&self) -> &str {
        &self.output
    }
}

impl ::protobuf::Message for CompleteTaskReq {
    fn is_initialized(&self) -> bool {
        for v in &self.worker {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error_message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.output)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(3, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.error_message);
        }
        if !self.logs.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.logs);
        }
        if !self.output.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.output);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.worker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if self.code != 0 {
            os.write_int32(3, self.code)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(4, &self.error_message)?;
        }
        if !self.logs.is_empty() {
            os.write_string(5, &self.logs)?;
        }
        if !self.output.is_empty() {
            os.write_string(6, &self.output)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteTaskReq {
        CompleteTaskReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Worker>>(
                    "worker",
                    |m: &CompleteTaskReq| { &m.worker },
                    |m: &mut CompleteTaskReq| { &mut m.worker },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &CompleteTaskReq| { &m.handle },
                    |m: &mut CompleteTaskReq| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "code",
                    |m: &CompleteTaskReq| { &m.code },
                    |m: &mut CompleteTaskReq| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error_message",
                    |m: &CompleteTaskReq| { &m.error_message },
                    |m: &mut CompleteTaskReq| { &mut m.error_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logs",
                    |m: &CompleteTaskReq| { &m.logs },
                    |m: &mut CompleteTaskReq| { &mut m.logs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "output",
                    |m: &CompleteTaskReq| { &m.output },
                    |m: &mut CompleteTaskReq| { &mut m.output },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CompleteTaskReq>(
                    "CompleteTaskReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CompleteTaskReq {
        static mut instance: ::protobuf::lazy::Lazy<CompleteTaskReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CompleteTaskReq,
        };
        unsafe {
            instance.get(CompleteTaskReq::new)
        }
    }
}

impl ::protobuf::Clear for CompleteTaskReq {
    fn clear(&mut self) {
        self.clear_worker();
        self.clear_handle();
        self.clear_code();
        self.clear_error_message();
        self.clear_logs();
        self.clear_output();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteTaskReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteTaskReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateProgressReq {
    // message fields
    pub worker: ::protobuf::SingularPtrField<Worker>,
    pub handle: ::std::string::String,
    pub progress: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub progress_message: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    pub progress_metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::StringValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl UpdateProgressReq {
    pub fn new() -> UpdateProgressReq {
        ::std::default::Default::default()
    }

    // .tortuga.Worker worker = 1;

    pub fn clear_worker(&mut self) {
        self.worker.clear();
    }

    pub fn has_worker(&self) -> bool {
        self.worker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker(&mut self, v: Worker) {
        self.worker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker(&mut self) -> &mut Worker {
        if self.worker.is_none() {
            self.worker.set_default();
        }
        self.worker.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker(&mut self) -> Worker {
        self.worker.take().unwrap_or_else(|| Worker::new())
    }

    pub fn get_worker(&self) -> &Worker {
        self.worker.as_ref().unwrap_or_else(|| Worker::default_instance())
    }

    // string handle = 2;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // .google.protobuf.FloatValue progress = 3;

    pub fn clear_progress(&mut self) {
        self.progress.clear();
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.progress.is_none() {
            self.progress.set_default();
        }
        self.progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.progress.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    pub fn get_progress(&self) -> &::protobuf::well_known_types::FloatValue {
        self.progress.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::default_instance())
    }

    // .google.protobuf.StringValue progress_message = 4;

    pub fn clear_progress_message(&mut self) {
        self.progress_message.clear();
    }

    pub fn has_progress_message(&self) -> bool {
        self.progress_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress_message(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.progress_message = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress_message(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.progress_message.is_none() {
            self.progress_message.set_default();
        }
        self.progress_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress_message(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.progress_message.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_progress_message(&self) -> &::protobuf::well_known_types::StringValue {
        self.progress_message.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }

    // .google.protobuf.StringValue progress_metadata = 5;

    pub fn clear_progress_metadata(&mut self) {
        self.progress_metadata.clear();
    }

    pub fn has_progress_metadata(&self) -> bool {
        self.progress_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress_metadata(&mut self, v: ::protobuf::well_known_types::StringValue) {
        self.progress_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_progress_metadata(&mut self) -> &mut ::protobuf::well_known_types::StringValue {
        if self.progress_metadata.is_none() {
            self.progress_metadata.set_default();
        }
        self.progress_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_progress_metadata(&mut self) -> ::protobuf::well_known_types::StringValue {
        self.progress_metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::new())
    }

    pub fn get_progress_metadata(&self) -> &::protobuf::well_known_types::StringValue {
        self.progress_metadata.as_ref().unwrap_or_else(|| ::protobuf::well_known_types::StringValue::default_instance())
    }
}

impl ::protobuf::Message for UpdateProgressReq {
    fn is_initialized(&self) -> bool {
        for v in &self.worker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress_message {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.progress_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress_message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.progress_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.worker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if let Some(ref v) = self.progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.progress_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.progress_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.worker.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if let Some(ref v) = self.progress.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.progress_message.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.progress_metadata.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateProgressReq {
        UpdateProgressReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Worker>>(
                    "worker",
                    |m: &UpdateProgressReq| { &m.worker },
                    |m: &mut UpdateProgressReq| { &mut m.worker },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &UpdateProgressReq| { &m.handle },
                    |m: &mut UpdateProgressReq| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                    "progress",
                    |m: &UpdateProgressReq| { &m.progress },
                    |m: &mut UpdateProgressReq| { &mut m.progress },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "progress_message",
                    |m: &UpdateProgressReq| { &m.progress_message },
                    |m: &mut UpdateProgressReq| { &mut m.progress_message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::StringValue>>(
                    "progress_metadata",
                    |m: &UpdateProgressReq| { &m.progress_metadata },
                    |m: &mut UpdateProgressReq| { &mut m.progress_metadata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UpdateProgressReq>(
                    "UpdateProgressReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UpdateProgressReq {
        static mut instance: ::protobuf::lazy::Lazy<UpdateProgressReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UpdateProgressReq,
        };
        unsafe {
            instance.get(UpdateProgressReq::new)
        }
    }
}

impl ::protobuf::Clear for UpdateProgressReq {
    fn clear(&mut self) {
        self.clear_worker();
        self.clear_handle();
        self.clear_progress();
        self.clear_progress_message();
        self.clear_progress_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateProgressReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateProgressReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgressReq {
    // message fields
    pub handle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProgressReq {
    pub fn new() -> ProgressReq {
        ::std::default::Default::default()
    }

    // string handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }
}

impl ::protobuf::Message for ProgressReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.handle.is_empty() {
            os.write_string(1, &self.handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgressReq {
        ProgressReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &ProgressReq| { &m.handle },
                    |m: &mut ProgressReq| { &mut m.handle },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgressReq>(
                    "ProgressReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgressReq {
        static mut instance: ::protobuf::lazy::Lazy<ProgressReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgressReq,
        };
        unsafe {
            instance.get(ProgressReq::new)
        }
    }
}

impl ::protobuf::Clear for ProgressReq {
    fn clear(&mut self) {
        self.clear_handle();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgressReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgressReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgressResp {
    // message fields
    pub handle: ::std::string::String,
    pub status: ::protobuf::SingularPtrField<super::status::Status>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProgressResp {
    pub fn new() -> ProgressResp {
        ::std::default::Default::default()
    }

    // string handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: ::std::string::String) {
        self.handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut ::std::string::String {
        &mut self.handle
    }

    // Take field
    pub fn take_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.handle, ::std::string::String::new())
    }

    pub fn get_handle(&self) -> &str {
        &self.handle
    }

    // .google.rpc.Status status = 2;

    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::status::Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::status::Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::status::Status {
        self.status.take().unwrap_or_else(|| super::status::Status::new())
    }

    pub fn get_status(&self) -> &super::status::Status {
        self.status.as_ref().unwrap_or_else(|| super::status::Status::default_instance())
    }
}

impl ::protobuf::Message for ProgressResp {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.handle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.handle);
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.handle.is_empty() {
            os.write_string(1, &self.handle)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgressResp {
        ProgressResp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "handle",
                    |m: &ProgressResp| { &m.handle },
                    |m: &mut ProgressResp| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::status::Status>>(
                    "status",
                    |m: &ProgressResp| { &m.status },
                    |m: &mut ProgressResp| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProgressResp>(
                    "ProgressResp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProgressResp {
        static mut instance: ::protobuf::lazy::Lazy<ProgressResp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProgressResp,
        };
        unsafe {
            instance.get(ProgressResp::new)
        }
    }
}

impl ::protobuf::Clear for ProgressResp {
    fn clear(&mut self) {
        self.clear_handle();
        self.clear_status();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgressResp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgressResp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TaskIdentifier {
    // message fields
    pub id: ::std::string::String,
    pub field_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TaskIdentifier {
    pub fn new() -> TaskIdentifier {
        ::std::default::Default::default()
    }

    // string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    pub fn get_id(&self) -> &str {
        &self.id
    }

    // string type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        &mut self.field_type
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.field_type, ::std::string::String::new())
    }

    pub fn get_field_type(&self) -> &str {
        &self.field_type
    }
}

impl ::protobuf::Message for TaskIdentifier {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.field_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.field_type.is_empty() {
            os.write_string(2, &self.field_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TaskIdentifier {
        TaskIdentifier::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "id",
                    |m: &TaskIdentifier| { &m.id },
                    |m: &mut TaskIdentifier| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "type",
                    |m: &TaskIdentifier| { &m.field_type },
                    |m: &mut TaskIdentifier| { &mut m.field_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskIdentifier>(
                    "TaskIdentifier",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TaskIdentifier {
        static mut instance: ::protobuf::lazy::Lazy<TaskIdentifier> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskIdentifier,
        };
        unsafe {
            instance.get(TaskIdentifier::new)
        }
    }
}

impl ::protobuf::Clear for TaskIdentifier {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TaskIdentifier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TaskIdentifier {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FindTaskReq {
    // message fields
    pub handle: i64,
    pub is_for_done_only: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FindTaskReq {
    pub fn new() -> FindTaskReq {
        ::std::default::Default::default()
    }

    // int64 handle = 1;

    pub fn clear_handle(&mut self) {
        self.handle = 0;
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = v;
    }

    pub fn get_handle(&self) -> i64 {
        self.handle
    }

    // bool is_for_done_only = 2;

    pub fn clear_is_for_done_only(&mut self) {
        self.is_for_done_only = false;
    }

    // Param is passed by value, moved
    pub fn set_is_for_done_only(&mut self, v: bool) {
        self.is_for_done_only = v;
    }

    pub fn get_is_for_done_only(&self) -> bool {
        self.is_for_done_only
    }
}

impl ::protobuf::Message for FindTaskReq {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.handle = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_for_done_only = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.handle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.handle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_for_done_only != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.handle != 0 {
            os.write_int64(1, self.handle)?;
        }
        if self.is_for_done_only != false {
            os.write_bool(2, self.is_for_done_only)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FindTaskReq {
        FindTaskReq::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "handle",
                    |m: &FindTaskReq| { &m.handle },
                    |m: &mut FindTaskReq| { &mut m.handle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_for_done_only",
                    |m: &FindTaskReq| { &m.is_for_done_only },
                    |m: &mut FindTaskReq| { &mut m.is_for_done_only },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FindTaskReq>(
                    "FindTaskReq",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FindTaskReq {
        static mut instance: ::protobuf::lazy::Lazy<FindTaskReq> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FindTaskReq,
        };
        unsafe {
            instance.get(FindTaskReq::new)
        }
    }
}

impl ::protobuf::Clear for FindTaskReq {
    fn clear(&mut self) {
        self.clear_handle();
        self.clear_is_for_done_only();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FindTaskReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FindTaskReq {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15tortuga/tortuga.proto\x12\x07tortuga\x1a\x19google/protobuf/any.pr\
    oto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.p\
    roto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrapp\
    ers.proto\x1a\x17google/rpc/status.proto\"]\n\x06Worker\x12\x1b\n\tworke\
    r_id\x18\x01\x20\x01(\tR\x08workerId\x12\x12\n\x04uuid\x18\x02\x20\x01(\
    \tR\x04uuid\x12\"\n\x0ccapabilities\x18\x03\x20\x03(\tR\x0ccapabilities\
    \"\xbc\x01\n\x0cHeartbeatReq\x12C\n\x0cworker_beats\x18\x01\x20\x03(\x0b\
    2\x20.tortuga.HeartbeatReq.WorkerBeatR\x0bworkerBeats\x1ag\n\nWorkerBeat\
    \x12'\n\x06worker\x18\x01\x20\x01(\x0b2\x0f.tortuga.WorkerR\x06worker\
    \x120\n\x14current_task_handles\x18\x02\x20\x03(\x03R\x12currentTaskHand\
    les\"2\n\x07TaskReq\x12'\n\x06worker\x18\x01\x20\x01(\x0b2\x0f.tortuga.W\
    orkerR\x06worker\"\xb4\x02\n\x08TaskResp\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\tR\x02id\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12(\n\x04data\
    \x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyR\x04data\x12\x16\n\x06han\
    dle\x18\x04\x20\x01(\tR\x06handle\x12\x12\n\x04none\x18\x05\x20\x01(\x08\
    R\x04none\x12;\n\tretry_ctx\x18\x06\x20\x01(\x0b2\x1e.tortuga.TaskResp.R\
    etryContextR\x08retryCtx\x12\x1a\n\x08priority\x18\x07\x20\x01(\x05R\x08\
    priority\x1aU\n\x0cRetryContext\x12\x18\n\x07retries\x18\x01\x20\x01(\
    \x05R\x07retries\x12+\n\x11progress_metadata\x18\x02\x20\x01(\tR\x10prog\
    ressMetadata\"\x96\x02\n\x04Task\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\x12(\n\x04data\x18\x03\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x04data\x127\n\x08priority\x18\
    \x04\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\x08priority\x12<\n\
    \x0bmax_retries\x18\x05\x20\x01(\x0b2\x1b.google.protobuf.Int32ValueR\nm\
    axRetries\x12/\n\x05delay\x18\x06\x20\x01(\x0b2\x19.google.protobuf.Dura\
    tionR\x05delay\x12\x18\n\x07modules\x18\x07\x20\x03(\tR\x07modules\"\xe9\
    \x04\n\x0cTaskProgress\x12\x16\n\x06handle\x18\x01\x20\x01(\tR\x06handle\
    \x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\x12\x12\n\x04type\x18\x03\x20\
    \x01(\tR\x04type\x12\x1f\n\x0bmax_retries\x18\x04\x20\x01(\x05R\nmaxRetr\
    ies\x12\x18\n\x07retries\x18\x05\x20\x01(\x05R\x07retries\x12\x1a\n\x08p\
    riority\x18\x06\x20\x01(\x05R\x08priority\x12\x1b\n\tworked_on\x18\x07\
    \x20\x01(\x08R\x08workedOn\x12\x12\n\x04done\x18\x08\x20\x01(\x08R\x04do\
    ne\x124\n\x07created\x18\t\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x07created\x12=\n\x0cstarted_time\x18\n\x20\x01(\x0b2\x1a.google.protob\
    uf.TimestampR\x0bstartedTime\x127\n\tdone_time\x18\x0b\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\x08doneTime\x12*\n\x06status\x18\x0c\x20\x01\
    (\x0b2\x12.google.rpc.StatusR\x06status\x12\x1a\n\x08progress\x18\r\x20\
    \x01(\x02R\x08progress\x12)\n\x10progress_message\x18\x0e\x20\x01(\tR\
    \x0fprogressMessage\x12+\n\x11progress_metadata\x18\x12\x20\x01(\tR\x10p\
    rogressMetadata\x12\x12\n\x04logs\x18\x0f\x20\x01(\tR\x04logs\x12\x1b\n\
    \tworker_id\x18\x10\x20\x01(\tR\x08workerId\x12\x16\n\x06output\x18\x11\
    \x20\x01(\tR\x06output\".\n\tCreateReq\x12!\n\x04task\x18\x01\x20\x01(\
    \x0b2\r.tortuga.TaskR\x04task\">\n\nCreateResp\x12\x16\n\x06handle\x18\
    \x01\x20\x01(\tR\x06handle\x12\x18\n\x07created\x18\x02\x20\x01(\x08R\
    \x07created\"\xb7\x01\n\x0fCompleteTaskReq\x12'\n\x06worker\x18\x01\x20\
    \x01(\x0b2\x0f.tortuga.WorkerR\x06worker\x12\x16\n\x06handle\x18\x02\x20\
    \x01(\tR\x06handle\x12\x12\n\x04code\x18\x03\x20\x01(\x05R\x04code\x12#\
    \n\rerror_message\x18\x04\x20\x01(\tR\x0cerrorMessage\x12\x12\n\x04logs\
    \x18\x05\x20\x01(\tR\x04logs\x12\x16\n\x06output\x18\x06\x20\x01(\tR\x06\
    output\"\xa1\x02\n\x11UpdateProgressReq\x12'\n\x06worker\x18\x01\x20\x01\
    (\x0b2\x0f.tortuga.WorkerR\x06worker\x12\x16\n\x06handle\x18\x02\x20\x01\
    (\tR\x06handle\x127\n\x08progress\x18\x03\x20\x01(\x0b2\x1b.google.proto\
    buf.FloatValueR\x08progress\x12G\n\x10progress_message\x18\x04\x20\x01(\
    \x0b2\x1c.google.protobuf.StringValueR\x0fprogressMessage\x12I\n\x11prog\
    ress_metadata\x18\x05\x20\x01(\x0b2\x1c.google.protobuf.StringValueR\x10\
    progressMetadata\"%\n\x0bProgressReq\x12\x16\n\x06handle\x18\x01\x20\x01\
    (\tR\x06handle\"R\n\x0cProgressResp\x12\x16\n\x06handle\x18\x01\x20\x01(\
    \tR\x06handle\x12*\n\x06status\x18\x02\x20\x01(\x0b2\x12.google.rpc.Stat\
    usR\x06status\"4\n\x0eTaskIdentifier\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04type\"N\n\x0bFindTaskReq\
    \x12\x16\n\x06handle\x18\x01\x20\x01(\x03R\x06handle\x12'\n\x10is_for_do\
    ne_only\x18\x02\x20\x01(\x08R\risForDoneOnly2\xad\x04\n\x07Tortuga\x125\
    \n\nCreateTask\x12\x12.tortuga.CreateReq\x1a\x13.tortuga.CreateResp\x122\
    \n\x0bRequestTask\x12\x10.tortuga.TaskReq\x1a\x11.tortuga.TaskResp\x12:\
    \n\tHeartbeat\x12\x15.tortuga.HeartbeatReq\x1a\x16.google.protobuf.Empty\
    \x12@\n\x0cCompleteTask\x12\x18.tortuga.CompleteTaskReq\x1a\x16.google.p\
    rotobuf.Empty\x12D\n\x0eUpdateProgress\x12\x1a.tortuga.UpdateProgressReq\
    \x1a\x16.google.protobuf.Empty\x12:\n\x08FindTask\x12\x17.tortuga.TaskId\
    entifier\x1a\x15.tortuga.TaskProgress\x12?\n\x10FindTaskByHandle\x12\x14\
    .tortuga.FindTaskReq\x1a\x15.tortuga.TaskProgress\x126\n\x04Ping\x12\x16\
    .google.protobuf.Empty\x1a\x16.google.protobuf.Empty\x12>\n\x0cQuitQuitQ\
    uit\x12\x16.google.protobuf.Empty\x1a\x16.google.protobuf.EmptyB\x1a\n\n\
    io.tortugaB\x0cTortugaProtoJ\xbc1\n\x07\x12\x05\x01\0\xa4\x01\x01\n5\n\
    \x01\x0c\x12\x03\x01\0\x12\x1a+\x20This\x20file\x20defines\x20tortuga\
    \x20GRPC\x20interface.\n\n\x08\n\x01\x02\x12\x03\x03\x08\x0f\n\x08\n\x01\
    \x08\x12\x03\x05\0#\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x05\0#\n\x0c\n\x05\
    \x08\xe7\x07\0\x02\x12\x03\x05\x07\x13\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\
    \x03\x05\x07\x13\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x05\x07\x13\
    \n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x05\x16\"\n\x08\n\x01\x08\x12\x03\
    \x06\0-\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x06\0-\n\x0c\n\x05\x08\xe7\
    \x07\x01\x02\x12\x03\x06\x07\x1b\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\
    \x06\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x06\x07\x1b\n\
    \x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x06\x1e,\n\t\n\x02\x03\0\x12\x03\
    \x08\x07\"\n\t\n\x02\x03\x01\x12\x03\t\x07'\n\t\n\x02\x03\x02\x12\x03\n\
    \x07$\n\t\n\x02\x03\x03\x12\x03\x0b\x07(\n\t\n\x02\x03\x04\x12\x03\x0c\
    \x07'\n\t\n\x02\x03\x05\x12\x03\r\x07\x20\n\n\n\x02\x04\0\x12\x04\x0f\0\
    \x15\x01\n\n\n\x03\x04\0\x01\x12\x03\x0f\x08\x0e\n\x0b\n\x04\x04\0\x02\0\
    \x12\x03\x10\x02\x17\n\r\n\x05\x04\0\x02\0\x04\x12\x04\x10\x02\x0f\x10\n\
    \x0c\n\x05\x04\0\x02\0\x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x10\t\x12\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x10\x15\x16\n\
    \x0b\n\x04\x04\0\x02\x01\x12\x03\x11\x02\x12\n\r\n\x05\x04\0\x02\x01\x04\
    \x12\x04\x11\x02\x10\x17\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x11\x02\
    \x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\x11\t\r\n\x0c\n\x05\x04\0\x02\
    \x01\x03\x12\x03\x11\x10\x11\n=\n\x04\x04\0\x02\x02\x12\x03\x14\x02#\x1a\
    0\x20name\x20of\x20the\x20tasks\x20that\x20this\x20worker\x20can\x20hand\
    le.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03\x14\x02\n\n\x0c\n\x05\x04\0\
    \x02\x02\x05\x12\x03\x14\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\
    \x14\x12\x1e\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x14!\"\n\n\n\x02\x04\
    \x01\x12\x04\x17\0!\x01\n\n\n\x03\x04\x01\x01\x12\x03\x17\x08\x14\nq\n\
    \x04\x04\x01\x03\0\x12\x04\x1a\x02\x1e\x03\x1ac\x20a\x20connection\x20ha\
    ndling\x20multiple\x20workers\x20will\x20beat\x20for\x20all\x20of\x20the\
    m\x20at\x20once\n\x20hence\x20this\x20is\x20repeated.\n\n\x0c\n\x05\x04\
    \x01\x03\0\x01\x12\x03\x1a\n\x14\n\r\n\x06\x04\x01\x03\0\x02\0\x12\x03\
    \x1b\x04\x16\n\x0f\n\x07\x04\x01\x03\0\x02\0\x04\x12\x04\x1b\x04\x1a\x16\
    \n\x0e\n\x07\x04\x01\x03\0\x02\0\x06\x12\x03\x1b\x04\n\n\x0e\n\x07\x04\
    \x01\x03\0\x02\0\x01\x12\x03\x1b\x0b\x11\n\x0e\n\x07\x04\x01\x03\0\x02\0\
    \x03\x12\x03\x1b\x14\x15\n\r\n\x06\x04\x01\x03\0\x02\x01\x12\x03\x1d\x04\
    ,\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x04\x12\x03\x1d\x04\x0c\n\x0e\n\x07\
    \x04\x01\x03\0\x02\x01\x05\x12\x03\x1d\r\x12\n\x0e\n\x07\x04\x01\x03\0\
    \x02\x01\x01\x12\x03\x1d\x13'\n\x0e\n\x07\x04\x01\x03\0\x02\x01\x03\x12\
    \x03\x1d*+\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x20\x02'\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x03\x20\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03\
    \x20\x0b\x15\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x20\x16\"\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03\x20%&\n\n\n\x02\x04\x02\x12\x04#\0%\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03#\x08\x0f\n\x0b\n\x04\x04\x02\x02\0\x12\x03$\x02\
    \x14\n\r\n\x05\x04\x02\x02\0\x04\x12\x04$\x02#\x11\n\x0c\n\x05\x04\x02\
    \x02\0\x06\x12\x03$\x02\x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03$\t\x0f\
    \n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03$\x12\x13\n\n\n\x02\x04\x03\x12\
    \x04'\06\x01\n\n\n\x03\x04\x03\x01\x12\x03'\x08\x10\n\x0b\n\x04\x04\x03\
    \x02\0\x12\x03(\x02\x10\n\r\n\x05\x04\x03\x02\0\x04\x12\x04(\x02'\x12\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03(\x02\x08\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03(\t\x0b\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03(\x0e\x0f\n\x0b\
    \n\x04\x04\x03\x02\x01\x12\x03)\x02\x12\n\r\n\x05\x04\x03\x02\x01\x04\
    \x12\x04)\x02(\x10\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03)\x02\x08\n\
    \x0c\n\x05\x04\x03\x02\x01\x01\x12\x03)\t\r\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03)\x10\x11\n\x0b\n\x04\x04\x03\x02\x02\x12\x03*\x02\x1f\n\r\n\
    \x05\x04\x03\x02\x02\x04\x12\x04*\x02)\x12\n\x0c\n\x05\x04\x03\x02\x02\
    \x06\x12\x03*\x02\x15\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03*\x16\x1a\n\
    \x0c\n\x05\x04\x03\x02\x02\x03\x12\x03*\x1d\x1e\n\x0b\n\x04\x04\x03\x02\
    \x03\x12\x03+\x02\x14\n\r\n\x05\x04\x03\x02\x03\x04\x12\x04+\x02*\x1f\n\
    \x0c\n\x05\x04\x03\x02\x03\x05\x12\x03+\x02\x08\n\x0c\n\x05\x04\x03\x02\
    \x03\x01\x12\x03+\t\x0f\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03+\x12\x13\
    \n\x0b\n\x04\x04\x03\x02\x04\x12\x03,\x02\x10\n\r\n\x05\x04\x03\x02\x04\
    \x04\x12\x04,\x02+\x14\n\x0c\n\x05\x04\x03\x02\x04\x05\x12\x03,\x02\x06\
    \n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03,\x07\x0b\n\x0c\n\x05\x04\x03\
    \x02\x04\x03\x12\x03,\x0e\x0f\n\x0c\n\x04\x04\x03\x03\0\x12\x04.\x022\
    \x03\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x03.\n\x16\n\r\n\x06\x04\x03\x03\
    \0\x02\0\x12\x03/\x04\x16\n\x0f\n\x07\x04\x03\x03\0\x02\0\x04\x12\x04/\
    \x04.\x18\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x03/\x04\t\n\x0e\n\x07\
    \x04\x03\x03\0\x02\0\x01\x12\x03/\n\x11\n\x0e\n\x07\x04\x03\x03\0\x02\0\
    \x03\x12\x03/\x14\x15\nJ\n\x06\x04\x03\x03\0\x02\x01\x12\x031\x04!\x1a;\
    \x20The\x20last\x20metadata\x20provided,\x20relevant\x20only\x20if\x20re\
    tries\x20>\x200.\n\n\x0f\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x041\x04/\
    \x16\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x05\x12\x031\x04\n\n\x0e\n\x07\
    \x04\x03\x03\0\x02\x01\x01\x12\x031\x0b\x1c\n\x0e\n\x07\x04\x03\x03\0\
    \x02\x01\x03\x12\x031\x1f\x20\n\x0b\n\x04\x04\x03\x02\x05\x12\x034\x02\
    \x1d\n\r\n\x05\x04\x03\x02\x05\x04\x12\x044\x022\x03\n\x0c\n\x05\x04\x03\
    \x02\x05\x06\x12\x034\x02\x0e\n\x0c\n\x05\x04\x03\x02\x05\x01\x12\x034\
    \x0f\x18\n\x0c\n\x05\x04\x03\x02\x05\x03\x12\x034\x1b\x1c\n\x0b\n\x04\
    \x04\x03\x02\x06\x12\x035\x02\x15\n\r\n\x05\x04\x03\x02\x06\x04\x12\x045\
    \x024\x1d\n\x0c\n\x05\x04\x03\x02\x06\x05\x12\x035\x02\x07\n\x0c\n\x05\
    \x04\x03\x02\x06\x01\x12\x035\x08\x10\n\x0c\n\x05\x04\x03\x02\x06\x03\
    \x12\x035\x13\x14\n\n\n\x02\x04\x04\x12\x048\0E\x01\n\n\n\x03\x04\x04\
    \x01\x12\x038\x08\x0c\n\x0b\n\x04\x04\x04\x02\0\x12\x039\x02\x10\n\r\n\
    \x05\x04\x04\x02\0\x04\x12\x049\x028\x0e\n\x0c\n\x05\x04\x04\x02\0\x05\
    \x12\x039\x02\x08\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x039\t\x0b\n\x0c\n\
    \x05\x04\x04\x02\0\x03\x12\x039\x0e\x0f\n\x0b\n\x04\x04\x04\x02\x01\x12\
    \x03:\x02\x12\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04:\x029\x10\n\x0c\n\
    \x05\x04\x04\x02\x01\x05\x12\x03:\x02\x08\n\x0c\n\x05\x04\x04\x02\x01\
    \x01\x12\x03:\t\r\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03:\x10\x11\n\x0b\
    \n\x04\x04\x04\x02\x02\x12\x03;\x02\x1f\n\r\n\x05\x04\x04\x02\x02\x04\
    \x12\x04;\x02:\x12\n\x0c\n\x05\x04\x04\x02\x02\x06\x12\x03;\x02\x15\n\
    \x0c\n\x05\x04\x04\x02\x02\x01\x12\x03;\x16\x1a\n\x0c\n\x05\x04\x04\x02\
    \x02\x03\x12\x03;\x1d\x1e\n\x0b\n\x04\x04\x04\x02\x03\x12\x03<\x02*\n\r\
    \n\x05\x04\x04\x02\x03\x04\x12\x04<\x02;\x1f\n\x0c\n\x05\x04\x04\x02\x03\
    \x06\x12\x03<\x02\x1c\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03<\x1d%\n\
    \x0c\n\x05\x04\x04\x02\x03\x03\x12\x03<()\n\x0b\n\x04\x04\x04\x02\x04\
    \x12\x03=\x02-\n\r\n\x05\x04\x04\x02\x04\x04\x12\x04=\x02<*\n\x0c\n\x05\
    \x04\x04\x02\x04\x06\x12\x03=\x02\x1c\n\x0c\n\x05\x04\x04\x02\x04\x01\
    \x12\x03=\x1d(\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03=+,\nE\n\x04\x04\
    \x04\x02\x05\x12\x03@\x02%\x1a8\x20If\x20set\x20the\x20task\x20shall\x20\
    not\x20be\x20served\x20before\x20this\x20delay.\n\n\r\n\x05\x04\x04\x02\
    \x05\x04\x12\x04@\x02=-\n\x0c\n\x05\x04\x04\x02\x05\x06\x12\x03@\x02\x1a\
    \n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03@\x1b\x20\n\x0c\n\x05\x04\x04\
    \x02\x05\x03\x12\x03@#$\ns\n\x04\x04\x04\x02\x06\x12\x03D\x02\x1e\x1af\
    \x20List\x20of\x20modules\x20that\x20apply\x20to\x20this\x20task.\n\x20N\
    ames\x20MUST\x20correspond\x20to\x20a\x20module\x20supported\x20in\x20th\
    e\x20server.\n\n\x0c\n\x05\x04\x04\x02\x06\x04\x12\x03D\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x06\x05\x12\x03D\x0b\x11\n\x0c\n\x05\x04\x04\x02\x06\
    \x01\x12\x03D\x12\x19\n\x0c\n\x05\x04\x04\x02\x06\x03\x12\x03D\x1c\x1d\n\
    \n\n\x02\x04\x05\x12\x04G\0`\x01\n\n\n\x03\x04\x05\x01\x12\x03G\x08\x14\
    \n\x0b\n\x04\x04\x05\x02\0\x12\x03H\x02\x14\n\r\n\x05\x04\x05\x02\0\x04\
    \x12\x04H\x02G\x16\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03H\x02\x08\n\x0c\
    \n\x05\x04\x05\x02\0\x01\x12\x03H\t\x0f\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03H\x12\x13\n\x0b\n\x04\x04\x05\x02\x01\x12\x03I\x02\x10\n\r\n\x05\
    \x04\x05\x02\x01\x04\x12\x04I\x02H\x14\n\x0c\n\x05\x04\x05\x02\x01\x05\
    \x12\x03I\x02\x08\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03I\t\x0b\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03I\x0e\x0f\n\x0b\n\x04\x04\x05\x02\x02\
    \x12\x03J\x02\x12\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04J\x02I\x10\n\x0c\
    \n\x05\x04\x05\x02\x02\x05\x12\x03J\x02\x08\n\x0c\n\x05\x04\x05\x02\x02\
    \x01\x12\x03J\t\r\n\x0c\n\x05\x04\x05\x02\x02\x03\x12\x03J\x10\x11\n\x0b\
    \n\x04\x04\x05\x02\x03\x12\x03L\x02\x18\n\r\n\x05\x04\x05\x02\x03\x04\
    \x12\x04L\x02J\x12\n\x0c\n\x05\x04\x05\x02\x03\x05\x12\x03L\x02\x07\n\
    \x0c\n\x05\x04\x05\x02\x03\x01\x12\x03L\x08\x13\n\x0c\n\x05\x04\x05\x02\
    \x03\x03\x12\x03L\x16\x17\n\x0b\n\x04\x04\x05\x02\x04\x12\x03M\x02\x14\n\
    \r\n\x05\x04\x05\x02\x04\x04\x12\x04M\x02L\x18\n\x0c\n\x05\x04\x05\x02\
    \x04\x05\x12\x03M\x02\x07\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03M\x08\
    \x0f\n\x0c\n\x05\x04\x05\x02\x04\x03\x12\x03M\x12\x13\n\x0b\n\x04\x04\
    \x05\x02\x05\x12\x03N\x02\x15\n\r\n\x05\x04\x05\x02\x05\x04\x12\x04N\x02\
    M\x14\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03N\x02\x07\n\x0c\n\x05\x04\
    \x05\x02\x05\x01\x12\x03N\x08\x10\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\
    \x03N\x13\x14\n\x0b\n\x04\x04\x05\x02\x06\x12\x03P\x02\x15\n\r\n\x05\x04\
    \x05\x02\x06\x04\x12\x04P\x02N\x15\n\x0c\n\x05\x04\x05\x02\x06\x05\x12\
    \x03P\x02\x06\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03P\x07\x10\n\x0c\n\
    \x05\x04\x05\x02\x06\x03\x12\x03P\x13\x14\n\x0b\n\x04\x04\x05\x02\x07\
    \x12\x03Q\x02\x10\n\r\n\x05\x04\x05\x02\x07\x04\x12\x04Q\x02P\x15\n\x0c\
    \n\x05\x04\x05\x02\x07\x05\x12\x03Q\x02\x06\n\x0c\n\x05\x04\x05\x02\x07\
    \x01\x12\x03Q\x07\x0b\n\x0c\n\x05\x04\x05\x02\x07\x03\x12\x03Q\x0e\x0f\n\
    \x0b\n\x04\x04\x05\x02\x08\x12\x03S\x02(\n\r\n\x05\x04\x05\x02\x08\x04\
    \x12\x04S\x02Q\x10\n\x0c\n\x05\x04\x05\x02\x08\x06\x12\x03S\x02\x1b\n\
    \x0c\n\x05\x04\x05\x02\x08\x01\x12\x03S\x1c#\n\x0c\n\x05\x04\x05\x02\x08\
    \x03\x12\x03S&'\n\x0b\n\x04\x04\x05\x02\t\x12\x03T\x02.\n\r\n\x05\x04\
    \x05\x02\t\x04\x12\x04T\x02S(\n\x0c\n\x05\x04\x05\x02\t\x06\x12\x03T\x02\
    \x1b\n\x0c\n\x05\x04\x05\x02\t\x01\x12\x03T\x1c(\n\x0c\n\x05\x04\x05\x02\
    \t\x03\x12\x03T+-\n\x0b\n\x04\x04\x05\x02\n\x12\x03U\x02+\n\r\n\x05\x04\
    \x05\x02\n\x04\x12\x04U\x02T.\n\x0c\n\x05\x04\x05\x02\n\x06\x12\x03U\x02\
    \x1b\n\x0c\n\x05\x04\x05\x02\n\x01\x12\x03U\x1c%\n\x0c\n\x05\x04\x05\x02\
    \n\x03\x12\x03U(*\n\x0b\n\x04\x04\x05\x02\x0b\x12\x03W\x02\x20\n\r\n\x05\
    \x04\x05\x02\x0b\x04\x12\x04W\x02U+\n\x0c\n\x05\x04\x05\x02\x0b\x06\x12\
    \x03W\x02\x13\n\x0c\n\x05\x04\x05\x02\x0b\x01\x12\x03W\x14\x1a\n\x0c\n\
    \x05\x04\x05\x02\x0b\x03\x12\x03W\x1d\x1f\n\x0b\n\x04\x04\x05\x02\x0c\
    \x12\x03Y\x02\x16\n\r\n\x05\x04\x05\x02\x0c\x04\x12\x04Y\x02W\x20\n\x0c\
    \n\x05\x04\x05\x02\x0c\x05\x12\x03Y\x02\x07\n\x0c\n\x05\x04\x05\x02\x0c\
    \x01\x12\x03Y\x08\x10\n\x0c\n\x05\x04\x05\x02\x0c\x03\x12\x03Y\x13\x15\n\
    \x0b\n\x04\x04\x05\x02\r\x12\x03Z\x02\x1f\n\r\n\x05\x04\x05\x02\r\x04\
    \x12\x04Z\x02Y\x16\n\x0c\n\x05\x04\x05\x02\r\x05\x12\x03Z\x02\x08\n\x0c\
    \n\x05\x04\x05\x02\r\x01\x12\x03Z\t\x19\n\x0c\n\x05\x04\x05\x02\r\x03\
    \x12\x03Z\x1c\x1e\n\x0b\n\x04\x04\x05\x02\x0e\x12\x03[\x02\x20\n\r\n\x05\
    \x04\x05\x02\x0e\x04\x12\x04[\x02Z\x1f\n\x0c\n\x05\x04\x05\x02\x0e\x05\
    \x12\x03[\x02\x08\n\x0c\n\x05\x04\x05\x02\x0e\x01\x12\x03[\t\x1a\n\x0c\n\
    \x05\x04\x05\x02\x0e\x03\x12\x03[\x1d\x1f\n\x0b\n\x04\x04\x05\x02\x0f\
    \x12\x03\\\x02\x13\n\r\n\x05\x04\x05\x02\x0f\x04\x12\x04\\\x02[\x20\n\
    \x0c\n\x05\x04\x05\x02\x0f\x05\x12\x03\\\x02\x08\n\x0c\n\x05\x04\x05\x02\
    \x0f\x01\x12\x03\\\t\r\n\x0c\n\x05\x04\x05\x02\x0f\x03\x12\x03\\\x10\x12\
    \n\x0b\n\x04\x04\x05\x02\x10\x12\x03^\x02\x18\n\r\n\x05\x04\x05\x02\x10\
    \x04\x12\x04^\x02\\\x13\n\x0c\n\x05\x04\x05\x02\x10\x05\x12\x03^\x02\x08\
    \n\x0c\n\x05\x04\x05\x02\x10\x01\x12\x03^\t\x12\n\x0c\n\x05\x04\x05\x02\
    \x10\x03\x12\x03^\x15\x17\n\x0b\n\x04\x04\x05\x02\x11\x12\x03_\x02\x15\n\
    \r\n\x05\x04\x05\x02\x11\x04\x12\x04_\x02^\x18\n\x0c\n\x05\x04\x05\x02\
    \x11\x05\x12\x03_\x02\x08\n\x0c\n\x05\x04\x05\x02\x11\x01\x12\x03_\t\x0f\
    \n\x0c\n\x05\x04\x05\x02\x11\x03\x12\x03_\x12\x14\n\n\n\x02\x04\x06\x12\
    \x04b\0d\x01\n\n\n\x03\x04\x06\x01\x12\x03b\x08\x11\n\x0b\n\x04\x04\x06\
    \x02\0\x12\x03c\x02\x10\n\r\n\x05\x04\x06\x02\0\x04\x12\x04c\x02b\x13\n\
    \x0c\n\x05\x04\x06\x02\0\x06\x12\x03c\x02\x06\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03c\x07\x0b\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03c\x0e\x0f\n\n\
    \n\x02\x04\x07\x12\x04f\0i\x01\n\n\n\x03\x04\x07\x01\x12\x03f\x08\x12\n\
    \x0b\n\x04\x04\x07\x02\0\x12\x03g\x02\x14\n\r\n\x05\x04\x07\x02\0\x04\
    \x12\x04g\x02f\x14\n\x0c\n\x05\x04\x07\x02\0\x05\x12\x03g\x02\x08\n\x0c\
    \n\x05\x04\x07\x02\0\x01\x12\x03g\t\x0f\n\x0c\n\x05\x04\x07\x02\0\x03\
    \x12\x03g\x12\x13\n\x0b\n\x04\x04\x07\x02\x01\x12\x03h\x02\x13\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04h\x02g\x14\n\x0c\n\x05\x04\x07\x02\x01\x05\
    \x12\x03h\x02\x06\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03h\x07\x0e\n\x0c\
    \n\x05\x04\x07\x02\x01\x03\x12\x03h\x11\x12\n\n\n\x02\x04\x08\x12\x04k\0\
    t\x01\n\n\n\x03\x04\x08\x01\x12\x03k\x08\x17\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03l\x02\x14\n\r\n\x05\x04\x08\x02\0\x04\x12\x04l\x02k\x19\n\x0c\n\
    \x05\x04\x08\x02\0\x06\x12\x03l\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03l\t\x0f\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03l\x12\x13\n\x0b\n\
    \x04\x04\x08\x02\x01\x12\x03m\x02\x14\n\r\n\x05\x04\x08\x02\x01\x04\x12\
    \x04m\x02l\x14\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03m\x02\x08\n\x0c\n\
    \x05\x04\x08\x02\x01\x01\x12\x03m\t\x0f\n\x0c\n\x05\x04\x08\x02\x01\x03\
    \x12\x03m\x12\x13\n\x0b\n\x04\x04\x08\x02\x02\x12\x03n\x02\x11\n\r\n\x05\
    \x04\x08\x02\x02\x04\x12\x04n\x02m\x14\n\x0c\n\x05\x04\x08\x02\x02\x05\
    \x12\x03n\x02\x07\n\x0c\n\x05\x04\x08\x02\x02\x01\x12\x03n\x08\x0c\n\x0c\
    \n\x05\x04\x08\x02\x02\x03\x12\x03n\x0f\x10\n\x0b\n\x04\x04\x08\x02\x03\
    \x12\x03o\x02\x1b\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04o\x02n\x11\n\x0c\
    \n\x05\x04\x08\x02\x03\x05\x12\x03o\x02\x08\n\x0c\n\x05\x04\x08\x02\x03\
    \x01\x12\x03o\t\x16\n\x0c\n\x05\x04\x08\x02\x03\x03\x12\x03o\x19\x1a\n\
    \x0b\n\x04\x04\x08\x02\x04\x12\x03p\x02\x12\n\r\n\x05\x04\x08\x02\x04\
    \x04\x12\x04p\x02o\x1b\n\x0c\n\x05\x04\x08\x02\x04\x05\x12\x03p\x02\x08\
    \n\x0c\n\x05\x04\x08\x02\x04\x01\x12\x03p\t\r\n\x0c\n\x05\x04\x08\x02\
    \x04\x03\x12\x03p\x10\x11\nD\n\x04\x04\x08\x02\x05\x12\x03s\x02\x14\x1a7\
    \x20arbitrary\x20text\x20that\x20may\x20be\x20saved\x20along\x20with\x20\
    the\x20task.\n\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04s\x02p\x12\n\x0c\n\
    \x05\x04\x08\x02\x05\x05\x12\x03s\x02\x08\n\x0c\n\x05\x04\x08\x02\x05\
    \x01\x12\x03s\t\x0f\n\x0c\n\x05\x04\x08\x02\x05\x03\x12\x03s\x12\x13\n\n\
    \n\x02\x04\t\x12\x04v\0}\x01\n\n\n\x03\x04\t\x01\x12\x03v\x08\x19\n\x0b\
    \n\x04\x04\t\x02\0\x12\x03w\x02\x14\n\r\n\x05\x04\t\x02\0\x04\x12\x04w\
    \x02v\x1b\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03w\x02\x08\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03w\t\x0f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03w\x12\x13\n\
    \x0b\n\x04\x04\t\x02\x01\x12\x03x\x02\x14\n\r\n\x05\x04\t\x02\x01\x04\
    \x12\x04x\x02w\x14\n\x0c\n\x05\x04\t\x02\x01\x05\x12\x03x\x02\x08\n\x0c\
    \n\x05\x04\t\x02\x01\x01\x12\x03x\t\x0f\n\x0c\n\x05\x04\t\x02\x01\x03\
    \x12\x03x\x12\x13\n\x0b\n\x04\x04\t\x02\x02\x12\x03z\x02*\n\r\n\x05\x04\
    \t\x02\x02\x04\x12\x04z\x02x\x14\n\x0c\n\x05\x04\t\x02\x02\x06\x12\x03z\
    \x02\x1c\n\x0c\n\x05\x04\t\x02\x02\x01\x12\x03z\x1d%\n\x0c\n\x05\x04\t\
    \x02\x02\x03\x12\x03z()\n\x0b\n\x04\x04\t\x02\x03\x12\x03{\x023\n\r\n\
    \x05\x04\t\x02\x03\x04\x12\x04{\x02z*\n\x0c\n\x05\x04\t\x02\x03\x06\x12\
    \x03{\x02\x1d\n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03{\x1e.\n\x0c\n\x05\
    \x04\t\x02\x03\x03\x12\x03{12\n\x0b\n\x04\x04\t\x02\x04\x12\x03|\x024\n\
    \r\n\x05\x04\t\x02\x04\x04\x12\x04|\x02{3\n\x0c\n\x05\x04\t\x02\x04\x06\
    \x12\x03|\x02\x1d\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03|\x1e/\n\x0c\n\
    \x05\x04\t\x02\x04\x03\x12\x03|23\n\x0b\n\x02\x04\n\x12\x05\x7f\0\x82\
    \x01\x01\n\n\n\x03\x04\n\x01\x12\x03\x7f\x08\x13\n=\n\x04\x04\n\x02\0\
    \x12\x04\x81\x01\x02\x14\x1a/\x20Handle\x20of\x20the\x20task\x20of\x20wh\
    ich\x20to\x20subscribe\x20for.\n\n\x0e\n\x05\x04\n\x02\0\x04\x12\x05\x81\
    \x01\x02\x7f\x15\n\r\n\x05\x04\n\x02\0\x05\x12\x04\x81\x01\x02\x08\n\r\n\
    \x05\x04\n\x02\0\x01\x12\x04\x81\x01\t\x0f\n\r\n\x05\x04\n\x02\0\x03\x12\
    \x04\x81\x01\x12\x13\n\x0c\n\x02\x04\x0b\x12\x06\x84\x01\0\x89\x01\x01\n\
    \x0b\n\x03\x04\x0b\x01\x12\x04\x84\x01\x08\x14\n0\n\x04\x04\x0b\x02\0\
    \x12\x04\x86\x01\x02\x14\x1a\"\x20handle\x20of\x20the\x20task\x20that\
    \x20is\x20done.\n\n\x0f\n\x05\x04\x0b\x02\0\x04\x12\x06\x86\x01\x02\x84\
    \x01\x16\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x86\x01\x02\x08\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\x86\x01\t\x0f\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\x86\x01\x12\x13\n\x1f\n\x04\x04\x0b\x02\x01\x12\x04\x88\x01\x02\x1f\
    \x1a\x11\x20How\x20it\x20ended...\n\n\x0f\n\x05\x04\x0b\x02\x01\x04\x12\
    \x06\x88\x01\x02\x86\x01\x14\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\x88\
    \x01\x02\x13\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\x88\x01\x14\x1a\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\x88\x01\x1d\x1e\n\x0c\n\x02\x04\x0c\x12\
    \x06\x8b\x01\0\x8e\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x8b\x01\x08\
    \x16\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x8c\x01\x02\x10\n\x0f\n\x05\x04\
    \x0c\x02\0\x04\x12\x06\x8c\x01\x02\x8b\x01\x18\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\x8c\x01\x02\x08\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x8c\x01\
    \t\x0b\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x8c\x01\x0e\x0f\n\x0c\n\x04\
    \x04\x0c\x02\x01\x12\x04\x8d\x01\x02\x12\n\x0f\n\x05\x04\x0c\x02\x01\x04\
    \x12\x06\x8d\x01\x02\x8c\x01\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\
    \x8d\x01\x02\x08\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\x8d\x01\t\r\n\r\n\
    \x05\x04\x0c\x02\x01\x03\x12\x04\x8d\x01\x10\x11\n\x0c\n\x02\x04\r\x12\
    \x06\x90\x01\0\x93\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x90\x01\x08\x13\
    \n\x0c\n\x04\x04\r\x02\0\x12\x04\x91\x01\x02\x13\n\x0f\n\x05\x04\r\x02\0\
    \x04\x12\x06\x91\x01\x02\x90\x01\x15\n\r\n\x05\x04\r\x02\0\x05\x12\x04\
    \x91\x01\x02\x07\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x91\x01\x08\x0e\n\r\n\
    \x05\x04\r\x02\0\x03\x12\x04\x91\x01\x11\x12\n\x0c\n\x04\x04\r\x02\x01\
    \x12\x04\x92\x01\x02\x1c\n\x0f\n\x05\x04\r\x02\x01\x04\x12\x06\x92\x01\
    \x02\x91\x01\x13\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\x92\x01\x02\x06\n\r\
    \n\x05\x04\r\x02\x01\x01\x12\x04\x92\x01\x07\x17\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x92\x01\x1a\x1b\n\x0c\n\x02\x06\0\x12\x06\x95\x01\0\xa4\x01\
    \x01\n\x0b\n\x03\x06\0\x01\x12\x04\x95\x01\x08\x0f\n\x0c\n\x04\x06\0\x02\
    \0\x12\x04\x96\x01\x021\n\r\n\x05\x06\0\x02\0\x01\x12\x04\x96\x01\x06\
    \x10\n\r\n\x05\x06\0\x02\0\x02\x12\x04\x96\x01\x11\x1a\n\r\n\x05\x06\0\
    \x02\0\x03\x12\x04\x96\x01%/\n\x0c\n\x04\x06\0\x02\x01\x12\x04\x97\x01\
    \x02.\n\r\n\x05\x06\0\x02\x01\x01\x12\x04\x97\x01\x06\x11\n\r\n\x05\x06\
    \0\x02\x01\x02\x12\x04\x97\x01\x12\x19\n\r\n\x05\x06\0\x02\x01\x03\x12\
    \x04\x97\x01$,\n\x0c\n\x04\x06\0\x02\x02\x12\x04\x98\x01\x02>\n\r\n\x05\
    \x06\0\x02\x02\x01\x12\x04\x98\x01\x06\x0f\n\r\n\x05\x06\0\x02\x02\x02\
    \x12\x04\x98\x01\x10\x1c\n\r\n\x05\x06\0\x02\x02\x03\x12\x04\x98\x01'<\n\
    \x0c\n\x04\x06\0\x02\x03\x12\x04\x99\x01\x02D\n\r\n\x05\x06\0\x02\x03\
    \x01\x12\x04\x99\x01\x06\x12\n\r\n\x05\x06\0\x02\x03\x02\x12\x04\x99\x01\
    \x13\"\n\r\n\x05\x06\0\x02\x03\x03\x12\x04\x99\x01-B\n\x0c\n\x04\x06\0\
    \x02\x04\x12\x04\x9a\x01\x02H\n\r\n\x05\x06\0\x02\x04\x01\x12\x04\x9a\
    \x01\x06\x14\n\r\n\x05\x06\0\x02\x04\x02\x12\x04\x9a\x01\x15&\n\r\n\x05\
    \x06\0\x02\x04\x03\x12\x04\x9a\x011F\n,\n\x04\x06\0\x02\x05\x12\x04\x9d\
    \x01\x026\x1a\x1e\x20Finds\x20a\x20task\x20by\x20id\x20and\x20type.\n\n\
    \r\n\x05\x06\0\x02\x05\x01\x12\x04\x9d\x01\x06\x0e\n\r\n\x05\x06\0\x02\
    \x05\x02\x12\x04\x9d\x01\x0f\x1d\n\r\n\x05\x06\0\x02\x05\x03\x12\x04\x9d\
    \x01(4\n0\n\x04\x06\0\x02\x06\x12\x04\x9f\x01\x02;\x1a\"\x20Finds\x20a\
    \x20task\x20by\x20specific\x20handle.\n\n\r\n\x05\x06\0\x02\x06\x01\x12\
    \x04\x9f\x01\x06\x16\n\r\n\x05\x06\0\x02\x06\x02\x12\x04\x9f\x01\x17\"\n\
    \r\n\x05\x06\0\x02\x06\x03\x12\x04\x9f\x01-9\n<\n\x04\x06\0\x02\x07\x12\
    \x04\xa2\x01\x02B\x1a.\x20admin\x20commands\x20(for\x20now\x20these\x20a\
    re\x20for\x20tests)\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\xa2\x01\x06\n\
    \n\r\n\x05\x06\0\x02\x07\x02\x12\x04\xa2\x01\x0b\x20\n\r\n\x05\x06\0\x02\
    \x07\x03\x12\x04\xa2\x01+@\n\x0c\n\x04\x06\0\x02\x08\x12\x04\xa3\x01\x02\
    J\n\r\n\x05\x06\0\x02\x08\x01\x12\x04\xa3\x01\x06\x12\n\r\n\x05\x06\0\
    \x02\x08\x02\x12\x04\xa3\x01\x13(\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\
    \xa3\x013Hb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
