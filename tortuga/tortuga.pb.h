// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tortuga/tortuga.proto

#ifndef PROTOBUF_tortuga_2ftortuga_2eproto__INCLUDED
#define PROTOBUF_tortuga_2ftortuga_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "google/rpc/status.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_tortuga_2ftortuga_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsWorkerImpl();
void InitDefaultsWorker();
void InitDefaultsHeartbeatReq_WorkerBeatImpl();
void InitDefaultsHeartbeatReq_WorkerBeat();
void InitDefaultsHeartbeatReqImpl();
void InitDefaultsHeartbeatReq();
void InitDefaultsTaskReqImpl();
void InitDefaultsTaskReq();
void InitDefaultsTaskResp_RetryContextImpl();
void InitDefaultsTaskResp_RetryContext();
void InitDefaultsTaskRespImpl();
void InitDefaultsTaskResp();
void InitDefaultsTaskImpl();
void InitDefaultsTask();
void InitDefaultsTaskProgressImpl();
void InitDefaultsTaskProgress();
void InitDefaultsCreateReqImpl();
void InitDefaultsCreateReq();
void InitDefaultsCreateRespImpl();
void InitDefaultsCreateResp();
void InitDefaultsCompleteTaskReqImpl();
void InitDefaultsCompleteTaskReq();
void InitDefaultsUpdateProgressReqImpl();
void InitDefaultsUpdateProgressReq();
void InitDefaultsProgressReqImpl();
void InitDefaultsProgressReq();
void InitDefaultsProgressRespImpl();
void InitDefaultsProgressResp();
void InitDefaultsTaskIdentifierImpl();
void InitDefaultsTaskIdentifier();
inline void InitDefaults() {
  InitDefaultsWorker();
  InitDefaultsHeartbeatReq_WorkerBeat();
  InitDefaultsHeartbeatReq();
  InitDefaultsTaskReq();
  InitDefaultsTaskResp_RetryContext();
  InitDefaultsTaskResp();
  InitDefaultsTask();
  InitDefaultsTaskProgress();
  InitDefaultsCreateReq();
  InitDefaultsCreateResp();
  InitDefaultsCompleteTaskReq();
  InitDefaultsUpdateProgressReq();
  InitDefaultsProgressReq();
  InitDefaultsProgressResp();
  InitDefaultsTaskIdentifier();
}
}  // namespace protobuf_tortuga_2ftortuga_2eproto
namespace tortuga {
class CompleteTaskReq;
class CompleteTaskReqDefaultTypeInternal;
extern CompleteTaskReqDefaultTypeInternal _CompleteTaskReq_default_instance_;
class CreateReq;
class CreateReqDefaultTypeInternal;
extern CreateReqDefaultTypeInternal _CreateReq_default_instance_;
class CreateResp;
class CreateRespDefaultTypeInternal;
extern CreateRespDefaultTypeInternal _CreateResp_default_instance_;
class HeartbeatReq;
class HeartbeatReqDefaultTypeInternal;
extern HeartbeatReqDefaultTypeInternal _HeartbeatReq_default_instance_;
class HeartbeatReq_WorkerBeat;
class HeartbeatReq_WorkerBeatDefaultTypeInternal;
extern HeartbeatReq_WorkerBeatDefaultTypeInternal _HeartbeatReq_WorkerBeat_default_instance_;
class ProgressReq;
class ProgressReqDefaultTypeInternal;
extern ProgressReqDefaultTypeInternal _ProgressReq_default_instance_;
class ProgressResp;
class ProgressRespDefaultTypeInternal;
extern ProgressRespDefaultTypeInternal _ProgressResp_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class TaskIdentifier;
class TaskIdentifierDefaultTypeInternal;
extern TaskIdentifierDefaultTypeInternal _TaskIdentifier_default_instance_;
class TaskProgress;
class TaskProgressDefaultTypeInternal;
extern TaskProgressDefaultTypeInternal _TaskProgress_default_instance_;
class TaskReq;
class TaskReqDefaultTypeInternal;
extern TaskReqDefaultTypeInternal _TaskReq_default_instance_;
class TaskResp;
class TaskRespDefaultTypeInternal;
extern TaskRespDefaultTypeInternal _TaskResp_default_instance_;
class TaskResp_RetryContext;
class TaskResp_RetryContextDefaultTypeInternal;
extern TaskResp_RetryContextDefaultTypeInternal _TaskResp_RetryContext_default_instance_;
class UpdateProgressReq;
class UpdateProgressReqDefaultTypeInternal;
extern UpdateProgressReqDefaultTypeInternal _UpdateProgressReq_default_instance_;
class Worker;
class WorkerDefaultTypeInternal;
extern WorkerDefaultTypeInternal _Worker_default_instance_;
}  // namespace tortuga
namespace tortuga {

// ===================================================================

class Worker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.Worker) */ {
 public:
  Worker();
  virtual ~Worker();

  Worker(const Worker& from);

  inline Worker& operator=(const Worker& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Worker(Worker&& from) noexcept
    : Worker() {
    *this = ::std::move(from);
  }

  inline Worker& operator=(Worker&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Worker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Worker* internal_default_instance() {
    return reinterpret_cast<const Worker*>(
               &_Worker_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Worker* other);
  friend void swap(Worker& a, Worker& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Worker* New() const PROTOBUF_FINAL { return New(NULL); }

  Worker* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Worker& from);
  void MergeFrom(const Worker& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Worker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string capabilities = 3;
  int capabilities_size() const;
  void clear_capabilities();
  static const int kCapabilitiesFieldNumber = 3;
  const ::std::string& capabilities(int index) const;
  ::std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_capabilities(int index, ::std::string&& value);
  #endif
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  ::std::string* add_capabilities();
  void add_capabilities(const ::std::string& value);
  #if LANG_CXX11
  void add_capabilities(::std::string&& value);
  #endif
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& capabilities() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_capabilities();

  // string worker_id = 1;
  void clear_worker_id();
  static const int kWorkerIdFieldNumber = 1;
  const ::std::string& worker_id() const;
  void set_worker_id(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_id(::std::string&& value);
  #endif
  void set_worker_id(const char* value);
  void set_worker_id(const char* value, size_t size);
  ::std::string* mutable_worker_id();
  ::std::string* release_worker_id();
  void set_allocated_worker_id(::std::string* worker_id);

  // string uuid = 2;
  void clear_uuid();
  static const int kUuidFieldNumber = 2;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const char* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:tortuga.Worker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> capabilities_;
  ::google::protobuf::internal::ArenaStringPtr worker_id_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsWorkerImpl();
};
// -------------------------------------------------------------------

class HeartbeatReq_WorkerBeat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.HeartbeatReq.WorkerBeat) */ {
 public:
  HeartbeatReq_WorkerBeat();
  virtual ~HeartbeatReq_WorkerBeat();

  HeartbeatReq_WorkerBeat(const HeartbeatReq_WorkerBeat& from);

  inline HeartbeatReq_WorkerBeat& operator=(const HeartbeatReq_WorkerBeat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatReq_WorkerBeat(HeartbeatReq_WorkerBeat&& from) noexcept
    : HeartbeatReq_WorkerBeat() {
    *this = ::std::move(from);
  }

  inline HeartbeatReq_WorkerBeat& operator=(HeartbeatReq_WorkerBeat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReq_WorkerBeat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatReq_WorkerBeat* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReq_WorkerBeat*>(
               &_HeartbeatReq_WorkerBeat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HeartbeatReq_WorkerBeat* other);
  friend void swap(HeartbeatReq_WorkerBeat& a, HeartbeatReq_WorkerBeat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatReq_WorkerBeat* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatReq_WorkerBeat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatReq_WorkerBeat& from);
  void MergeFrom(const HeartbeatReq_WorkerBeat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeartbeatReq_WorkerBeat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 current_task_handles = 2;
  int current_task_handles_size() const;
  void clear_current_task_handles();
  static const int kCurrentTaskHandlesFieldNumber = 2;
  ::google::protobuf::int64 current_task_handles(int index) const;
  void set_current_task_handles(int index, ::google::protobuf::int64 value);
  void add_current_task_handles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      current_task_handles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_current_task_handles();

  // .tortuga.Worker worker = 1;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 1;
  const ::tortuga::Worker& worker() const;
  ::tortuga::Worker* release_worker();
  ::tortuga::Worker* mutable_worker();
  void set_allocated_worker(::tortuga::Worker* worker);

  // @@protoc_insertion_point(class_scope:tortuga.HeartbeatReq.WorkerBeat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > current_task_handles_;
  mutable int _current_task_handles_cached_byte_size_;
  ::tortuga::Worker* worker_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsHeartbeatReq_WorkerBeatImpl();
};
// -------------------------------------------------------------------

class HeartbeatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.HeartbeatReq) */ {
 public:
  HeartbeatReq();
  virtual ~HeartbeatReq();

  HeartbeatReq(const HeartbeatReq& from);

  inline HeartbeatReq& operator=(const HeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatReq(HeartbeatReq&& from) noexcept
    : HeartbeatReq() {
    *this = ::std::move(from);
  }

  inline HeartbeatReq& operator=(HeartbeatReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatReq* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReq*>(
               &_HeartbeatReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HeartbeatReq* other);
  friend void swap(HeartbeatReq& a, HeartbeatReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatReq* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatReq& from);
  void MergeFrom(const HeartbeatReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeartbeatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HeartbeatReq_WorkerBeat WorkerBeat;

  // accessors -------------------------------------------------------

  // repeated .tortuga.HeartbeatReq.WorkerBeat worker_beats = 1;
  int worker_beats_size() const;
  void clear_worker_beats();
  static const int kWorkerBeatsFieldNumber = 1;
  const ::tortuga::HeartbeatReq_WorkerBeat& worker_beats(int index) const;
  ::tortuga::HeartbeatReq_WorkerBeat* mutable_worker_beats(int index);
  ::tortuga::HeartbeatReq_WorkerBeat* add_worker_beats();
  ::google::protobuf::RepeatedPtrField< ::tortuga::HeartbeatReq_WorkerBeat >*
      mutable_worker_beats();
  const ::google::protobuf::RepeatedPtrField< ::tortuga::HeartbeatReq_WorkerBeat >&
      worker_beats() const;

  // @@protoc_insertion_point(class_scope:tortuga.HeartbeatReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tortuga::HeartbeatReq_WorkerBeat > worker_beats_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsHeartbeatReqImpl();
};
// -------------------------------------------------------------------

class TaskReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.TaskReq) */ {
 public:
  TaskReq();
  virtual ~TaskReq();

  TaskReq(const TaskReq& from);

  inline TaskReq& operator=(const TaskReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskReq(TaskReq&& from) noexcept
    : TaskReq() {
    *this = ::std::move(from);
  }

  inline TaskReq& operator=(TaskReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskReq* internal_default_instance() {
    return reinterpret_cast<const TaskReq*>(
               &_TaskReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TaskReq* other);
  friend void swap(TaskReq& a, TaskReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskReq* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskReq& from);
  void MergeFrom(const TaskReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tortuga.Worker worker = 1;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 1;
  const ::tortuga::Worker& worker() const;
  ::tortuga::Worker* release_worker();
  ::tortuga::Worker* mutable_worker();
  void set_allocated_worker(::tortuga::Worker* worker);

  // @@protoc_insertion_point(class_scope:tortuga.TaskReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tortuga::Worker* worker_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskReqImpl();
};
// -------------------------------------------------------------------

class TaskResp_RetryContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.TaskResp.RetryContext) */ {
 public:
  TaskResp_RetryContext();
  virtual ~TaskResp_RetryContext();

  TaskResp_RetryContext(const TaskResp_RetryContext& from);

  inline TaskResp_RetryContext& operator=(const TaskResp_RetryContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskResp_RetryContext(TaskResp_RetryContext&& from) noexcept
    : TaskResp_RetryContext() {
    *this = ::std::move(from);
  }

  inline TaskResp_RetryContext& operator=(TaskResp_RetryContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskResp_RetryContext& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskResp_RetryContext* internal_default_instance() {
    return reinterpret_cast<const TaskResp_RetryContext*>(
               &_TaskResp_RetryContext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(TaskResp_RetryContext* other);
  friend void swap(TaskResp_RetryContext& a, TaskResp_RetryContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskResp_RetryContext* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskResp_RetryContext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskResp_RetryContext& from);
  void MergeFrom(const TaskResp_RetryContext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskResp_RetryContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string progress_metadata = 2;
  void clear_progress_metadata();
  static const int kProgressMetadataFieldNumber = 2;
  const ::std::string& progress_metadata() const;
  void set_progress_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_progress_metadata(::std::string&& value);
  #endif
  void set_progress_metadata(const char* value);
  void set_progress_metadata(const char* value, size_t size);
  ::std::string* mutable_progress_metadata();
  ::std::string* release_progress_metadata();
  void set_allocated_progress_metadata(::std::string* progress_metadata);

  // int32 retries = 1;
  void clear_retries();
  static const int kRetriesFieldNumber = 1;
  ::google::protobuf::int32 retries() const;
  void set_retries(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tortuga.TaskResp.RetryContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr progress_metadata_;
  ::google::protobuf::int32 retries_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskResp_RetryContextImpl();
};
// -------------------------------------------------------------------

class TaskResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.TaskResp) */ {
 public:
  TaskResp();
  virtual ~TaskResp();

  TaskResp(const TaskResp& from);

  inline TaskResp& operator=(const TaskResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskResp(TaskResp&& from) noexcept
    : TaskResp() {
    *this = ::std::move(from);
  }

  inline TaskResp& operator=(TaskResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskResp* internal_default_instance() {
    return reinterpret_cast<const TaskResp*>(
               &_TaskResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(TaskResp* other);
  friend void swap(TaskResp& a, TaskResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskResp* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskResp& from);
  void MergeFrom(const TaskResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TaskResp_RetryContext RetryContext;

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string handle = 4;
  void clear_handle();
  static const int kHandleFieldNumber = 4;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // .google.protobuf.Any data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::google::protobuf::Any& data() const;
  ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* data);

  // .tortuga.TaskResp.RetryContext retry_ctx = 6;
  bool has_retry_ctx() const;
  void clear_retry_ctx();
  static const int kRetryCtxFieldNumber = 6;
  const ::tortuga::TaskResp_RetryContext& retry_ctx() const;
  ::tortuga::TaskResp_RetryContext* release_retry_ctx();
  ::tortuga::TaskResp_RetryContext* mutable_retry_ctx();
  void set_allocated_retry_ctx(::tortuga::TaskResp_RetryContext* retry_ctx);

  // bool none = 5;
  void clear_none();
  static const int kNoneFieldNumber = 5;
  bool none() const;
  void set_none(bool value);

  // @@protoc_insertion_point(class_scope:tortuga.TaskResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::Any* data_;
  ::tortuga::TaskResp_RetryContext* retry_ctx_;
  bool none_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskRespImpl();
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Task* other);
  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const PROTOBUF_FINAL { return New(NULL); }

  Task* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string modules = 7;
  int modules_size() const;
  void clear_modules();
  static const int kModulesFieldNumber = 7;
  const ::std::string& modules(int index) const;
  ::std::string* mutable_modules(int index);
  void set_modules(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_modules(int index, ::std::string&& value);
  #endif
  void set_modules(int index, const char* value);
  void set_modules(int index, const char* value, size_t size);
  ::std::string* add_modules();
  void add_modules(const ::std::string& value);
  #if LANG_CXX11
  void add_modules(::std::string&& value);
  #endif
  void add_modules(const char* value);
  void add_modules(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& modules() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_modules();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .google.protobuf.Any data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::google::protobuf::Any& data() const;
  ::google::protobuf::Any* release_data();
  ::google::protobuf::Any* mutable_data();
  void set_allocated_data(::google::protobuf::Any* data);

  // .google.protobuf.Int32Value priority = 4;
  bool has_priority() const;
  void clear_priority();
  static const int kPriorityFieldNumber = 4;
  const ::google::protobuf::Int32Value& priority() const;
  ::google::protobuf::Int32Value* release_priority();
  ::google::protobuf::Int32Value* mutable_priority();
  void set_allocated_priority(::google::protobuf::Int32Value* priority);

  // .google.protobuf.Int32Value max_retries = 5;
  bool has_max_retries() const;
  void clear_max_retries();
  static const int kMaxRetriesFieldNumber = 5;
  const ::google::protobuf::Int32Value& max_retries() const;
  ::google::protobuf::Int32Value* release_max_retries();
  ::google::protobuf::Int32Value* mutable_max_retries();
  void set_allocated_max_retries(::google::protobuf::Int32Value* max_retries);

  // .google.protobuf.Duration delay = 6;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 6;
  const ::google::protobuf::Duration& delay() const;
  ::google::protobuf::Duration* release_delay();
  ::google::protobuf::Duration* mutable_delay();
  void set_allocated_delay(::google::protobuf::Duration* delay);

  // @@protoc_insertion_point(class_scope:tortuga.Task)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> modules_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::Any* data_;
  ::google::protobuf::Int32Value* priority_;
  ::google::protobuf::Int32Value* max_retries_;
  ::google::protobuf::Duration* delay_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskImpl();
};
// -------------------------------------------------------------------

class TaskProgress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.TaskProgress) */ {
 public:
  TaskProgress();
  virtual ~TaskProgress();

  TaskProgress(const TaskProgress& from);

  inline TaskProgress& operator=(const TaskProgress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskProgress(TaskProgress&& from) noexcept
    : TaskProgress() {
    *this = ::std::move(from);
  }

  inline TaskProgress& operator=(TaskProgress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskProgress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskProgress* internal_default_instance() {
    return reinterpret_cast<const TaskProgress*>(
               &_TaskProgress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(TaskProgress* other);
  friend void swap(TaskProgress& a, TaskProgress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskProgress* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskProgress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskProgress& from);
  void MergeFrom(const TaskProgress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskProgress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 1;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // string id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // string progress_message = 14;
  void clear_progress_message();
  static const int kProgressMessageFieldNumber = 14;
  const ::std::string& progress_message() const;
  void set_progress_message(const ::std::string& value);
  #if LANG_CXX11
  void set_progress_message(::std::string&& value);
  #endif
  void set_progress_message(const char* value);
  void set_progress_message(const char* value, size_t size);
  ::std::string* mutable_progress_message();
  ::std::string* release_progress_message();
  void set_allocated_progress_message(::std::string* progress_message);

  // string logs = 15;
  void clear_logs();
  static const int kLogsFieldNumber = 15;
  const ::std::string& logs() const;
  void set_logs(const ::std::string& value);
  #if LANG_CXX11
  void set_logs(::std::string&& value);
  #endif
  void set_logs(const char* value);
  void set_logs(const char* value, size_t size);
  ::std::string* mutable_logs();
  ::std::string* release_logs();
  void set_allocated_logs(::std::string* logs);

  // string worker_id = 16;
  void clear_worker_id();
  static const int kWorkerIdFieldNumber = 16;
  const ::std::string& worker_id() const;
  void set_worker_id(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_id(::std::string&& value);
  #endif
  void set_worker_id(const char* value);
  void set_worker_id(const char* value, size_t size);
  ::std::string* mutable_worker_id();
  ::std::string* release_worker_id();
  void set_allocated_worker_id(::std::string* worker_id);

  // string output = 17;
  void clear_output();
  static const int kOutputFieldNumber = 17;
  const ::std::string& output() const;
  void set_output(const ::std::string& value);
  #if LANG_CXX11
  void set_output(::std::string&& value);
  #endif
  void set_output(const char* value);
  void set_output(const char* value, size_t size);
  ::std::string* mutable_output();
  ::std::string* release_output();
  void set_allocated_output(::std::string* output);

  // string progress_metadata = 18;
  void clear_progress_metadata();
  static const int kProgressMetadataFieldNumber = 18;
  const ::std::string& progress_metadata() const;
  void set_progress_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_progress_metadata(::std::string&& value);
  #endif
  void set_progress_metadata(const char* value);
  void set_progress_metadata(const char* value, size_t size);
  ::std::string* mutable_progress_metadata();
  ::std::string* release_progress_metadata();
  void set_allocated_progress_metadata(::std::string* progress_metadata);

  // .google.protobuf.Timestamp created = 9;
  bool has_created() const;
  void clear_created();
  static const int kCreatedFieldNumber = 9;
  const ::google::protobuf::Timestamp& created() const;
  ::google::protobuf::Timestamp* release_created();
  ::google::protobuf::Timestamp* mutable_created();
  void set_allocated_created(::google::protobuf::Timestamp* created);

  // .google.protobuf.Timestamp started_time = 10;
  bool has_started_time() const;
  void clear_started_time();
  static const int kStartedTimeFieldNumber = 10;
  const ::google::protobuf::Timestamp& started_time() const;
  ::google::protobuf::Timestamp* release_started_time();
  ::google::protobuf::Timestamp* mutable_started_time();
  void set_allocated_started_time(::google::protobuf::Timestamp* started_time);

  // .google.protobuf.Timestamp done_time = 11;
  bool has_done_time() const;
  void clear_done_time();
  static const int kDoneTimeFieldNumber = 11;
  const ::google::protobuf::Timestamp& done_time() const;
  ::google::protobuf::Timestamp* release_done_time();
  ::google::protobuf::Timestamp* mutable_done_time();
  void set_allocated_done_time(::google::protobuf::Timestamp* done_time);

  // .google.rpc.Status status = 12;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 12;
  const ::google::rpc::Status& status() const;
  ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);

  // int32 max_retries = 4;
  void clear_max_retries();
  static const int kMaxRetriesFieldNumber = 4;
  ::google::protobuf::int32 max_retries() const;
  void set_max_retries(::google::protobuf::int32 value);

  // int32 retries = 5;
  void clear_retries();
  static const int kRetriesFieldNumber = 5;
  ::google::protobuf::int32 retries() const;
  void set_retries(::google::protobuf::int32 value);

  // int32 priority = 6;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // bool worked_on = 7;
  void clear_worked_on();
  static const int kWorkedOnFieldNumber = 7;
  bool worked_on() const;
  void set_worked_on(bool value);

  // bool done = 8;
  void clear_done();
  static const int kDoneFieldNumber = 8;
  bool done() const;
  void set_done(bool value);

  // float progress = 13;
  void clear_progress();
  static const int kProgressFieldNumber = 13;
  float progress() const;
  void set_progress(float value);

  // @@protoc_insertion_point(class_scope:tortuga.TaskProgress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr progress_message_;
  ::google::protobuf::internal::ArenaStringPtr logs_;
  ::google::protobuf::internal::ArenaStringPtr worker_id_;
  ::google::protobuf::internal::ArenaStringPtr output_;
  ::google::protobuf::internal::ArenaStringPtr progress_metadata_;
  ::google::protobuf::Timestamp* created_;
  ::google::protobuf::Timestamp* started_time_;
  ::google::protobuf::Timestamp* done_time_;
  ::google::rpc::Status* status_;
  ::google::protobuf::int32 max_retries_;
  ::google::protobuf::int32 retries_;
  ::google::protobuf::int32 priority_;
  bool worked_on_;
  bool done_;
  float progress_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskProgressImpl();
};
// -------------------------------------------------------------------

class CreateReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.CreateReq) */ {
 public:
  CreateReq();
  virtual ~CreateReq();

  CreateReq(const CreateReq& from);

  inline CreateReq& operator=(const CreateReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateReq(CreateReq&& from) noexcept
    : CreateReq() {
    *this = ::std::move(from);
  }

  inline CreateReq& operator=(CreateReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateReq* internal_default_instance() {
    return reinterpret_cast<const CreateReq*>(
               &_CreateReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CreateReq* other);
  friend void swap(CreateReq& a, CreateReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateReq& from);
  void MergeFrom(const CreateReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tortuga.Task task = 1;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 1;
  const ::tortuga::Task& task() const;
  ::tortuga::Task* release_task();
  ::tortuga::Task* mutable_task();
  void set_allocated_task(::tortuga::Task* task);

  // @@protoc_insertion_point(class_scope:tortuga.CreateReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tortuga::Task* task_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsCreateReqImpl();
};
// -------------------------------------------------------------------

class CreateResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.CreateResp) */ {
 public:
  CreateResp();
  virtual ~CreateResp();

  CreateResp(const CreateResp& from);

  inline CreateResp& operator=(const CreateResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateResp(CreateResp&& from) noexcept
    : CreateResp() {
    *this = ::std::move(from);
  }

  inline CreateResp& operator=(CreateResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateResp* internal_default_instance() {
    return reinterpret_cast<const CreateResp*>(
               &_CreateResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CreateResp* other);
  friend void swap(CreateResp& a, CreateResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateResp* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateResp& from);
  void MergeFrom(const CreateResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 1;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // bool created = 2;
  void clear_created();
  static const int kCreatedFieldNumber = 2;
  bool created() const;
  void set_created(bool value);

  // @@protoc_insertion_point(class_scope:tortuga.CreateResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  bool created_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsCreateRespImpl();
};
// -------------------------------------------------------------------

class CompleteTaskReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.CompleteTaskReq) */ {
 public:
  CompleteTaskReq();
  virtual ~CompleteTaskReq();

  CompleteTaskReq(const CompleteTaskReq& from);

  inline CompleteTaskReq& operator=(const CompleteTaskReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompleteTaskReq(CompleteTaskReq&& from) noexcept
    : CompleteTaskReq() {
    *this = ::std::move(from);
  }

  inline CompleteTaskReq& operator=(CompleteTaskReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompleteTaskReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompleteTaskReq* internal_default_instance() {
    return reinterpret_cast<const CompleteTaskReq*>(
               &_CompleteTaskReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CompleteTaskReq* other);
  friend void swap(CompleteTaskReq& a, CompleteTaskReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompleteTaskReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CompleteTaskReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CompleteTaskReq& from);
  void MergeFrom(const CompleteTaskReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CompleteTaskReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 2;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // string error_message = 4;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 4;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // string logs = 5;
  void clear_logs();
  static const int kLogsFieldNumber = 5;
  const ::std::string& logs() const;
  void set_logs(const ::std::string& value);
  #if LANG_CXX11
  void set_logs(::std::string&& value);
  #endif
  void set_logs(const char* value);
  void set_logs(const char* value, size_t size);
  ::std::string* mutable_logs();
  ::std::string* release_logs();
  void set_allocated_logs(::std::string* logs);

  // string output = 6;
  void clear_output();
  static const int kOutputFieldNumber = 6;
  const ::std::string& output() const;
  void set_output(const ::std::string& value);
  #if LANG_CXX11
  void set_output(::std::string&& value);
  #endif
  void set_output(const char* value);
  void set_output(const char* value, size_t size);
  ::std::string* mutable_output();
  ::std::string* release_output();
  void set_allocated_output(::std::string* output);

  // .tortuga.Worker worker = 1;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 1;
  const ::tortuga::Worker& worker() const;
  ::tortuga::Worker* release_worker();
  ::tortuga::Worker* mutable_worker();
  void set_allocated_worker(::tortuga::Worker* worker);

  // int32 code = 3;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tortuga.CompleteTaskReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::internal::ArenaStringPtr logs_;
  ::google::protobuf::internal::ArenaStringPtr output_;
  ::tortuga::Worker* worker_;
  ::google::protobuf::int32 code_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsCompleteTaskReqImpl();
};
// -------------------------------------------------------------------

class UpdateProgressReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.UpdateProgressReq) */ {
 public:
  UpdateProgressReq();
  virtual ~UpdateProgressReq();

  UpdateProgressReq(const UpdateProgressReq& from);

  inline UpdateProgressReq& operator=(const UpdateProgressReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateProgressReq(UpdateProgressReq&& from) noexcept
    : UpdateProgressReq() {
    *this = ::std::move(from);
  }

  inline UpdateProgressReq& operator=(UpdateProgressReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateProgressReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateProgressReq* internal_default_instance() {
    return reinterpret_cast<const UpdateProgressReq*>(
               &_UpdateProgressReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(UpdateProgressReq* other);
  friend void swap(UpdateProgressReq& a, UpdateProgressReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateProgressReq* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdateProgressReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdateProgressReq& from);
  void MergeFrom(const UpdateProgressReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdateProgressReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 2;
  void clear_handle();
  static const int kHandleFieldNumber = 2;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // .tortuga.Worker worker = 1;
  bool has_worker() const;
  void clear_worker();
  static const int kWorkerFieldNumber = 1;
  const ::tortuga::Worker& worker() const;
  ::tortuga::Worker* release_worker();
  ::tortuga::Worker* mutable_worker();
  void set_allocated_worker(::tortuga::Worker* worker);

  // .google.protobuf.FloatValue progress = 3;
  bool has_progress() const;
  void clear_progress();
  static const int kProgressFieldNumber = 3;
  const ::google::protobuf::FloatValue& progress() const;
  ::google::protobuf::FloatValue* release_progress();
  ::google::protobuf::FloatValue* mutable_progress();
  void set_allocated_progress(::google::protobuf::FloatValue* progress);

  // .google.protobuf.StringValue progress_message = 4;
  bool has_progress_message() const;
  void clear_progress_message();
  static const int kProgressMessageFieldNumber = 4;
  const ::google::protobuf::StringValue& progress_message() const;
  ::google::protobuf::StringValue* release_progress_message();
  ::google::protobuf::StringValue* mutable_progress_message();
  void set_allocated_progress_message(::google::protobuf::StringValue* progress_message);

  // .google.protobuf.StringValue progress_metadata = 5;
  bool has_progress_metadata() const;
  void clear_progress_metadata();
  static const int kProgressMetadataFieldNumber = 5;
  const ::google::protobuf::StringValue& progress_metadata() const;
  ::google::protobuf::StringValue* release_progress_metadata();
  ::google::protobuf::StringValue* mutable_progress_metadata();
  void set_allocated_progress_metadata(::google::protobuf::StringValue* progress_metadata);

  // @@protoc_insertion_point(class_scope:tortuga.UpdateProgressReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::tortuga::Worker* worker_;
  ::google::protobuf::FloatValue* progress_;
  ::google::protobuf::StringValue* progress_message_;
  ::google::protobuf::StringValue* progress_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsUpdateProgressReqImpl();
};
// -------------------------------------------------------------------

class ProgressReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.ProgressReq) */ {
 public:
  ProgressReq();
  virtual ~ProgressReq();

  ProgressReq(const ProgressReq& from);

  inline ProgressReq& operator=(const ProgressReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProgressReq(ProgressReq&& from) noexcept
    : ProgressReq() {
    *this = ::std::move(from);
  }

  inline ProgressReq& operator=(ProgressReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProgressReq* internal_default_instance() {
    return reinterpret_cast<const ProgressReq*>(
               &_ProgressReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ProgressReq* other);
  friend void swap(ProgressReq& a, ProgressReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProgressReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ProgressReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProgressReq& from);
  void MergeFrom(const ProgressReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProgressReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 1;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // @@protoc_insertion_point(class_scope:tortuga.ProgressReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsProgressReqImpl();
};
// -------------------------------------------------------------------

class ProgressResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.ProgressResp) */ {
 public:
  ProgressResp();
  virtual ~ProgressResp();

  ProgressResp(const ProgressResp& from);

  inline ProgressResp& operator=(const ProgressResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProgressResp(ProgressResp&& from) noexcept
    : ProgressResp() {
    *this = ::std::move(from);
  }

  inline ProgressResp& operator=(ProgressResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProgressResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProgressResp* internal_default_instance() {
    return reinterpret_cast<const ProgressResp*>(
               &_ProgressResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ProgressResp* other);
  friend void swap(ProgressResp& a, ProgressResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProgressResp* New() const PROTOBUF_FINAL { return New(NULL); }

  ProgressResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProgressResp& from);
  void MergeFrom(const ProgressResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProgressResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string handle = 1;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  const ::std::string& handle() const;
  void set_handle(const ::std::string& value);
  #if LANG_CXX11
  void set_handle(::std::string&& value);
  #endif
  void set_handle(const char* value);
  void set_handle(const char* value, size_t size);
  ::std::string* mutable_handle();
  ::std::string* release_handle();
  void set_allocated_handle(::std::string* handle);

  // .google.rpc.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  const ::google::rpc::Status& status() const;
  ::google::rpc::Status* release_status();
  ::google::rpc::Status* mutable_status();
  void set_allocated_status(::google::rpc::Status* status);

  // @@protoc_insertion_point(class_scope:tortuga.ProgressResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr handle_;
  ::google::rpc::Status* status_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsProgressRespImpl();
};
// -------------------------------------------------------------------

class TaskIdentifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tortuga.TaskIdentifier) */ {
 public:
  TaskIdentifier();
  virtual ~TaskIdentifier();

  TaskIdentifier(const TaskIdentifier& from);

  inline TaskIdentifier& operator=(const TaskIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskIdentifier(TaskIdentifier&& from) noexcept
    : TaskIdentifier() {
    *this = ::std::move(from);
  }

  inline TaskIdentifier& operator=(TaskIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskIdentifier* internal_default_instance() {
    return reinterpret_cast<const TaskIdentifier*>(
               &_TaskIdentifier_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(TaskIdentifier* other);
  friend void swap(TaskIdentifier& a, TaskIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskIdentifier* New() const PROTOBUF_FINAL { return New(NULL); }

  TaskIdentifier* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TaskIdentifier& from);
  void MergeFrom(const TaskIdentifier& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TaskIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:tortuga.TaskIdentifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  mutable int _cached_size_;
  friend struct ::protobuf_tortuga_2ftortuga_2eproto::TableStruct;
  friend void ::protobuf_tortuga_2ftortuga_2eproto::InitDefaultsTaskIdentifierImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Worker

// string worker_id = 1;
inline void Worker::clear_worker_id() {
  worker_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Worker::worker_id() const {
  // @@protoc_insertion_point(field_get:tortuga.Worker.worker_id)
  return worker_id_.GetNoArena();
}
inline void Worker::set_worker_id(const ::std::string& value) {
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.Worker.worker_id)
}
#if LANG_CXX11
inline void Worker::set_worker_id(::std::string&& value) {
  
  worker_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.Worker.worker_id)
}
#endif
inline void Worker::set_worker_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.Worker.worker_id)
}
inline void Worker::set_worker_id(const char* value, size_t size) {
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.Worker.worker_id)
}
inline ::std::string* Worker::mutable_worker_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.Worker.worker_id)
  return worker_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Worker::release_worker_id() {
  // @@protoc_insertion_point(field_release:tortuga.Worker.worker_id)
  
  return worker_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Worker::set_allocated_worker_id(::std::string* worker_id) {
  if (worker_id != NULL) {
    
  } else {
    
  }
  worker_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.Worker.worker_id)
}

// string uuid = 2;
inline void Worker::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Worker::uuid() const {
  // @@protoc_insertion_point(field_get:tortuga.Worker.uuid)
  return uuid_.GetNoArena();
}
inline void Worker::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.Worker.uuid)
}
#if LANG_CXX11
inline void Worker::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.Worker.uuid)
}
#endif
inline void Worker::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.Worker.uuid)
}
inline void Worker::set_uuid(const char* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.Worker.uuid)
}
inline ::std::string* Worker::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.Worker.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Worker::release_uuid() {
  // @@protoc_insertion_point(field_release:tortuga.Worker.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Worker::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:tortuga.Worker.uuid)
}

// repeated string capabilities = 3;
inline int Worker::capabilities_size() const {
  return capabilities_.size();
}
inline void Worker::clear_capabilities() {
  capabilities_.Clear();
}
inline const ::std::string& Worker::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:tortuga.Worker.capabilities)
  return capabilities_.Get(index);
}
inline ::std::string* Worker::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:tortuga.Worker.capabilities)
  return capabilities_.Mutable(index);
}
inline void Worker::set_capabilities(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tortuga.Worker.capabilities)
  capabilities_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Worker::set_capabilities(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tortuga.Worker.capabilities)
  capabilities_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Worker::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tortuga.Worker.capabilities)
}
inline void Worker::set_capabilities(int index, const char* value, size_t size) {
  capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tortuga.Worker.capabilities)
}
inline ::std::string* Worker::add_capabilities() {
  // @@protoc_insertion_point(field_add_mutable:tortuga.Worker.capabilities)
  return capabilities_.Add();
}
inline void Worker::add_capabilities(const ::std::string& value) {
  capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tortuga.Worker.capabilities)
}
#if LANG_CXX11
inline void Worker::add_capabilities(::std::string&& value) {
  capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tortuga.Worker.capabilities)
}
#endif
inline void Worker::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tortuga.Worker.capabilities)
}
inline void Worker::add_capabilities(const char* value, size_t size) {
  capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tortuga.Worker.capabilities)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Worker::capabilities() const {
  // @@protoc_insertion_point(field_list:tortuga.Worker.capabilities)
  return capabilities_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Worker::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:tortuga.Worker.capabilities)
  return &capabilities_;
}

// -------------------------------------------------------------------

// HeartbeatReq_WorkerBeat

// .tortuga.Worker worker = 1;
inline bool HeartbeatReq_WorkerBeat::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void HeartbeatReq_WorkerBeat::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) {
    delete worker_;
  }
  worker_ = NULL;
}
inline const ::tortuga::Worker& HeartbeatReq_WorkerBeat::worker() const {
  const ::tortuga::Worker* p = worker_;
  // @@protoc_insertion_point(field_get:tortuga.HeartbeatReq.WorkerBeat.worker)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::Worker*>(
      &::tortuga::_Worker_default_instance_);
}
inline ::tortuga::Worker* HeartbeatReq_WorkerBeat::release_worker() {
  // @@protoc_insertion_point(field_release:tortuga.HeartbeatReq.WorkerBeat.worker)
  
  ::tortuga::Worker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline ::tortuga::Worker* HeartbeatReq_WorkerBeat::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::tortuga::Worker;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.HeartbeatReq.WorkerBeat.worker)
  return worker_;
}
inline void HeartbeatReq_WorkerBeat::set_allocated_worker(::tortuga::Worker* worker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete worker_;
  }
  if (worker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      worker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, worker, submessage_arena);
    }
    
  } else {
    
  }
  worker_ = worker;
  // @@protoc_insertion_point(field_set_allocated:tortuga.HeartbeatReq.WorkerBeat.worker)
}

// repeated int64 current_task_handles = 2;
inline int HeartbeatReq_WorkerBeat::current_task_handles_size() const {
  return current_task_handles_.size();
}
inline void HeartbeatReq_WorkerBeat::clear_current_task_handles() {
  current_task_handles_.Clear();
}
inline ::google::protobuf::int64 HeartbeatReq_WorkerBeat::current_task_handles(int index) const {
  // @@protoc_insertion_point(field_get:tortuga.HeartbeatReq.WorkerBeat.current_task_handles)
  return current_task_handles_.Get(index);
}
inline void HeartbeatReq_WorkerBeat::set_current_task_handles(int index, ::google::protobuf::int64 value) {
  current_task_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:tortuga.HeartbeatReq.WorkerBeat.current_task_handles)
}
inline void HeartbeatReq_WorkerBeat::add_current_task_handles(::google::protobuf::int64 value) {
  current_task_handles_.Add(value);
  // @@protoc_insertion_point(field_add:tortuga.HeartbeatReq.WorkerBeat.current_task_handles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
HeartbeatReq_WorkerBeat::current_task_handles() const {
  // @@protoc_insertion_point(field_list:tortuga.HeartbeatReq.WorkerBeat.current_task_handles)
  return current_task_handles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
HeartbeatReq_WorkerBeat::mutable_current_task_handles() {
  // @@protoc_insertion_point(field_mutable_list:tortuga.HeartbeatReq.WorkerBeat.current_task_handles)
  return &current_task_handles_;
}

// -------------------------------------------------------------------

// HeartbeatReq

// repeated .tortuga.HeartbeatReq.WorkerBeat worker_beats = 1;
inline int HeartbeatReq::worker_beats_size() const {
  return worker_beats_.size();
}
inline void HeartbeatReq::clear_worker_beats() {
  worker_beats_.Clear();
}
inline const ::tortuga::HeartbeatReq_WorkerBeat& HeartbeatReq::worker_beats(int index) const {
  // @@protoc_insertion_point(field_get:tortuga.HeartbeatReq.worker_beats)
  return worker_beats_.Get(index);
}
inline ::tortuga::HeartbeatReq_WorkerBeat* HeartbeatReq::mutable_worker_beats(int index) {
  // @@protoc_insertion_point(field_mutable:tortuga.HeartbeatReq.worker_beats)
  return worker_beats_.Mutable(index);
}
inline ::tortuga::HeartbeatReq_WorkerBeat* HeartbeatReq::add_worker_beats() {
  // @@protoc_insertion_point(field_add:tortuga.HeartbeatReq.worker_beats)
  return worker_beats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tortuga::HeartbeatReq_WorkerBeat >*
HeartbeatReq::mutable_worker_beats() {
  // @@protoc_insertion_point(field_mutable_list:tortuga.HeartbeatReq.worker_beats)
  return &worker_beats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tortuga::HeartbeatReq_WorkerBeat >&
HeartbeatReq::worker_beats() const {
  // @@protoc_insertion_point(field_list:tortuga.HeartbeatReq.worker_beats)
  return worker_beats_;
}

// -------------------------------------------------------------------

// TaskReq

// .tortuga.Worker worker = 1;
inline bool TaskReq::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void TaskReq::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) {
    delete worker_;
  }
  worker_ = NULL;
}
inline const ::tortuga::Worker& TaskReq::worker() const {
  const ::tortuga::Worker* p = worker_;
  // @@protoc_insertion_point(field_get:tortuga.TaskReq.worker)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::Worker*>(
      &::tortuga::_Worker_default_instance_);
}
inline ::tortuga::Worker* TaskReq::release_worker() {
  // @@protoc_insertion_point(field_release:tortuga.TaskReq.worker)
  
  ::tortuga::Worker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline ::tortuga::Worker* TaskReq::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::tortuga::Worker;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskReq.worker)
  return worker_;
}
inline void TaskReq::set_allocated_worker(::tortuga::Worker* worker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete worker_;
  }
  if (worker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      worker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, worker, submessage_arena);
    }
    
  } else {
    
  }
  worker_ = worker;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskReq.worker)
}

// -------------------------------------------------------------------

// TaskResp_RetryContext

// int32 retries = 1;
inline void TaskResp_RetryContext::clear_retries() {
  retries_ = 0;
}
inline ::google::protobuf::int32 TaskResp_RetryContext::retries() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.RetryContext.retries)
  return retries_;
}
inline void TaskResp_RetryContext::set_retries(::google::protobuf::int32 value) {
  
  retries_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.RetryContext.retries)
}

// string progress_metadata = 2;
inline void TaskResp_RetryContext::clear_progress_metadata() {
  progress_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResp_RetryContext::progress_metadata() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.RetryContext.progress_metadata)
  return progress_metadata_.GetNoArena();
}
inline void TaskResp_RetryContext::set_progress_metadata(const ::std::string& value) {
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.RetryContext.progress_metadata)
}
#if LANG_CXX11
inline void TaskResp_RetryContext::set_progress_metadata(::std::string&& value) {
  
  progress_metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskResp.RetryContext.progress_metadata)
}
#endif
inline void TaskResp_RetryContext::set_progress_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskResp.RetryContext.progress_metadata)
}
inline void TaskResp_RetryContext::set_progress_metadata(const char* value, size_t size) {
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskResp.RetryContext.progress_metadata)
}
inline ::std::string* TaskResp_RetryContext::mutable_progress_metadata() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.RetryContext.progress_metadata)
  return progress_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResp_RetryContext::release_progress_metadata() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.RetryContext.progress_metadata)
  
  return progress_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResp_RetryContext::set_allocated_progress_metadata(::std::string* progress_metadata) {
  if (progress_metadata != NULL) {
    
  } else {
    
  }
  progress_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), progress_metadata);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.RetryContext.progress_metadata)
}

// -------------------------------------------------------------------

// TaskResp

// string id = 1;
inline void TaskResp::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResp::id() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.id)
  return id_.GetNoArena();
}
inline void TaskResp::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.id)
}
#if LANG_CXX11
inline void TaskResp::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskResp.id)
}
#endif
inline void TaskResp::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskResp.id)
}
inline void TaskResp::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskResp.id)
}
inline ::std::string* TaskResp::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResp::release_id() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResp::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.id)
}

// string type = 2;
inline void TaskResp::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResp::type() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.type)
  return type_.GetNoArena();
}
inline void TaskResp::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.type)
}
#if LANG_CXX11
inline void TaskResp::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskResp.type)
}
#endif
inline void TaskResp::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskResp.type)
}
inline void TaskResp::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskResp.type)
}
inline ::std::string* TaskResp::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResp::release_type() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResp::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.type)
}

// .google.protobuf.Any data = 3;
inline bool TaskResp::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::google::protobuf::Any& TaskResp::data() const {
  const ::google::protobuf::Any* p = data_;
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.data)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* TaskResp::release_data() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.data)
  
  ::google::protobuf::Any* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* TaskResp::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.data)
  return data_;
}
inline void TaskResp::set_allocated_data(::google::protobuf::Any* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.data)
}

// string handle = 4;
inline void TaskResp::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskResp::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.handle)
  return handle_.GetNoArena();
}
inline void TaskResp::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.handle)
}
#if LANG_CXX11
inline void TaskResp::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskResp.handle)
}
#endif
inline void TaskResp::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskResp.handle)
}
inline void TaskResp::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskResp.handle)
}
inline ::std::string* TaskResp::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskResp::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskResp::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.handle)
}

// bool none = 5;
inline void TaskResp::clear_none() {
  none_ = false;
}
inline bool TaskResp::none() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.none)
  return none_;
}
inline void TaskResp::set_none(bool value) {
  
  none_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskResp.none)
}

// .tortuga.TaskResp.RetryContext retry_ctx = 6;
inline bool TaskResp::has_retry_ctx() const {
  return this != internal_default_instance() && retry_ctx_ != NULL;
}
inline void TaskResp::clear_retry_ctx() {
  if (GetArenaNoVirtual() == NULL && retry_ctx_ != NULL) {
    delete retry_ctx_;
  }
  retry_ctx_ = NULL;
}
inline const ::tortuga::TaskResp_RetryContext& TaskResp::retry_ctx() const {
  const ::tortuga::TaskResp_RetryContext* p = retry_ctx_;
  // @@protoc_insertion_point(field_get:tortuga.TaskResp.retry_ctx)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::TaskResp_RetryContext*>(
      &::tortuga::_TaskResp_RetryContext_default_instance_);
}
inline ::tortuga::TaskResp_RetryContext* TaskResp::release_retry_ctx() {
  // @@protoc_insertion_point(field_release:tortuga.TaskResp.retry_ctx)
  
  ::tortuga::TaskResp_RetryContext* temp = retry_ctx_;
  retry_ctx_ = NULL;
  return temp;
}
inline ::tortuga::TaskResp_RetryContext* TaskResp::mutable_retry_ctx() {
  
  if (retry_ctx_ == NULL) {
    retry_ctx_ = new ::tortuga::TaskResp_RetryContext;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskResp.retry_ctx)
  return retry_ctx_;
}
inline void TaskResp::set_allocated_retry_ctx(::tortuga::TaskResp_RetryContext* retry_ctx) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete retry_ctx_;
  }
  if (retry_ctx) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      retry_ctx = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, retry_ctx, submessage_arena);
    }
    
  } else {
    
  }
  retry_ctx_ = retry_ctx;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskResp.retry_ctx)
}

// -------------------------------------------------------------------

// Task

// string id = 1;
inline void Task::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::id() const {
  // @@protoc_insertion_point(field_get:tortuga.Task.id)
  return id_.GetNoArena();
}
inline void Task::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.Task.id)
}
#if LANG_CXX11
inline void Task::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.Task.id)
}
#endif
inline void Task::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.Task.id)
}
inline void Task::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.Task.id)
}
inline ::std::string* Task::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.Task.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_id() {
  // @@protoc_insertion_point(field_release:tortuga.Task.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.id)
}

// string type = 2;
inline void Task::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Task::type() const {
  // @@protoc_insertion_point(field_get:tortuga.Task.type)
  return type_.GetNoArena();
}
inline void Task::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.Task.type)
}
#if LANG_CXX11
inline void Task::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.Task.type)
}
#endif
inline void Task::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.Task.type)
}
inline void Task::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.Task.type)
}
inline ::std::string* Task::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.Task.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_type() {
  // @@protoc_insertion_point(field_release:tortuga.Task.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.type)
}

// .google.protobuf.Any data = 3;
inline bool Task::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline const ::google::protobuf::Any& Task::data() const {
  const ::google::protobuf::Any* p = data_;
  // @@protoc_insertion_point(field_get:tortuga.Task.data)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Task::release_data() {
  // @@protoc_insertion_point(field_release:tortuga.Task.data)
  
  ::google::protobuf::Any* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* Task::mutable_data() {
  
  if (data_ == NULL) {
    data_ = new ::google::protobuf::Any;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.Task.data)
  return data_;
}
inline void Task::set_allocated_data(::google::protobuf::Any* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(data_);
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.data)
}

// .google.protobuf.Int32Value priority = 4;
inline bool Task::has_priority() const {
  return this != internal_default_instance() && priority_ != NULL;
}
inline const ::google::protobuf::Int32Value& Task::priority() const {
  const ::google::protobuf::Int32Value* p = priority_;
  // @@protoc_insertion_point(field_get:tortuga.Task.priority)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Task::release_priority() {
  // @@protoc_insertion_point(field_release:tortuga.Task.priority)
  
  ::google::protobuf::Int32Value* temp = priority_;
  priority_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Task::mutable_priority() {
  
  if (priority_ == NULL) {
    priority_ = new ::google::protobuf::Int32Value;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.Task.priority)
  return priority_;
}
inline void Task::set_allocated_priority(::google::protobuf::Int32Value* priority) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(priority_);
  }
  if (priority) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(priority)->GetArena();
    if (message_arena != submessage_arena) {
      priority = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    
  } else {
    
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.priority)
}

// .google.protobuf.Int32Value max_retries = 5;
inline bool Task::has_max_retries() const {
  return this != internal_default_instance() && max_retries_ != NULL;
}
inline const ::google::protobuf::Int32Value& Task::max_retries() const {
  const ::google::protobuf::Int32Value* p = max_retries_;
  // @@protoc_insertion_point(field_get:tortuga.Task.max_retries)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int32Value*>(
      &::google::protobuf::_Int32Value_default_instance_);
}
inline ::google::protobuf::Int32Value* Task::release_max_retries() {
  // @@protoc_insertion_point(field_release:tortuga.Task.max_retries)
  
  ::google::protobuf::Int32Value* temp = max_retries_;
  max_retries_ = NULL;
  return temp;
}
inline ::google::protobuf::Int32Value* Task::mutable_max_retries() {
  
  if (max_retries_ == NULL) {
    max_retries_ = new ::google::protobuf::Int32Value;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.Task.max_retries)
  return max_retries_;
}
inline void Task::set_allocated_max_retries(::google::protobuf::Int32Value* max_retries) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(max_retries_);
  }
  if (max_retries) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(max_retries)->GetArena();
    if (message_arena != submessage_arena) {
      max_retries = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, max_retries, submessage_arena);
    }
    
  } else {
    
  }
  max_retries_ = max_retries;
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.max_retries)
}

// .google.protobuf.Duration delay = 6;
inline bool Task::has_delay() const {
  return this != internal_default_instance() && delay_ != NULL;
}
inline const ::google::protobuf::Duration& Task::delay() const {
  const ::google::protobuf::Duration* p = delay_;
  // @@protoc_insertion_point(field_get:tortuga.Task.delay)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Task::release_delay() {
  // @@protoc_insertion_point(field_release:tortuga.Task.delay)
  
  ::google::protobuf::Duration* temp = delay_;
  delay_ = NULL;
  return temp;
}
inline ::google::protobuf::Duration* Task::mutable_delay() {
  
  if (delay_ == NULL) {
    delay_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.Task.delay)
  return delay_;
}
inline void Task::set_allocated_delay(::google::protobuf::Duration* delay) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(delay_);
  }
  if (delay) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(delay)->GetArena();
    if (message_arena != submessage_arena) {
      delay = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delay, submessage_arena);
    }
    
  } else {
    
  }
  delay_ = delay;
  // @@protoc_insertion_point(field_set_allocated:tortuga.Task.delay)
}

// repeated string modules = 7;
inline int Task::modules_size() const {
  return modules_.size();
}
inline void Task::clear_modules() {
  modules_.Clear();
}
inline const ::std::string& Task::modules(int index) const {
  // @@protoc_insertion_point(field_get:tortuga.Task.modules)
  return modules_.Get(index);
}
inline ::std::string* Task::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:tortuga.Task.modules)
  return modules_.Mutable(index);
}
inline void Task::set_modules(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tortuga.Task.modules)
  modules_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Task::set_modules(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tortuga.Task.modules)
  modules_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Task::set_modules(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  modules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tortuga.Task.modules)
}
inline void Task::set_modules(int index, const char* value, size_t size) {
  modules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tortuga.Task.modules)
}
inline ::std::string* Task::add_modules() {
  // @@protoc_insertion_point(field_add_mutable:tortuga.Task.modules)
  return modules_.Add();
}
inline void Task::add_modules(const ::std::string& value) {
  modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tortuga.Task.modules)
}
#if LANG_CXX11
inline void Task::add_modules(::std::string&& value) {
  modules_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tortuga.Task.modules)
}
#endif
inline void Task::add_modules(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tortuga.Task.modules)
}
inline void Task::add_modules(const char* value, size_t size) {
  modules_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tortuga.Task.modules)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Task::modules() const {
  // @@protoc_insertion_point(field_list:tortuga.Task.modules)
  return modules_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Task::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:tortuga.Task.modules)
  return &modules_;
}

// -------------------------------------------------------------------

// TaskProgress

// string handle = 1;
inline void TaskProgress::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.handle)
  return handle_.GetNoArena();
}
inline void TaskProgress::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.handle)
}
#if LANG_CXX11
inline void TaskProgress::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.handle)
}
#endif
inline void TaskProgress::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.handle)
}
inline void TaskProgress::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.handle)
}
inline ::std::string* TaskProgress::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.handle)
}

// string id = 2;
inline void TaskProgress::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::id() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.id)
  return id_.GetNoArena();
}
inline void TaskProgress::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.id)
}
#if LANG_CXX11
inline void TaskProgress::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.id)
}
#endif
inline void TaskProgress::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.id)
}
inline void TaskProgress::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.id)
}
inline ::std::string* TaskProgress::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_id() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.id)
}

// string type = 3;
inline void TaskProgress::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::type() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.type)
  return type_.GetNoArena();
}
inline void TaskProgress::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.type)
}
#if LANG_CXX11
inline void TaskProgress::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.type)
}
#endif
inline void TaskProgress::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.type)
}
inline void TaskProgress::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.type)
}
inline ::std::string* TaskProgress::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_type() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.type)
}

// int32 max_retries = 4;
inline void TaskProgress::clear_max_retries() {
  max_retries_ = 0;
}
inline ::google::protobuf::int32 TaskProgress::max_retries() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.max_retries)
  return max_retries_;
}
inline void TaskProgress::set_max_retries(::google::protobuf::int32 value) {
  
  max_retries_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.max_retries)
}

// int32 retries = 5;
inline void TaskProgress::clear_retries() {
  retries_ = 0;
}
inline ::google::protobuf::int32 TaskProgress::retries() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.retries)
  return retries_;
}
inline void TaskProgress::set_retries(::google::protobuf::int32 value) {
  
  retries_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.retries)
}

// int32 priority = 6;
inline void TaskProgress::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 TaskProgress::priority() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.priority)
  return priority_;
}
inline void TaskProgress::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.priority)
}

// bool worked_on = 7;
inline void TaskProgress::clear_worked_on() {
  worked_on_ = false;
}
inline bool TaskProgress::worked_on() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.worked_on)
  return worked_on_;
}
inline void TaskProgress::set_worked_on(bool value) {
  
  worked_on_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.worked_on)
}

// bool done = 8;
inline void TaskProgress::clear_done() {
  done_ = false;
}
inline bool TaskProgress::done() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.done)
  return done_;
}
inline void TaskProgress::set_done(bool value) {
  
  done_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.done)
}

// .google.protobuf.Timestamp created = 9;
inline bool TaskProgress::has_created() const {
  return this != internal_default_instance() && created_ != NULL;
}
inline const ::google::protobuf::Timestamp& TaskProgress::created() const {
  const ::google::protobuf::Timestamp* p = created_;
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.created)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TaskProgress::release_created() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.created)
  
  ::google::protobuf::Timestamp* temp = created_;
  created_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* TaskProgress::mutable_created() {
  
  if (created_ == NULL) {
    created_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.created)
  return created_;
}
inline void TaskProgress::set_allocated_created(::google::protobuf::Timestamp* created) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(created_);
  }
  if (created) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(created)->GetArena();
    if (message_arena != submessage_arena) {
      created = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.created)
}

// .google.protobuf.Timestamp started_time = 10;
inline bool TaskProgress::has_started_time() const {
  return this != internal_default_instance() && started_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& TaskProgress::started_time() const {
  const ::google::protobuf::Timestamp* p = started_time_;
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.started_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TaskProgress::release_started_time() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.started_time)
  
  ::google::protobuf::Timestamp* temp = started_time_;
  started_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* TaskProgress::mutable_started_time() {
  
  if (started_time_ == NULL) {
    started_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.started_time)
  return started_time_;
}
inline void TaskProgress::set_allocated_started_time(::google::protobuf::Timestamp* started_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(started_time_);
  }
  if (started_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(started_time)->GetArena();
    if (message_arena != submessage_arena) {
      started_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, started_time, submessage_arena);
    }
    
  } else {
    
  }
  started_time_ = started_time;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.started_time)
}

// .google.protobuf.Timestamp done_time = 11;
inline bool TaskProgress::has_done_time() const {
  return this != internal_default_instance() && done_time_ != NULL;
}
inline const ::google::protobuf::Timestamp& TaskProgress::done_time() const {
  const ::google::protobuf::Timestamp* p = done_time_;
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.done_time)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* TaskProgress::release_done_time() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.done_time)
  
  ::google::protobuf::Timestamp* temp = done_time_;
  done_time_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* TaskProgress::mutable_done_time() {
  
  if (done_time_ == NULL) {
    done_time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.done_time)
  return done_time_;
}
inline void TaskProgress::set_allocated_done_time(::google::protobuf::Timestamp* done_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(done_time_);
  }
  if (done_time) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(done_time)->GetArena();
    if (message_arena != submessage_arena) {
      done_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, done_time, submessage_arena);
    }
    
  } else {
    
  }
  done_time_ = done_time;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.done_time)
}

// .google.rpc.Status status = 12;
inline bool TaskProgress::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline const ::google::rpc::Status& TaskProgress::status() const {
  const ::google::rpc::Status* p = status_;
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.status)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* TaskProgress::release_status() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.status)
  
  ::google::rpc::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::google::rpc::Status* TaskProgress::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.status)
  return status_;
}
inline void TaskProgress::set_allocated_status(::google::rpc::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.status)
}

// float progress = 13;
inline void TaskProgress::clear_progress() {
  progress_ = 0;
}
inline float TaskProgress::progress() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.progress)
  return progress_;
}
inline void TaskProgress::set_progress(float value) {
  
  progress_ = value;
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.progress)
}

// string progress_message = 14;
inline void TaskProgress::clear_progress_message() {
  progress_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::progress_message() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.progress_message)
  return progress_message_.GetNoArena();
}
inline void TaskProgress::set_progress_message(const ::std::string& value) {
  
  progress_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.progress_message)
}
#if LANG_CXX11
inline void TaskProgress::set_progress_message(::std::string&& value) {
  
  progress_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.progress_message)
}
#endif
inline void TaskProgress::set_progress_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  progress_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.progress_message)
}
inline void TaskProgress::set_progress_message(const char* value, size_t size) {
  
  progress_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.progress_message)
}
inline ::std::string* TaskProgress::mutable_progress_message() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.progress_message)
  return progress_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_progress_message() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.progress_message)
  
  return progress_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_progress_message(::std::string* progress_message) {
  if (progress_message != NULL) {
    
  } else {
    
  }
  progress_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), progress_message);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.progress_message)
}

// string progress_metadata = 18;
inline void TaskProgress::clear_progress_metadata() {
  progress_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::progress_metadata() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.progress_metadata)
  return progress_metadata_.GetNoArena();
}
inline void TaskProgress::set_progress_metadata(const ::std::string& value) {
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.progress_metadata)
}
#if LANG_CXX11
inline void TaskProgress::set_progress_metadata(::std::string&& value) {
  
  progress_metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.progress_metadata)
}
#endif
inline void TaskProgress::set_progress_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.progress_metadata)
}
inline void TaskProgress::set_progress_metadata(const char* value, size_t size) {
  
  progress_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.progress_metadata)
}
inline ::std::string* TaskProgress::mutable_progress_metadata() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.progress_metadata)
  return progress_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_progress_metadata() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.progress_metadata)
  
  return progress_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_progress_metadata(::std::string* progress_metadata) {
  if (progress_metadata != NULL) {
    
  } else {
    
  }
  progress_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), progress_metadata);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.progress_metadata)
}

// string logs = 15;
inline void TaskProgress::clear_logs() {
  logs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::logs() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.logs)
  return logs_.GetNoArena();
}
inline void TaskProgress::set_logs(const ::std::string& value) {
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.logs)
}
#if LANG_CXX11
inline void TaskProgress::set_logs(::std::string&& value) {
  
  logs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.logs)
}
#endif
inline void TaskProgress::set_logs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.logs)
}
inline void TaskProgress::set_logs(const char* value, size_t size) {
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.logs)
}
inline ::std::string* TaskProgress::mutable_logs() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.logs)
  return logs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_logs() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.logs)
  
  return logs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_logs(::std::string* logs) {
  if (logs != NULL) {
    
  } else {
    
  }
  logs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), logs);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.logs)
}

// string worker_id = 16;
inline void TaskProgress::clear_worker_id() {
  worker_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::worker_id() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.worker_id)
  return worker_id_.GetNoArena();
}
inline void TaskProgress::set_worker_id(const ::std::string& value) {
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.worker_id)
}
#if LANG_CXX11
inline void TaskProgress::set_worker_id(::std::string&& value) {
  
  worker_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.worker_id)
}
#endif
inline void TaskProgress::set_worker_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.worker_id)
}
inline void TaskProgress::set_worker_id(const char* value, size_t size) {
  
  worker_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.worker_id)
}
inline ::std::string* TaskProgress::mutable_worker_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.worker_id)
  return worker_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_worker_id() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.worker_id)
  
  return worker_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_worker_id(::std::string* worker_id) {
  if (worker_id != NULL) {
    
  } else {
    
  }
  worker_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.worker_id)
}

// string output = 17;
inline void TaskProgress::clear_output() {
  output_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskProgress::output() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskProgress.output)
  return output_.GetNoArena();
}
inline void TaskProgress::set_output(const ::std::string& value) {
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskProgress.output)
}
#if LANG_CXX11
inline void TaskProgress::set_output(::std::string&& value) {
  
  output_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskProgress.output)
}
#endif
inline void TaskProgress::set_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskProgress.output)
}
inline void TaskProgress::set_output(const char* value, size_t size) {
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskProgress.output)
}
inline ::std::string* TaskProgress::mutable_output() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskProgress.output)
  return output_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskProgress::release_output() {
  // @@protoc_insertion_point(field_release:tortuga.TaskProgress.output)
  
  return output_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskProgress::set_allocated_output(::std::string* output) {
  if (output != NULL) {
    
  } else {
    
  }
  output_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskProgress.output)
}

// -------------------------------------------------------------------

// CreateReq

// .tortuga.Task task = 1;
inline bool CreateReq::has_task() const {
  return this != internal_default_instance() && task_ != NULL;
}
inline void CreateReq::clear_task() {
  if (GetArenaNoVirtual() == NULL && task_ != NULL) {
    delete task_;
  }
  task_ = NULL;
}
inline const ::tortuga::Task& CreateReq::task() const {
  const ::tortuga::Task* p = task_;
  // @@protoc_insertion_point(field_get:tortuga.CreateReq.task)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::Task*>(
      &::tortuga::_Task_default_instance_);
}
inline ::tortuga::Task* CreateReq::release_task() {
  // @@protoc_insertion_point(field_release:tortuga.CreateReq.task)
  
  ::tortuga::Task* temp = task_;
  task_ = NULL;
  return temp;
}
inline ::tortuga::Task* CreateReq::mutable_task() {
  
  if (task_ == NULL) {
    task_ = new ::tortuga::Task;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.CreateReq.task)
  return task_;
}
inline void CreateReq::set_allocated_task(::tortuga::Task* task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_;
  }
  if (task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  task_ = task;
  // @@protoc_insertion_point(field_set_allocated:tortuga.CreateReq.task)
}

// -------------------------------------------------------------------

// CreateResp

// string handle = 1;
inline void CreateResp::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateResp::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.CreateResp.handle)
  return handle_.GetNoArena();
}
inline void CreateResp::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.CreateResp.handle)
}
#if LANG_CXX11
inline void CreateResp::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.CreateResp.handle)
}
#endif
inline void CreateResp::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.CreateResp.handle)
}
inline void CreateResp::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.CreateResp.handle)
}
inline ::std::string* CreateResp::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.CreateResp.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateResp::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.CreateResp.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateResp::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.CreateResp.handle)
}

// bool created = 2;
inline void CreateResp::clear_created() {
  created_ = false;
}
inline bool CreateResp::created() const {
  // @@protoc_insertion_point(field_get:tortuga.CreateResp.created)
  return created_;
}
inline void CreateResp::set_created(bool value) {
  
  created_ = value;
  // @@protoc_insertion_point(field_set:tortuga.CreateResp.created)
}

// -------------------------------------------------------------------

// CompleteTaskReq

// .tortuga.Worker worker = 1;
inline bool CompleteTaskReq::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void CompleteTaskReq::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) {
    delete worker_;
  }
  worker_ = NULL;
}
inline const ::tortuga::Worker& CompleteTaskReq::worker() const {
  const ::tortuga::Worker* p = worker_;
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.worker)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::Worker*>(
      &::tortuga::_Worker_default_instance_);
}
inline ::tortuga::Worker* CompleteTaskReq::release_worker() {
  // @@protoc_insertion_point(field_release:tortuga.CompleteTaskReq.worker)
  
  ::tortuga::Worker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline ::tortuga::Worker* CompleteTaskReq::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::tortuga::Worker;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.CompleteTaskReq.worker)
  return worker_;
}
inline void CompleteTaskReq::set_allocated_worker(::tortuga::Worker* worker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete worker_;
  }
  if (worker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      worker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, worker, submessage_arena);
    }
    
  } else {
    
  }
  worker_ = worker;
  // @@protoc_insertion_point(field_set_allocated:tortuga.CompleteTaskReq.worker)
}

// string handle = 2;
inline void CompleteTaskReq::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompleteTaskReq::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.handle)
  return handle_.GetNoArena();
}
inline void CompleteTaskReq::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.CompleteTaskReq.handle)
}
#if LANG_CXX11
inline void CompleteTaskReq::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.CompleteTaskReq.handle)
}
#endif
inline void CompleteTaskReq::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.CompleteTaskReq.handle)
}
inline void CompleteTaskReq::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.CompleteTaskReq.handle)
}
inline ::std::string* CompleteTaskReq::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.CompleteTaskReq.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompleteTaskReq::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.CompleteTaskReq.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompleteTaskReq::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.CompleteTaskReq.handle)
}

// int32 code = 3;
inline void CompleteTaskReq::clear_code() {
  code_ = 0;
}
inline ::google::protobuf::int32 CompleteTaskReq::code() const {
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.code)
  return code_;
}
inline void CompleteTaskReq::set_code(::google::protobuf::int32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:tortuga.CompleteTaskReq.code)
}

// string error_message = 4;
inline void CompleteTaskReq::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompleteTaskReq::error_message() const {
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.error_message)
  return error_message_.GetNoArena();
}
inline void CompleteTaskReq::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.CompleteTaskReq.error_message)
}
#if LANG_CXX11
inline void CompleteTaskReq::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.CompleteTaskReq.error_message)
}
#endif
inline void CompleteTaskReq::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.CompleteTaskReq.error_message)
}
inline void CompleteTaskReq::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.CompleteTaskReq.error_message)
}
inline ::std::string* CompleteTaskReq::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.CompleteTaskReq.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompleteTaskReq::release_error_message() {
  // @@protoc_insertion_point(field_release:tortuga.CompleteTaskReq.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompleteTaskReq::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tortuga.CompleteTaskReq.error_message)
}

// string logs = 5;
inline void CompleteTaskReq::clear_logs() {
  logs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompleteTaskReq::logs() const {
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.logs)
  return logs_.GetNoArena();
}
inline void CompleteTaskReq::set_logs(const ::std::string& value) {
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.CompleteTaskReq.logs)
}
#if LANG_CXX11
inline void CompleteTaskReq::set_logs(::std::string&& value) {
  
  logs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.CompleteTaskReq.logs)
}
#endif
inline void CompleteTaskReq::set_logs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.CompleteTaskReq.logs)
}
inline void CompleteTaskReq::set_logs(const char* value, size_t size) {
  
  logs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.CompleteTaskReq.logs)
}
inline ::std::string* CompleteTaskReq::mutable_logs() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.CompleteTaskReq.logs)
  return logs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompleteTaskReq::release_logs() {
  // @@protoc_insertion_point(field_release:tortuga.CompleteTaskReq.logs)
  
  return logs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompleteTaskReq::set_allocated_logs(::std::string* logs) {
  if (logs != NULL) {
    
  } else {
    
  }
  logs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), logs);
  // @@protoc_insertion_point(field_set_allocated:tortuga.CompleteTaskReq.logs)
}

// string output = 6;
inline void CompleteTaskReq::clear_output() {
  output_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompleteTaskReq::output() const {
  // @@protoc_insertion_point(field_get:tortuga.CompleteTaskReq.output)
  return output_.GetNoArena();
}
inline void CompleteTaskReq::set_output(const ::std::string& value) {
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.CompleteTaskReq.output)
}
#if LANG_CXX11
inline void CompleteTaskReq::set_output(::std::string&& value) {
  
  output_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.CompleteTaskReq.output)
}
#endif
inline void CompleteTaskReq::set_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.CompleteTaskReq.output)
}
inline void CompleteTaskReq::set_output(const char* value, size_t size) {
  
  output_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.CompleteTaskReq.output)
}
inline ::std::string* CompleteTaskReq::mutable_output() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.CompleteTaskReq.output)
  return output_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompleteTaskReq::release_output() {
  // @@protoc_insertion_point(field_release:tortuga.CompleteTaskReq.output)
  
  return output_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompleteTaskReq::set_allocated_output(::std::string* output) {
  if (output != NULL) {
    
  } else {
    
  }
  output_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output);
  // @@protoc_insertion_point(field_set_allocated:tortuga.CompleteTaskReq.output)
}

// -------------------------------------------------------------------

// UpdateProgressReq

// .tortuga.Worker worker = 1;
inline bool UpdateProgressReq::has_worker() const {
  return this != internal_default_instance() && worker_ != NULL;
}
inline void UpdateProgressReq::clear_worker() {
  if (GetArenaNoVirtual() == NULL && worker_ != NULL) {
    delete worker_;
  }
  worker_ = NULL;
}
inline const ::tortuga::Worker& UpdateProgressReq::worker() const {
  const ::tortuga::Worker* p = worker_;
  // @@protoc_insertion_point(field_get:tortuga.UpdateProgressReq.worker)
  return p != NULL ? *p : *reinterpret_cast<const ::tortuga::Worker*>(
      &::tortuga::_Worker_default_instance_);
}
inline ::tortuga::Worker* UpdateProgressReq::release_worker() {
  // @@protoc_insertion_point(field_release:tortuga.UpdateProgressReq.worker)
  
  ::tortuga::Worker* temp = worker_;
  worker_ = NULL;
  return temp;
}
inline ::tortuga::Worker* UpdateProgressReq::mutable_worker() {
  
  if (worker_ == NULL) {
    worker_ = new ::tortuga::Worker;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.UpdateProgressReq.worker)
  return worker_;
}
inline void UpdateProgressReq::set_allocated_worker(::tortuga::Worker* worker) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete worker_;
  }
  if (worker) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      worker = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, worker, submessage_arena);
    }
    
  } else {
    
  }
  worker_ = worker;
  // @@protoc_insertion_point(field_set_allocated:tortuga.UpdateProgressReq.worker)
}

// string handle = 2;
inline void UpdateProgressReq::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateProgressReq::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.UpdateProgressReq.handle)
  return handle_.GetNoArena();
}
inline void UpdateProgressReq::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.UpdateProgressReq.handle)
}
#if LANG_CXX11
inline void UpdateProgressReq::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.UpdateProgressReq.handle)
}
#endif
inline void UpdateProgressReq::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.UpdateProgressReq.handle)
}
inline void UpdateProgressReq::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.UpdateProgressReq.handle)
}
inline ::std::string* UpdateProgressReq::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.UpdateProgressReq.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateProgressReq::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.UpdateProgressReq.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateProgressReq::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.UpdateProgressReq.handle)
}

// .google.protobuf.FloatValue progress = 3;
inline bool UpdateProgressReq::has_progress() const {
  return this != internal_default_instance() && progress_ != NULL;
}
inline const ::google::protobuf::FloatValue& UpdateProgressReq::progress() const {
  const ::google::protobuf::FloatValue* p = progress_;
  // @@protoc_insertion_point(field_get:tortuga.UpdateProgressReq.progress)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::FloatValue*>(
      &::google::protobuf::_FloatValue_default_instance_);
}
inline ::google::protobuf::FloatValue* UpdateProgressReq::release_progress() {
  // @@protoc_insertion_point(field_release:tortuga.UpdateProgressReq.progress)
  
  ::google::protobuf::FloatValue* temp = progress_;
  progress_ = NULL;
  return temp;
}
inline ::google::protobuf::FloatValue* UpdateProgressReq::mutable_progress() {
  
  if (progress_ == NULL) {
    progress_ = new ::google::protobuf::FloatValue;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.UpdateProgressReq.progress)
  return progress_;
}
inline void UpdateProgressReq::set_allocated_progress(::google::protobuf::FloatValue* progress) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(progress_);
  }
  if (progress) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(progress)->GetArena();
    if (message_arena != submessage_arena) {
      progress = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, progress, submessage_arena);
    }
    
  } else {
    
  }
  progress_ = progress;
  // @@protoc_insertion_point(field_set_allocated:tortuga.UpdateProgressReq.progress)
}

// .google.protobuf.StringValue progress_message = 4;
inline bool UpdateProgressReq::has_progress_message() const {
  return this != internal_default_instance() && progress_message_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateProgressReq::progress_message() const {
  const ::google::protobuf::StringValue* p = progress_message_;
  // @@protoc_insertion_point(field_get:tortuga.UpdateProgressReq.progress_message)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateProgressReq::release_progress_message() {
  // @@protoc_insertion_point(field_release:tortuga.UpdateProgressReq.progress_message)
  
  ::google::protobuf::StringValue* temp = progress_message_;
  progress_message_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateProgressReq::mutable_progress_message() {
  
  if (progress_message_ == NULL) {
    progress_message_ = new ::google::protobuf::StringValue;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.UpdateProgressReq.progress_message)
  return progress_message_;
}
inline void UpdateProgressReq::set_allocated_progress_message(::google::protobuf::StringValue* progress_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(progress_message_);
  }
  if (progress_message) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(progress_message)->GetArena();
    if (message_arena != submessage_arena) {
      progress_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, progress_message, submessage_arena);
    }
    
  } else {
    
  }
  progress_message_ = progress_message;
  // @@protoc_insertion_point(field_set_allocated:tortuga.UpdateProgressReq.progress_message)
}

// .google.protobuf.StringValue progress_metadata = 5;
inline bool UpdateProgressReq::has_progress_metadata() const {
  return this != internal_default_instance() && progress_metadata_ != NULL;
}
inline const ::google::protobuf::StringValue& UpdateProgressReq::progress_metadata() const {
  const ::google::protobuf::StringValue* p = progress_metadata_;
  // @@protoc_insertion_point(field_get:tortuga.UpdateProgressReq.progress_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* UpdateProgressReq::release_progress_metadata() {
  // @@protoc_insertion_point(field_release:tortuga.UpdateProgressReq.progress_metadata)
  
  ::google::protobuf::StringValue* temp = progress_metadata_;
  progress_metadata_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* UpdateProgressReq::mutable_progress_metadata() {
  
  if (progress_metadata_ == NULL) {
    progress_metadata_ = new ::google::protobuf::StringValue;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.UpdateProgressReq.progress_metadata)
  return progress_metadata_;
}
inline void UpdateProgressReq::set_allocated_progress_metadata(::google::protobuf::StringValue* progress_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(progress_metadata_);
  }
  if (progress_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast< ::google::protobuf::MessageLite*>(progress_metadata)->GetArena();
    if (message_arena != submessage_arena) {
      progress_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, progress_metadata, submessage_arena);
    }
    
  } else {
    
  }
  progress_metadata_ = progress_metadata;
  // @@protoc_insertion_point(field_set_allocated:tortuga.UpdateProgressReq.progress_metadata)
}

// -------------------------------------------------------------------

// ProgressReq

// string handle = 1;
inline void ProgressReq::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProgressReq::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.ProgressReq.handle)
  return handle_.GetNoArena();
}
inline void ProgressReq::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.ProgressReq.handle)
}
#if LANG_CXX11
inline void ProgressReq::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.ProgressReq.handle)
}
#endif
inline void ProgressReq::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.ProgressReq.handle)
}
inline void ProgressReq::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.ProgressReq.handle)
}
inline ::std::string* ProgressReq::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.ProgressReq.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProgressReq::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.ProgressReq.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProgressReq::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.ProgressReq.handle)
}

// -------------------------------------------------------------------

// ProgressResp

// string handle = 1;
inline void ProgressResp::clear_handle() {
  handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProgressResp::handle() const {
  // @@protoc_insertion_point(field_get:tortuga.ProgressResp.handle)
  return handle_.GetNoArena();
}
inline void ProgressResp::set_handle(const ::std::string& value) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.ProgressResp.handle)
}
#if LANG_CXX11
inline void ProgressResp::set_handle(::std::string&& value) {
  
  handle_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.ProgressResp.handle)
}
#endif
inline void ProgressResp::set_handle(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.ProgressResp.handle)
}
inline void ProgressResp::set_handle(const char* value, size_t size) {
  
  handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.ProgressResp.handle)
}
inline ::std::string* ProgressResp::mutable_handle() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.ProgressResp.handle)
  return handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProgressResp::release_handle() {
  // @@protoc_insertion_point(field_release:tortuga.ProgressResp.handle)
  
  return handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProgressResp::set_allocated_handle(::std::string* handle) {
  if (handle != NULL) {
    
  } else {
    
  }
  handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), handle);
  // @@protoc_insertion_point(field_set_allocated:tortuga.ProgressResp.handle)
}

// .google.rpc.Status status = 2;
inline bool ProgressResp::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline const ::google::rpc::Status& ProgressResp::status() const {
  const ::google::rpc::Status* p = status_;
  // @@protoc_insertion_point(field_get:tortuga.ProgressResp.status)
  return p != NULL ? *p : *reinterpret_cast<const ::google::rpc::Status*>(
      &::google::rpc::_Status_default_instance_);
}
inline ::google::rpc::Status* ProgressResp::release_status() {
  // @@protoc_insertion_point(field_release:tortuga.ProgressResp.status)
  
  ::google::rpc::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::google::rpc::Status* ProgressResp::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::google::rpc::Status;
  }
  // @@protoc_insertion_point(field_mutable:tortuga.ProgressResp.status)
  return status_;
}
inline void ProgressResp::set_allocated_status(::google::rpc::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:tortuga.ProgressResp.status)
}

// -------------------------------------------------------------------

// TaskIdentifier

// string id = 1;
inline void TaskIdentifier::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskIdentifier::id() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskIdentifier.id)
  return id_.GetNoArena();
}
inline void TaskIdentifier::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskIdentifier.id)
}
#if LANG_CXX11
inline void TaskIdentifier::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskIdentifier.id)
}
#endif
inline void TaskIdentifier::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskIdentifier.id)
}
inline void TaskIdentifier::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskIdentifier.id)
}
inline ::std::string* TaskIdentifier::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskIdentifier.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskIdentifier::release_id() {
  // @@protoc_insertion_point(field_release:tortuga.TaskIdentifier.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskIdentifier::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskIdentifier.id)
}

// string type = 2;
inline void TaskIdentifier::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskIdentifier::type() const {
  // @@protoc_insertion_point(field_get:tortuga.TaskIdentifier.type)
  return type_.GetNoArena();
}
inline void TaskIdentifier::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tortuga.TaskIdentifier.type)
}
#if LANG_CXX11
inline void TaskIdentifier::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tortuga.TaskIdentifier.type)
}
#endif
inline void TaskIdentifier::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tortuga.TaskIdentifier.type)
}
inline void TaskIdentifier::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tortuga.TaskIdentifier.type)
}
inline ::std::string* TaskIdentifier::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:tortuga.TaskIdentifier.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskIdentifier::release_type() {
  // @@protoc_insertion_point(field_release:tortuga.TaskIdentifier.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskIdentifier::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tortuga.TaskIdentifier.type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tortuga

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tortuga_2ftortuga_2eproto__INCLUDED
